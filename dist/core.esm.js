import{PublicKey as t,MAX_SEED_LENGTH as e,SystemProgram as n,SYSVAR_RENT_PUBKEY as o,SYSVAR_CLOCK_PUBKEY as i,AddressLookupTableAccount as a,ComputeBudgetProgram as s}from"@solana/web3.js";import r from"lru-cache";import{Market as u,OpenOrders as c,Orderbook as m}from"@project-serum/serum";import{calculateAmpFactor as d,decodeSwap as p,SWAP_PROGRAM_ID as l,StableSwap as h}from"@saberhq/stableswap-sdk";import{TokenSwapStable as g,Fraction as S,TokenSwapConstantProduct as k,toDecimal as f,Stable as y,ZERO_FRACTION as A,ZERO as M,TWO as w,ONE as T}from"@jup-ag/math";import P from"jsbi";import*as v from"fzstd";import{deserializeAccount as b,deserializeMint as I}from"@mercurial-finance/optimist";import{u64 as B,TOKEN_PROGRAM_ID as F,NATIVE_MINT as L,ASSOCIATED_TOKEN_PROGRAM_ID as D}from"@solana/spl-token";import q,{BN as x}from"bn.js";import{SYMMETRY_PROGRAM_ID as E,JUPITER_PROGRAM as O,ALDRIN_SWAP_PROGRAM_ID as C,ALDRIN_SWAP_V2_PROGRAM_ID as R,SABER_ADD_DECIMALS_PROGRAM_ID as V,LIFINITY_V2_PROGRAM_ID as N,CYKURA_PROGRAM_ID as U,CYKURA_FACTORY_STATE_ADDRESS as K,WHIRLPOOL_PROGRAM_ID as z,JUPITER_PROGRAM_ID as W,MARINADE_PROGRAM_ID as Q,INVARIANT_PROGRAM_ID as j,INVARIANT_STATE_ID as X,INVARIANT_PROGRAM_AUTHORITY_ID as Y,METEORA_PROGRAM_ID as _,METEORA_VAULT_PROGRAM_ID as $,GOOSE_FX_PROGRAM_ID as H,GOOSE_FX_CONTROLLER_ID as Z,DELTA_FI_PROGRAM_ID as J,DELTA_FI_USER_ID as G,BALANSOL_PROGRAM_ID as tt,DRADEX_PROGRAM_ID as et,DRADEX_DEX_USER as nt,DRADEX_MASTER_ID as ot,DRADEX_LOGGER_PROGRAM_ID as it,CREMA_PROGRAM_ID as at,CREMA_PARTNER_ACCOUNT as st,findAssociatedTokenAddress as rt,RAYDIUM_CLMM_PROGRAM_ID as ut,PHOENIX_PROGRAM_ID as ct,MERCURIAL_SWAP_PROGRAM_ID as mt,RAYDIUM_AMM_V4_PROGRAM_ID as dt,BONK_SWAP_PROGRAM_ID as pt,BONK_SWAP_STATE_ID as lt,BONK_SWAP_PROGRAM_AUTHORITY as ht,MARCO_POLO_PROGRAM_ID as gt,MARCO_POLO_STATE_ID as St,MARCO_POLO_PROGRAM_AUTHORITY as kt,OPENBOOK_PROGRAM_ID as ft,STEP_TOKEN_SWAP_PROGRAM_ID as yt,JUPITER_FEE_OWNER as At,ORCA_V1_PROGRAM_ID as Mt,ORCA_V2_PROGRAM_ID as wt,PENGUIN_PROGRAM_ID as Tt,SAROS_PROGRAM_ID as Pt,STEPN_PROGRAM_ID as vt,MAINNET_SERUM_DEX_PROGRAM as bt,DEVNET_SERUM_DEX_PROGRAM as It,CROPPER_PROGRAM_ID as Bt,SENCHA_PROGRAM_ID as Ft,LIFINITY_PROGRAM_ID as Lt,getEmptyInstruction as Dt,getAtaInstructions as qt,WRAPPED_SOL_MINT as xt,calculateTransactionDepositAndFee as Et,Owner as Ot,createAndCloseWSOLAccount as Ct,TransactionBuilder as Rt,executeTransaction as Vt,getRemoteRouteMap as Nt,MARKETS_URL as Ut}from"@jup-ag/common";export*from"@jup-ag/common";import{Layout as Kt,blob as zt,struct as Wt,u8 as Qt,u32 as jt,nu64 as Xt}from"@solana/buffer-layout";import{sha256 as Yt}from"@noble/hashes/sha256";import{AnchorProvider as _t,Program as $t,BorshAccountsCoder as Ht,BorshCoder as Zt,BN as Jt,utils as Gt}from"@coral-xyz/anchor";import te from"decimal.js";import{PDAUtil as ee,TickUtil as ne,TICK_ARRAY_SIZE as oe,computeSwap as ie,TickMath as ae,IDL as se}from"@jup-ag/crema-sdk-v2";import{tickPosition as re,TickMath as ue,generateBitmapWord as ce,TICK_SEED as me,u32ToSeed as de,BITMAP_SEED as pe,u16ToSeed as le,nextInitializedBit as he,buildTick as ge,Pool as Se,OBSERVATION_SEED as ke,IDL as fe}from"@jup-ag/cykura-sdk";import{Token as ye,CurrencyAmount as Ae}from"@jup-ag/cykura-sdk-core";import{getSwappedAmountsAndPriceImpactFromRawValue as Me,getDeltafiDexV2 as we}from"@jup-ag/deltafi-sdk";import{parsePriceData as Te}from"@pythnetwork/client";import{BigNumber as Pe}from"bignumber.js";import{PAIR_LAYOUT as ve,SyncSwap as be,SSL as Ie,wasm as Be,loadWasm as Fe}from"@jup-ag/goosefx-ssl-sdk";import{calculatePriceSqrt as Le,MIN_TICK as De,MAX_TICK as qe,toDecimal as xe,simulateSwap as Ee,findClosestTicks as Oe,TICK_CROSSES_PER_IX as Ce,IDL as Re,DENOMINATOR as Ve}from"@jup-ag/invariant";import{LIFINITY_AMM_LAYOUT as Ne,getParsedData as Ue,TradeDirection as Ke,getCurveAmount as ze}from"@jup-ag/lifinity-sdk";import{IDL as We,getParsedData as Qe,TradeDirection as je,getCurveAmount as Xe}from"@jup-ag/lifinity-sdk-v2";import{AmmIdl as Ye,PROGRAM_ID as _e,VaultIdl as $e,calculateSwapQuote as He,CURVE_TYPE_ACCOUNTS as Ze}from"@mercurial-finance/dynamic-amm-sdk";import{SwapUtils as Je,swapQuoteWithParams as Ge,ParsableWhirlpool as tn,ParsableTickArray as en}from"@jup-ag/whirlpools-sdk";import{dexCoder as nn,QuoteCalculator as on}from"@jup-ag/dradex-sdk";import{OrderBook as an}from"@jup-ag/dradex-idl";import{IDL as sn,Amm as rn}from"@jup-ag/raydium-clmm-sdk";import{deserializeMarketData as un,Market as cn,getMarketLadder as mn}from"@jup-ag/phoenix-sdk";import dn from"cross-fetch";const pn={Raydium:{Openbook:!0}},ln={Symmetry:!0,Openbook:!0,Cykura:!0,Meteora:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0,BonkSwap:!0,Oasis:!0},Crema:{Balansol:!0,Raydium:!0,Lifinity:!0,"Lifinity V2":!0},BonkSwap:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0,Oasis:!0},Oasis:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0,BonkSwap:!0},Dradex:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Raydium:!0},Balansol:{Raydium:!0},Lifinity:{Raydium:!0},"Lifinity V2":{Raydium:!0}},hn={Symmetry:!0,Raydium:!0,GooseFX:!0,Meteora:!0,Serum:!0,Openbook:!0,Dradex:!0,Crema:!0,Lifinity:!0,"Lifinity V2":!0},gn=(t,e,n)=>{const o=t[e];if(o){if(!0===o||!0===o["*"])return!0;if(n)return!0===o[n]}return!1},Sn=(t,e,n)=>gn(t,e,n)||!!n&&gn(t,n,e);function kn(t,e){return Array.apply(0,new Array(Math.ceil(t.length/e))).map(((n,o)=>t.slice(o*e,(o+1)*e)))}async function fn(e,n,o=1e3,i=100){return(await Promise.all(kn(n,o).map((async n=>{const o=kn(n,i).map((t=>({methodName:"getMultipleAccounts",args:e._buildArgs([t],e.commitment,"base64+zstd")})));return e._rpcBatchRequest(o).then((e=>e.reduce(((e,n)=>(n.result.value.forEach((n=>{if(n){const o=n;o.data=Buffer.from(v.decompress(Buffer.from(n.data[0],"base64"))),o.owner=new t(n.owner),e.push(o)}else e.push(null)})),e)),[]))).catch((t=>n.map((()=>null))))})))).flat()}var yn;!function(t){t.ExactIn="ExactIn",t.ExactOut="ExactOut"}(yn||(yn={}));const An=(t,e)=>e.map((e=>{const n=t.get(e.toString());if(!n)throw new Error(`Account info ${e.toBase58()} missing`);return n})),Mn=t=>t.map((t=>{const e=b(t.data);if(!e)throw new Error("Invalid token account");return e})).map((t=>P.BigInt(t.amount))),wn="Missing tokenReserveAmounts",Tn=async(t,e)=>{const n=t.map((t=>t.getAccountsForUpdate().map((t=>t.toBase58())))).flat(),o=new Map;(await fn(e,n)).forEach(((t,e)=>{t&&o.set(n[e],t)}));for(let e of t)e.update(o)};class Pn extends Kt{constructor(t){const e=zt(32);super(e.span,t),this.layout=void 0,this.layout=e}getSpan(t,e){return this.layout.getSpan(t,e)}decode(e,n){return new t(this.layout.decode(e,n))}encode(t,e,n){return this.layout.encode(t.toBuffer(),e,n)}}const vn=t=>new Pn(t);class bn extends Kt{constructor(t=8,e){const n=zt(t);super(n.span,e),this.layout=void 0,this.layout=n}getSpan(t,e){return this.layout.getSpan(t,e)}decode(t,e){return new B(this.layout.decode(t,e),10,"le")}encode(t,e,n){return this.layout.encode(t.toArrayLike(Buffer,"le",this.layout.span),e,n)}}const In=t=>new bn(8,t),Bn=t=>new bn(16,t),Fn=t=>Buffer.isBuffer(t)?t:t instanceof Uint8Array?Buffer.from(t.buffer,t.byteOffset,t.byteLength):Buffer.from(t);function Ln(n,o){let i=Buffer.alloc(0);n.forEach((function(t){if(t.length>e)throw new TypeError("Max seed length exceeded");i=Buffer.concat([i,Fn(t)])})),i=Buffer.concat([i,o.toBuffer(),Buffer.from("ProgramDerivedAddress")]);let a=Yt(new Uint8Array(i)),s=new q(a,16).toArray(void 0,32);return new t(s)}const Dn=Wt([Qt("version"),Qt("isInitialized"),Qt("nonce"),vn("ammId"),vn("serumProgramId"),vn("serumMarket"),vn("tokenProgramId"),vn("tokenAAccount"),vn("tokenBAccount"),vn("poolMint"),vn("mintA"),vn("mintB")]),qn=Wt([Qt("isInitialized"),vn("stateOwner"),vn("feeOwner"),In("initialSupply"),In("returnFeeNumerator"),In("fixedFeeNumerator"),In("feeDenominator"),Qt("curveType"),zt(32,"curveParameters")]),xn=new t("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),En=(t,e)=>{const n=e.owner,o=Dn.decode(e.data);return{programId:n,authority:Ln([t.toBuffer(),Buffer.from([o.nonce])],n),version:o.version,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:o.ammId,serumProgramId:o.serumProgramId,tokenProgramId:o.tokenProgramId,tokenAAccount:o.tokenAAccount,tokenBAccount:o.tokenBAccount,serumMarket:o.serumMarket,poolMint:o.poolMint,mintA:o.mintA,mintB:o.mintB}},On={Bid:{bid:{}},Ask:{ask:{}}},Cn=t=>({serum:{side:t}}),Rn=t=>({crema:{aToB:t}}),Vn=t=>({aldrin:{side:t}}),Nn=t=>({aldrinV2:{side:t}}),Un=t=>({whirlpool:{aToB:t}}),Kn=t=>({invariant:{xToY:t}}),zn=t=>({dradex:{side:t}}),Wn=t=>({marcoPolo:{xToY:t}}),Qn=t=>({openbook:{side:t}}),jn=t=>({phoenix:{side:t}}),Xn=(t,e)=>({symmetry:{fromTokenId:t,toTokenId:e}}),Yn=t=>({chain:{swapLegs:t}}),_n=t=>({split:{splitLegs:t}}),$n=t=>({swap:{swap:t}}),Hn=(t,e)=>({percent:t,swapLeg:e}),Zn=["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT","DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],Jn="development"===process.env.NODE_ENV,Gn="test"===process.env.NODE_ENV,to="production"===process.env.NODE_ENV,eo=100,no=new _t(null,null,{skipPreflight:!1}),oo=new $t({version:"0.1.0",name:"funds",instructions:[{name:"createFund",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"fundToken",isMut:!0,isSigner:!0},{name:"createFeeSweeper",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"messageDigestFive",type:{array:["u8",16]}},{name:"managerFee",type:"u64"},{name:"hostPubkey",type:"publicKey"},{name:"hostFee",type:"u64"},{name:"activelyManaged",type:"u64"},{name:"assetPool",type:{array:["u8",256]}},{name:"refilterInterval",type:"u64"},{name:"reweightInterval",type:"u64"},{name:"rebalanceInterval",type:"u64"},{name:"rebalanceThreshold",type:"u64"},{name:"rebalanceSlippage",type:"u64"},{name:"lpOffsetThreshold",type:"u64"},{name:"fundLpFee",type:"u64"}]},{name:"closeFund",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"fundToken",isMut:!0,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"setRules",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1}],args:[{name:"numOfRules",type:"u64"},{name:"rulesData",type:{array:["u8",512]}},{name:"ruleWeights",type:{array:["u64",20]}},{name:"ruleExpos",type:{array:["i64",20]}}]},{name:"fundEdit",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1}],args:[{name:"messageDigestFive",type:{array:["u8",16]}},{name:"managerFee",type:"u64"},{name:"activelyManaged",type:"u64"},{name:"assetPool",type:{array:["u8",256]}},{name:"refilterInterval",type:"u64"},{name:"reweightInterval",type:"u64"},{name:"rebalanceInterval",type:"u64"},{name:"rebalanceThreshold",type:"u64"},{name:"rebalanceSlippage",type:"u64"},{name:"lpOffsetThreshold",type:"u64"},{name:"fundLpFee",type:"u64"}]},{name:"buyFund",accounts:[{name:"buyer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaUsdcAccount",isMut:!0,isSigner:!1},{name:"buyerUsdcAccount",isMut:!0,isSigner:!1},{name:"managerUsdcAccount",isMut:!0,isSigner:!1},{name:"smfFeeAccount",isMut:!0,isSigner:!1},{name:"hostUsdcAccount",isMut:!0,isSigner:!1},{name:"buyerFundTokenAccount",isMut:!0,isSigner:!1},{name:"buyState",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"amount",type:"u64"}]},{name:"mintFund",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"buyer",isMut:!0,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"buyState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"buyerFundTokenAccount",isMut:!0,isSigner:!1},{name:"fundToken",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"swapFundTokens",accounts:[{name:"buyer",isMut:!1,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaFromTokenAccount",isMut:!0,isSigner:!1},{name:"buyerFromTokenAccount",isMut:!0,isSigner:!1},{name:"pdaToTokenAccount",isMut:!0,isSigner:!1},{name:"buyerToTokenAccount",isMut:!0,isSigner:!1},{name:"swapFeeAccount",isMut:!0,isSigner:!1},{name:"hostFeeAccount",isMut:!0,isSigner:!1},{name:"managerFeeAccount",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"curveData",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"fromTokenId",type:"u64"},{name:"toTokenId",type:"u64"},{name:"fromAmount",type:"u64"},{name:"minimumToAmount",type:"u64"}]},{name:"sellFund",accounts:[{name:"seller",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"newFundState",isMut:!0,isSigner:!1},{name:"sellerFundTokenAccount",isMut:!0,isSigner:!1},{name:"fundToken",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"amount",type:"u64"},{name:"rebalance",type:"u64"}]},{name:"claimToken",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"sellerTokenAccount",isMut:!0,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u64"}]},{name:"claimTokenFromBuyState",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"buyer",isMut:!0,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1},{name:"buyState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"buyerTokenAccount",isMut:!0,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u64"}]},{name:"updateCurrentWeights",accounts:[{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1}],args:[]},{name:"buyStateRebalance",accounts:[{name:"fundState",isMut:!0,isSigner:!1},{name:"buyState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"pythToken",isMut:!1,isSigner:!1},{name:"pythUsdc",isMut:!1,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaUsdcAccount",isMut:!0,isSigner:!1},{name:"rebalanceFeeAccount",isMut:!0,isSigner:!1},{name:"prismProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u8"},{name:"instructionId",type:{array:["u8",8]}},{name:"instructionSize",type:"u8"},{name:"instructionData",type:{array:["u8",28]}}]},{name:"rebalanceToUsdc",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"pythToken",isMut:!1,isSigner:!1},{name:"pythUsdc",isMut:!1,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaUsdcAccount",isMut:!0,isSigner:!1},{name:"rebalanceFeeAccount",isMut:!0,isSigner:!1},{name:"prismProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u8"},{name:"maxAmountToSell",type:"u64"},{name:"instructionId",type:{array:["u8",8]}},{name:"instructionSize",type:"u8"},{name:"instructionData",type:{array:["u8",28]}}]},{name:"rebalanceFromUsdc",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"pythToken",isMut:!1,isSigner:!1},{name:"pythUsdc",isMut:!1,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaUsdcAccount",isMut:!0,isSigner:!1},{name:"rebalanceFeeAccount",isMut:!0,isSigner:!1},{name:"prismProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u8"},{name:"maxAmountToSpend",type:"u64"},{name:"instructionId",type:{array:["u8",8]}},{name:"instructionSize",type:"u8"},{name:"instructionData",type:{array:["u8",28]}}]},{name:"reweight",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenStats",isMut:!1,isSigner:!1}],args:[]},{name:"refilter",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenStats",isMut:!1,isSigner:!1}],args:[]},{name:"addToken",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenMint",type:"publicKey"},{name:"pdaTokenAccount",type:"publicKey"},{name:"coingeckoId",type:{array:["u8",30]}},{name:"pyth",type:"publicKey"},{name:"decimals",type:"u8"},{name:"index",type:"u8"}]},{name:"updateDatabase",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"database",isMut:!0,isSigner:!1}],args:[{name:"tokenId",type:"u64"},{name:"price",type:"u64"},{name:"circulatingSupply",type:"u64"},{name:"volume",type:"u64"},{name:"timestamp",type:"u64"}]},{name:"updateTokenStats",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenStats",isMut:!0,isSigner:!1},{name:"database",isMut:!1,isSigner:!1}],args:[{name:"startIndex",type:"u8"},{name:"endIndex",type:"u8"}]},{name:"updateCurveData",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"curveData",isMut:!0,isSigner:!1}],args:[{name:"startIndex",type:"u8"},{name:"endIndex",type:"u8"},{name:"priceData",type:{array:[{array:[{array:[{array:["u64",2]},10]},2]},3]}}]},{name:"initializeTokenInfo",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"initializeDatabase",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"database",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"initializeTokenStats",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenStats",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"initializeCurveData",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"curveData",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeDatabase",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"database",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeTokenStats",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenStats",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeTokenInfo",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeToken",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"tokenAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeOpenOrders",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"pdaAccount",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"market",isMut:!1,isSigner:!1},{name:"serumDex",isMut:!1,isSigner:!1},{name:"serumSwapProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"fundState",type:{kind:"struct",fields:[{name:"version",type:"u64"},{name:"manager",type:"publicKey"},{name:"fundToken",type:"publicKey"},{name:"managerFee",type:"u64"},{name:"supplyOutsanding",type:"u64"},{name:"activelyManaged",type:"u64"},{name:"activeBuyStates",type:"u64"},{name:"sellState",type:"u64"},{name:"rebalanceSellState",type:"u64"},{name:"hostPubkey",type:"publicKey"},{name:"hostFee",type:"u64"},{name:"numOfTokens",type:"u64"},{name:"currentCompToken",type:{array:["u64",20]}},{name:"currentCompAmount",type:{array:["u64",20]}},{name:"lastRebalanceTime",type:{array:["u64",20]}},{name:"targetWeight",type:{array:["u64",20]}},{name:"weightSum",type:"u64"},{name:"currentWeight",type:{array:["u64",20]}},{name:"fundWorth",type:"u64"},{name:"lastUpdateTime",type:"u64"},{name:"refilterInterval",type:"u64"},{name:"reweightInterval",type:"u64"},{name:"rebalanceInterval",type:"u64"},{name:"rebalanceThreshold",type:"u64"},{name:"rebalanceSlippage",type:"u64"},{name:"lpOffsetThreshold",type:"u64"},{name:"lastRefilterTime",type:"u64"},{name:"lastReweightTime",type:"u64"},{name:"rulesReady",type:"u64"},{name:"assetPool",type:{array:["u64",200]}},{name:"numOfRules",type:"u64"},{name:"rules",type:{array:[{defined:"Rule"},20]}},{name:"numRuleTokens",type:"u64"},{name:"ruleTokens",type:{array:["u64",20]}},{name:"ruleTokenWeights",type:{array:["u64",20]}},{name:"messageDigestFive",type:{array:["u8",16]}},{name:"fundLpFee",type:"u64"},{name:"symmetryLpFee",type:"u64"},{name:"extraBytes",type:{array:["u64",96]}}]}},{name:"buyState",type:{kind:"struct",fields:[{name:"fund",type:"publicKey"},{name:"buyer",type:"publicKey"},{name:"fundManager",type:"publicKey"},{name:"hostPlatform",type:"publicKey"},{name:"buyerFundTokenAccount",type:"publicKey"},{name:"usdcContributed",type:"u64"},{name:"usdcLeft",type:"u64"},{name:"token",type:{array:["u64",20]}},{name:"amountToSpend",type:{array:["u64",20]}},{name:"amountBought",type:{array:["u64",20]}},{name:"creationTimestamp",type:"u64"},{name:"contributedValue",type:"u64"}]}},{name:"tokenInfo",type:{kind:"struct",fields:[{name:"numTokens",type:"u64"},{name:"tokenMint",type:{array:["publicKey",200]}},{name:"pdaTokenAccount",type:{array:["publicKey",200]}},{name:"coingeckoIds",type:{array:[{array:["u8",30]},200]}},{name:"pyth",type:{array:["publicKey",200]}},{name:"decimals",type:{array:["u8",200]}}]}},{name:"database",type:{kind:"struct",fields:[{name:"data",type:{array:[{defined:"TokenData"},200]}},{name:"numberOfTokens",type:"u64"}]}},{name:"tokenStats",type:{kind:"struct",fields:[{name:"stats",type:{array:[{array:[{defined:"Stats"},6]},200]}}]}},{name:"prismData",type:{kind:"struct",fields:[{name:"buy",type:{array:[{defined:"TokenPriceData"},200]}},{name:"sell",type:{array:[{defined:"TokenPriceData"},200]}}]}}],types:[{name:"Rule",type:{kind:"struct",fields:[{name:"filterBy",type:"u64"},{name:"filterDays",type:"u64"},{name:"sortBy",type:"u64"},{name:"totalWeight",type:"u64"},{name:"fixedAsset",type:"u64"},{name:"numAssets",type:"u64"},{name:"weightBy",type:"u64"},{name:"weightDays",type:"u64"},{name:"weightExpo",type:"i64"},{name:"excludeNum",type:"u64"},{name:"excludeAssets",type:{array:["u64",10]}},{name:"ruleAssets",type:{array:["u64",20]}}]}},{name:"TokenData",type:{kind:"struct",fields:[{name:"price",type:{array:["u64",460]}},{name:"circulatingSupply",type:{array:["u64",460]}},{name:"volume",type:{array:["u64",460]}},{name:"timestamp",type:{array:["u64",460]}},{name:"index",type:"u64"}]}},{name:"Stats",type:{kind:"struct",fields:[{name:"days",type:"u64"},{name:"performance",type:"u64"},{name:"volume",type:"u64"},{name:"mcap",type:"u64"}]}},{name:"TokenPriceData",type:{kind:"struct",fields:[{name:"amount",type:{array:["u64",10]}},{name:"price",type:{array:["u64",10]}}]}},{name:"PriceStatus",type:{kind:"enum",variants:[{name:"Unknown"},{name:"Trading"},{name:"Halted"},{name:"Auction"}]}},{name:"CorpAction",type:{kind:"enum",variants:[{name:"NoCorpAct"}]}},{name:"PriceType",type:{kind:"enum",variants:[{name:"Unknown"},{name:"Price"},{name:"TWAP"},{name:"Volatility"}]}}],errors:[{code:6e3,name:"AlreadySet",msg:"Rules are already set"},{code:6001,name:"IncorrectPdaUsdcAccount",msg:"Incorrect pda_usdc_account"},{code:6002,name:"IncorrectPythAccount",msg:"Incorrect pyth account provided"},{code:6003,name:"IncorrectSellState",msg:"Fund_state is provided instead of sell_state"},{code:6004,name:"IncorrectPdaTokenAccount",msg:"Incorrect pda_token_account"},{code:6005,name:"UpdateCurrentWeights",msg:"Current weights need to be updated"},{code:6006,name:"TimeHasntPassed",msg:"Enough time hasn't passed yet"},{code:6007,name:"InThreshold",msg:"weight is in rebalance threshold"},{code:6008,name:"MoreThan20Assets",msg:"Number of Assets must be less or equal to 20"},{code:6009,name:"ConstraintError",msg:"Constraint error"},{code:6010,name:"NotActivelyManaged",msg:"Fund isn't actively managed"},{code:6011,name:"IncorrectSmfFeeAccount",msg:"Incorrect smf_fee_account"},{code:6012,name:"ExpoRangeError",msg:"Expo must be in [0;1] range"},{code:6013,name:"NoRefilterAndReweightForSellState",msg:"Refilter or Reweight shouldn't be called for sell_state"},{code:6014,name:"IncorrectRebalanceFeeAccount",msg:"Incorrect rebalance_fee_account"},{code:6015,name:"TokenIsAlreadyBought",msg:"Rebalance function already bought this token"},{code:6016,name:"FundStateMustBeUpdated",msg:"Fund state must be updated"},{code:6017,name:"RuleWeightLimitError",msg:"Rule weight is more than 1000"},{code:6018,name:"IntervalLimitsAreIncorrect",msg:"Refilter, Reweight or Rebalance interval limits are incorrect"},{code:6019,name:"SlippageError",msg:"Swap Exceeded FundState Rebalance Slippage"},{code:6020,name:"TokenIsntPresentInState",msg:"Passed token is not present in buy_state"},{code:6021,name:"LessTokenInFund",msg:"There are less free tokens Tokens in fund_state than buyer wants"},{code:6022,name:"UsdcIsntEnough",msg:"USDC worth is less than token worth"},{code:6023,name:"ExceedsTargetWeight",msg:"Token weight after swap exceeds target weight"},{code:6024,name:"FundWorthDecreasing",msg:"Fund worth fill decrease after swap"},{code:6025,name:"SlippageExceeded",msg:"Swap slippage exceeded"},{code:6026,name:"IncorrectManagerAccount",msg:"manager_usdc_account doesnt belong to manager"},{code:6027,name:"WrongSigner",msg:"Sell state rebalance should be executed by manager"},{code:6028,name:"ClaimTokens",msg:"Only ClaimTokens function is available on this sellState"},{code:6029,name:"FilterOrWeightByError",msg:"filter_by and weight_by should be in [0;3] range"},{code:6030,name:"FilterOrWeightDaysError",msg:"filter_days and weight_days should be in [0;5] range"},{code:6031,name:"SortByError",msg:"sort_by must be 0 or 1"},{code:6032,name:"IncorrectRefferalFeeAccount",msg:"Incorrect refferal USDC account"},{code:6033,name:"IncorrectTokenAccount",msg:"Incorrect Buyer Token account"},{code:6034,name:"TokenStatsShouldBeUpdated",msg:"To call refilter/reweight function token stats must be updated"},{code:6035,name:"SellState",msg:"Fund is a SellState"},{code:6036,name:"ProgramFreezed",msg:"Program is freezed. Contact developer support."},{code:6037,name:"TvlLimitReached",msg:"TVL Limit reached as symmetry funds are in beta mode."},{code:6038,name:"BuyLimit",msg:"Max allowed contribution is limited to 5000 USDC"},{code:6039,name:"PythStatus",msg:"Pyth status should be Trading"},{code:6040,name:"PythConfidence",msg:"Pyth status should be Trading"},{code:6041,name:"PythNegativePrice",msg:"Pyth price can not be negative"},{code:6042,name:"AssetPool",msg:"Asset Pool shouldn't contain repeating tokens and should contain USDC"},{code:6043,name:"InvalidInstructionData",msg:"Invalid instruction data was provided"},{code:6044,name:"NotAssociatedTokenAccount",msg:"Fee account is not associated"},{code:6045,name:"CouldNotSwap",msg:"Could not swap enough amount"},{code:6046,name:"IncorrectTokenId",msg:"Incorrect token Id"},{code:6047,name:"FixedRule",msg:"Fixed rule should contain only 1 asset"},{code:6048,name:"FundIsActive",msg:"Fund is still active"},{code:6049,name:"BuyStateIsBeingClaimed",msg:"Buy state is being claimed"},{code:6050,name:"AssetPoolContainsOfflinePythToken",msg:"Asset pool contains token with offline pyth status"}]},E,no),io=new t("4Rn7pKKyiSNKZXKCoLqEpRznX1rhveV4dW1DCg6hRoVH"),ao=new t("4QMjSHuM3iS7Fdfi8kZJfHRKoEJSDHEtEwqbChsTcUVK"),so=new t("AWfpfzA6FYbqx4JLz75PDgsjH7jtBnnmJ6MXW5zNY2Ei"),ro=new t("BLBYiq48WcLQ5SxiftyKmPtmsZPUBEnDEjqEnKGAR4zx"),uo={pubkey:W,isSigner:!1,isWritable:!1};function co(t,e,n,o,i,a,s,r){return O.instruction.route(n,i,a,s,r,{accounts:{tokenProgram:F,userTransferAuthority:t,destinationTokenAccount:e},remainingAccounts:o})}function mo(t,e,n,o){return{swapProgram:mt,swapState:t.ammId,tokenProgram:F,poolAuthority:t.authority,userTransferAuthority:o,sourceTokenAccount:e,destinationTokenAccount:n}}const[po]=t.findProgramAddressSync([new Uint8Array(Buffer.from("amm authority".replace("Â "," "),"utf-8"))],dt);function lo(t,e,n,o){if(!t.serumMarketKeys)throw new Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:dt,tokenProgram:F,ammId:t.ammId,ammAuthority:po,ammOpenOrders:t.ammOpenOrders,poolCoinTokenAccount:t.poolCoinTokenAccount,poolPcTokenAccount:t.poolPcTokenAccount,serumProgramId:t.serumProgramId,serumMarket:t.serumMarket,serumBids:t.serumMarketKeys.serumBids,serumAsks:t.serumMarketKeys.serumAsks,serumEventQueue:t.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:t.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:t.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:t.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:e,userDestinationTokenAccount:n,userSourceOwner:o}}function ho(e,n,i,a,s,r){const u=t.createProgramAddressSync([e.address.toBuffer(),e.decoded.vaultSignerNonce.toArrayLike(Buffer,"le",8)],e.programId);return{market:{market:e.address,openOrders:n,requestQueue:e.decoded.requestQueue,eventQueue:e.decoded.eventQueue,bids:e.bidsAddress,asks:e.asksAddress,coinVault:e.decoded.baseVault,pcVault:e.decoded.quoteVault,vaultSigner:u},authority:r,orderPayerTokenAccount:i,coinWallet:a,pcWallet:s,dexProgram:e.programId,tokenProgram:F,rent:o}}function go(t,e,n,o,i){const a=e.equals(t.state.tokenA.mint)?t.state.tokenB.adminFeeAccount:t.state.tokenA.adminFeeAccount,[s,r]=e.equals(t.state.tokenA.mint)?[t.state.tokenA.reserve,t.state.tokenB.reserve]:[t.state.tokenB.reserve,t.state.tokenA.reserve];return{swapProgram:t.config.swapProgramID,tokenProgram:F,swap:t.config.swapAccount,swapAuthority:t.config.authority,userAuthority:i,inputUserAccount:n,inputTokenAccount:s,outputUserAccount:o,outputTokenAccount:r,feesTokenAccount:a}}function So(t,e){const n=[];return n.push(t?{pubkey:t,isSigner:!1,isWritable:!0}:e?{pubkey:e,isSigner:!1,isWritable:!0}:uo),n}const ko=new B(0);class fo{constructor(t,e){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=t,this.denominator=e}static fromDecimal(t){return fo.fromFraction(t.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(t,e){const n="number"==typeof t?new B(t.toString()):t,o="number"==typeof e?new B(e.toString()):e;return new fo(n,o)}toDecimal(){return this.denominator.eq(ko)?new te(0):new te(this.numerator.toString()).div(new te(this.denominator.toString()))}add(t){const e=this.denominator.gcd(t.denominator),n=this.denominator.div(e).mul(t.denominator),o=n.div(this.denominator),i=n.div(t.denominator),a=this.numerator.mul(o),s=t.numerator.mul(i),r=a.add(s);return new fo(new B(r.toString()),new B(n.toString()))}}const yo=Wt([In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator")],"fees"),Ao=[zt(8,"padding"),vn("lpTokenFreezeVault"),vn("poolMint"),vn("baseTokenVault"),vn("baseTokenMint"),vn("quoteTokenVault"),vn("quoteTokenMint"),vn("poolSigner"),Qt("poolSignerNonce"),vn("authority"),vn("initializerAccount"),vn("feeBaseAccount"),vn("feeQuoteAccount"),vn("feePoolTokenAccount"),yo],Mo=Wt(Ao),wo=Wt([...Ao,Qt("curveType"),vn("curve")]),To=Wt([zt(8,"padding"),In("amp")]);function Po(t,e){const n=!!e.owner.equals(R),o=(n?wo:Mo).decode(e.data),i="curveType"in o?{curveType:o.curveType,curve:o.curve}:{};return{isV2:n,address:t,poolMint:o.poolMint,baseTokenVault:o.baseTokenVault,baseTokenMint:o.baseTokenMint,quoteTokenVault:o.quoteTokenVault,quoteTokenMint:o.quoteTokenMint,poolSigner:o.poolSigner,feeBaseAccount:o.feeBaseAccount,feeQuoteAccount:o.feeQuoteAccount,feePoolTokenAccount:o.feePoolTokenAccount,fees:{traderFee:fo.fromFraction(o.fees.tradeFeeNumerator,o.fees.tradeFeeDenominator),ownerFee:fo.fromFraction(o.fees.ownerTradeFeeNumerator,o.fees.ownerTradeFeeDenominator)},...i}}class vo{constructor(t,e,n){if(this.params=void 0,this.id=void 0,this.label="Aldrin",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.params=n,this.poolState=Po(t,e),this.id=t.toBase58(),1===this.poolState.curveType){const{amp:t}=this.params;if(!t)throw new Error("Amp is required for a stable curve");this.calculator=new g(P.BigInt(t),new S(P.BigInt(this.poolState.fees.traderFee.numerator.toString()),P.BigInt(this.poolState.fees.traderFee.denominator.toString())),new S(P.BigInt(this.poolState.fees.ownerFee.numerator.toString()),P.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}else this.calculator=new k(new S(P.BigInt(this.poolState.fees.traderFee.numerator.toString()),P.BigInt(this.poolState.fees.traderFee.denominator.toString())),new S(P.BigInt(this.poolState.fees.ownerFee.numerator.toString()),P.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}static decodeStableCurveAmp(t){const{amp:e}=To.decode(t.data);return 2*e.toNumber()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(t){const e=An(t,this.getAccountsForUpdate());this.tokenReserveAmounts=Mn(e)}getQuote({sourceMint:t,amount:e}){if(!this.tokenReserveAmounts)throw new Error(wn);let n=new te(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new te(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const o=this.poolState.baseTokenMint.equals(t)?0:1;let i=this.calculator.exchange(this.tokenReserveAmounts,e,o);return{notEnoughLiquidity:!1,inAmount:e,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:t.toBase58(),feePct:n.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(t){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");return function({poolState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,curve:i,userTransferAuthority:a}){const[s,r,u]=e.equals(t.baseTokenMint)?[On.Ask,n,o]:[On.Bid,o,n];return[$n(Nn(s)),O.instruction.aldrinV2Swap({accounts:{swapProgram:R,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:a,userBaseTokenAccount:r,userQuoteTokenAccount:u,curve:i,tokenProgram:F}}).keys]}({poolState:this.poolState,curve:this.poolState.curve,...t})}return function({poolState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){const[a,s,r]=e.equals(t.baseTokenMint)?[On.Ask,n,o]:[On.Bid,o,n];return[$n(Vn(a)),O.instruction.aldrinSwap({accounts:{swapProgram:C,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:i,userBaseTokenAccount:s,userQuoteTokenAccount:r,tokenProgram:F}}).keys]}({poolState:this.poolState,...t})}get reserveTokenMints(){return[this.poolState.quoteTokenMint,this.poolState.baseTokenMint]}}vo.accountInfoToAldrinPoolState=Po;const bo={version:"0.1.0",name:"balancer_amm",instructions:[{name:"swap",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"pool",isMut:!0,isSigner:!1},{name:"taxMan",isMut:!0,isSigner:!1},{name:"bidMint",isMut:!1,isSigner:!1},{name:"treasurer",isMut:!1,isSigner:!1},{name:"srcTreasury",isMut:!0,isSigner:!1},{name:"srcAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"askMint",isMut:!1,isSigner:!1},{name:"dstTreasury",isMut:!0,isSigner:!1},{name:"dstAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"dstTokenAccountTaxman",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"bidAmount",type:"u64"},{name:"limit",type:"u64"}],returns:"u64"}],accounts:[{name:"pool",type:{kind:"struct",fields:[{name:"authority",type:"publicKey"},{name:"fee",type:"u64"},{name:"taxFee",type:"u64"},{name:"state",type:{defined:"PoolState"}},{name:"mintLpt",type:"publicKey"},{name:"taxMan",type:"publicKey"},{name:"mints",type:{vec:"publicKey"}},{name:"actions",type:{vec:{defined:"MintActionState"}}},{name:"treasuries",type:{vec:"publicKey"}},{name:"reserves",type:{vec:"u64"}},{name:"weights",type:{vec:"u64"}}]}}],types:[{name:"PoolState",type:{kind:"enum",variants:[{name:"Uninitialized"},{name:"Initialized"},{name:"Frozen"},{name:"Deleted"}]}},{name:"MintActionState",type:{kind:"enum",variants:[{name:"Active"},{name:"BidOnly"},{name:"AskOnly"},{name:"Paused"}]}}],errors:[]},Io=10**9,Bo=(t,e)=>{const n=t.map((t=>t.toNumber()/Io));return e.toNumber()/Io/n.reduce(((t,e)=>t+e),0)},Fo=(t,e)=>{const{balanceIn:n,balanceOut:o,weightIn:i,weightOut:a,swapFee:s}=e,r=Number(n.toString()),u=Number(o.toString()),c=i,m=a,d=Number(s.toString())/Io;return-r*m/(u*(-1+d)*(r/(t+r-t*d))**((c+m)/m)*c)},Lo=new Ht(bo);class Do{constructor(t,e){this.address=void 0,this.label="Balansol",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolData=void 0,this.address=t,this.id=t.toBase58(),this.poolData=Lo.decode("pool",e.data)}getAccountsForUpdate(){return[new t(this.id)]}update(t){let[e]=An(t,this.getAccountsForUpdate());const n=Lo.decode("pool",e.data);this.poolData=n}getQuote({sourceMint:t,destinationMint:e,amount:n}){var o,i;if(!this.poolData)throw new Error(`Invalid pool data ${this.address.toBase58()}`);if(!this.poolData.state.initialized)throw new Error(`Pool is not initialized ${this.address.toBase58()}`);const a=this.poolData.mints.map((t=>t.toBase58())),s=a.indexOf(t.toBase58()),r=a.indexOf(e.toBase58());if(null===(o=this.poolData.actions[s])||void 0===o||!o.active)throw new Error(`Invalid bid mint state ${this.address.toBase58()}`);if(null===(i=this.poolData.actions[r])||void 0===i||!i.active)throw new Error(`Invalid ask mint state ${this.address.toBase58()}`);const u=Bo(this.poolData.weights,this.poolData.weights[s]),c=Bo(this.poolData.weights,this.poolData.weights[r]),m=((t,e,n,o,i,a)=>{const s=Number(e.toString()),r=Number(n.toString());return s*(1-(r/(r+t))**(i/o))*(1-Number(a.toString())/Io)})(Number(n.toString()),this.poolData.reserves[r],this.poolData.reserves[s],c,u,this.poolData.fee.add(this.poolData.taxFee)),d=((t,e)=>{const n=Fo(0,e),o=Fo(t,e);return o<n?0:1-n/o})(Number(n.toString()),{balanceIn:this.poolData.reserves[s],balanceOut:this.poolData.reserves[r],weightIn:u,weightOut:c,swapFee:this.poolData.fee.add(this.poolData.taxFee)}),p=this.poolData.fee.add(this.poolData.taxFee).toNumber()/10**9,l=m/(1-p)*p;return{notEnoughLiquidity:!1,inAmount:n,outAmount:P.BigInt(Math.floor(m)),feeAmount:P.BigInt(Math.floor(l)),feeMint:e.toBase58(),feePct:0,priceImpactPct:d}}getSwapLegAndAccounts(e){var i;if(!this.poolData)throw new Error(`Invalid pool data ${this.address.toBase58()}`);const a=this.poolData.mints.findIndex((t=>t.equals(e.sourceMint))),s=this.poolData.mints.findIndex((t=>t.equals(e.destinationMint))),[r]=t.findProgramAddressSync([Buffer.from("treasurer"),this.address.toBuffer()],tt),u=rt({tokenMintAddress:e.destinationMint,walletAddress:this.poolData.taxMan});return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:i,userTransferAuthority:a,sourceMint:s,destinationMint:r}){return[$n({balansol:{}}),O.instruction.balansolSwap({accounts:{swapProgram:tt,authority:a,pool:t.pool,taxMan:t.taxMan,bidMint:s,treasurer:t.treasurer,srcTreasury:t.srcTreasury,srcAssociatedTokenAccount:e,askMint:r,dstTreasury:t.dstTreasury,dstAssociatedTokenAccount:i,dstTokenAccountTaxman:t.dstTokenAccountTaxman,systemProgram:n.programId,tokenProgram:F,associatedTokenProgram:D,rent:o},remainingAccounts:t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[uo]}).keys]}({...e,additionalArgs:{pool:this.address,taxMan:this.poolData.taxMan,dstTokenAccountTaxman:u,treasurer:r,srcTreasury:this.poolData.treasuries[a],dstTreasury:this.poolData.treasuries[s],referrer:null===(i=e.quoteMintToReferrer)||void 0===i?void 0:i.get(e.destinationMint.toBase58())}})}get reserveTokenMints(){return this.poolData.mints}}Do.getIDL=()=>bo;const qo=new Zt(se);class xo{constructor(t,e,n){this.address=void 0,this.id=void 0,this.label="Crema",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.clmmpoolData=void 0,this.reserveTokenDecimals=void 0,this.tickArrayMapPubkey=void 0,this.feeRate=void 0,this.tickArrayMap=void 0,this.tickArrayPubkeys=[],this.tickArrays=[],this.arrayStartIndex=void 0,this.swapTicks=void 0,this.address=t,this.id=t.toBase58(),this.clmmpoolData=qo.accounts.decode("clmmpool",e.data),this.feeRate=this.clmmpoolData.feeRate,this.tickArrayMapPubkey=ee.getTickArrayMapPDA(at,t).publicKey,this.reserveTokenDecimals=[n.decimalA,n.decimalB],this.arrayStartIndex=0}getAccountsForUpdate(){return[this.address,this.tickArrayMapPubkey,...this.tickArrayPubkeys]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Missing poolData ${this.address.toBase58()}`);this.clmmpoolData=qo.accounts.decode("clmmpool",e.data),this.feeRate=this.clmmpoolData.feeRate;const n=t.get(this.tickArrayMapPubkey.toBase58());if(!n)throw new Error(`Missing tickArrayMap ${this.tickArrayMapPubkey.toBase58()}`);const o=qo.accounts.decode("tickArrayMap",n.data);this.tickArrayPubkeys=this.getTickArrayPubkeys(this.address,o),this.tickArrayMap=o;const i=ne.getArrayIndex(this.clmmpoolData.currentTickIndex,this.clmmpoolData.tickSpacing);let a=!1;const s=[];for(let e=0;e<this.tickArrayPubkeys.length;e++){const n=t.get(this.tickArrayPubkeys[e].toBase58());if(n){const t=qo.accounts.decode("tickArray",n.data);!1===a&&t.arrayIndex>=i&&(a=!0,this.arrayStartIndex=e),s.push({address:this.tickArrayPubkeys[e],data:t})}}this.tickArrays=s;const r={aToB:[],bToA:[]};for(let t=this.arrayStartIndex;t>this.arrayStartIndex-3;t--){let e=this.tickArrays[t];e&&r.aToB.push(e)}for(let t=this.arrayStartIndex;t<this.arrayStartIndex+3;t++){let e=this.tickArrays[t];e&&r.bToA.push(e)}this.swapTicks={aToB:[],bToA:[]},[r.aToB,r.bToA].forEach(((t,e)=>{for(let n=0;n<t.length;n++){const o=t[n];if(0===e)for(let t=oe-1;t>=0;t--)o.data&&o.data.ticks[t].isInitialized&&this.swapTicks.aToB.push(o.data.ticks[t]);else for(let t=0;t<oe;t++)o.data&&o.data.ticks[t].isInitialized&&this.swapTicks.bToA.push(o.data.ticks[t])}}))}getTickArrayPubkeys(t,e){let n=[];for(let t=0;t<868;t++){let o=e.bitmap[t];for(let t=0;t<8;t++)n.push((o>>t&1)>0)}const o=[];for(let e=0;e<n.length;e++)if(n[e]){const n=ee.getTickArrayPDA(at,t,e).publicKey;o.push(n)}return o}getQuote(t){let e,n,o;if(!this.swapTicks)throw new Error("swapTicks is not initialized");"ExactIn"===t.swapMode?(e=t.destinationMint,o=!0):(e=t.sourceMint,o=!1),n=!!t.sourceMint.equals(this.reserveTokenMints[0]);const i=new x(t.amount.toString()),a=ie(n,o,i,this.clmmpoolData,this.swapTicks[n?"aToB":"bToA"]),s=ae.sqrtPriceX64ToPrice(this.clmmpoolData.currentSqrtPrice,this.reserveTokenDecimals[0],this.reserveTokenDecimals[1]).toNumber(),r=ae.sqrtPriceX64ToPrice(a.nextSqrtPrice,this.reserveTokenDecimals[0],this.reserveTokenDecimals[1]).toNumber();let u=!1;if(u=o?a.amountIn.lt(i):a.amountOut.lt(i),u)throw new Error("not enough liquidity");return{notEnoughLiquidity:u,inAmount:P.BigInt(a.amountIn),outAmount:P.BigInt(a.amountOut),feeMint:e.toString(),feeAmount:P.multiply(P.BigInt(t.amount),P.BigInt(this.feeRate)),feePct:this.feeRate,priceImpactPct:Math.abs(s-r)/s}}getSwapLegAndAccounts(t){let e,n;if(!this.swapTicks)throw new Error("swapTicks is not initialized");const o=ee.getClmmConfigPDA(at).publicKey;if(e=!!t.sourceMint.equals(this.reserveTokenMints[0]),n="ExactIn"===t.swapMode,!this.tickArrayMap)throw new Error("tickArrayMap is not initialized");const i=new x(t.amount.toString()),a=ie(e,n,i,this.clmmpoolData,this.swapTicks[e?"aToB":"bToA"],this.address,this.tickArrayMap);return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o,sourceMint:i}){const{aToB:a,accountA:s,accountB:r}=i.equals(t.tokenA)?{aToB:!0,accountA:e,accountB:n}:{aToB:!1,accountA:n,accountB:e};let u=[];return t.remainingAccounts.forEach((t=>{u.push({pubkey:t,isSigner:!1,isWritable:!0})})),u.push(uo),[$n(Rn(a)),O.instruction.cremaSwap({accounts:{swapProgram:at,clmmConfig:t.clmmConfig,clmmpool:t.clmmpool,tokenA:t.tokenA,tokenB:t.tokenB,accountA:s,accountB:r,tokenAVault:t.tokenAVault,tokenBVault:t.tokenBVault,tickArrayMap:t.tickArrayMap,owner:o,partner:st,partnerAtaA:rt({walletAddress:st,tokenMintAddress:t.tokenA}),partnerAtaB:rt({walletAddress:st,tokenMintAddress:t.tokenB}),tokenProgram:F},remainingAccounts:u}).keys]}({additionalArgs:{clmmConfig:o,clmmpool:this.address,tokenA:this.clmmpoolData.tokenA,tokenB:this.clmmpoolData.tokenB,tokenAVault:this.clmmpoolData.tokenAVault,tokenBVault:this.clmmpoolData.tokenBVault,tickArrayMap:this.tickArrayMapPubkey,remainingAccounts:a.swapTickArrays},...t})}get reserveTokenMints(){return[this.clmmpoolData.tokenA,this.clmmpoolData.tokenB]}}class Eo{static async getStateFromStateAccount(t){const e=await t.getAccountInfo(xn);if(!e)throw new Error("State account not found");return(t=>{const e=qn.decode(t.data);return{isInitialized:Boolean(e.isInitialized),stateOwner:e.stateOwner,feeOwner:e.feeOwner,initialSupply:e.initialSupply,returnFeeNumerator:e.returnFeeNumerator.toNumber(),fixedFeeNumerator:e.fixedFeeNumerator.toNumber(),feeDenominator:e.feeDenominator.toNumber(),curveType:e.curveType,curveParameters:e.curveParameters}})(e)}constructor(e,n,o){this.id=void 0,this.label="Cropper",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.feePct=void 0,this.params=void 0,this.id=e.toBase58(),this.poolState=En(e,n),this.params={...o,tokenAFeeAccount:new t(o.tokenAFeeAccount),tokenBFeeAccount:new t(o.tokenBFeeAccount)},this.feePct=new te(this.params.fixedFeeNumerator).add(new te(this.params.returnFeeNumerator)).div(this.params.feeDenominator),this.calculator=new k(new S(P.BigInt(this.params.fixedFeeNumerator),P.BigInt(this.params.feeDenominator)),new S(P.BigInt(this.params.returnFeeNumerator),P.BigInt(this.params.feeDenominator)))}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(t){const e=An(t,this.getAccountsForUpdate());this.tokenReserveAmounts=Mn(e)}getQuote({sourceMint:t,amount:e}){if(!this.tokenReserveAmounts)throw new Error(wn);const n=this.poolState.mintA.equals(t)?1:0,o=this.calculator.exchange(this.tokenReserveAmounts,e,n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:t.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(t){const e=t.sourceMint.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return function({poolState:t,feeAccount:e,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:a}){const[s,r]=n.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return[$n({cropper:{}}),O.instruction.cropperSwap({accounts:{tokenSwapProgram:t.programId,tokenProgram:F,swap:t.ammId,swapState:xn,authority:t.authority,userTransferAuthority:a,source:o,swapSource:s,swapDestination:r,destination:i,poolMint:t.poolMint,poolFee:e}}).keys]}({poolState:this.poolState,feeAccount:e,...t})}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}Eo.decodePoolState=En;class Oo{constructor(t,e){this.program=void 0,this.pool=void 0,this.bitmapCache=void 0,this.tickCache=void 0,this.accountsToFetch={bitmaps:[],ticks:[]},this.program=t,this.pool=e,this.bitmapCache=new Map,this.tickCache=new Map}async eagerLoadCache(t,e){const n=P.toNumber(P.divide(P.BigInt(t),P.BigInt(e))),{wordPos:o}=re(n);try{const t=[],{wordPos:n}=re(Math.floor(ue.MIN_TICK/e)),{wordPos:a}=re(Math.floor(ue.MAX_TICK/e)),s=Math.max(o-10,n),r=Math.min(o+10,a);for(let e=s;e<r;e++)t.push(this.getBitmapAddressSync(e));const u=await this.program.account.tickBitmapState.fetchMultiple(t),c=[];for(let n=0;n<r-s;n++){var i;const o=n+s,a=null===(i=u[n])||void 0===i?void 0:i.word,r=a?ce(a):new Jt(0);if(this.bitmapCache.set(o,{address:t[n],word:r}),r&&!r.eqn(0))for(let t=0;t<256;t++)if(r.shrn(t).and(new Jt(1)).eqn(1)){const n=this.getTickAddressSync(((o<<8)+t)*e);c.push(n)}}const m=await this.program.account.tickState.fetchMultiple(c);for(const t in c){const e=m[t];if(!e)continue;const{tick:n,liquidityNet:o}=e;this.tickCache.set(n,{address:c[t],liquidityNet:P.BigInt(o)})}}catch(t){}}lazyLoadAccountsToCache(t,e){const n=P.toNumber(P.divide(P.BigInt(t),P.BigInt(e))),{wordPos:o}=re(n),i=[],a=[],{wordPos:s}=re(Math.floor(ue.MIN_TICK/e)),{wordPos:r}=re(Math.floor(ue.MAX_TICK/e)),u=Math.max(o-10,s),c=Math.min(o+10,r);for(let t=u;t<c;t++){i.push(this.getBitmapAddressSync(t));const e=this.bitmapCache.get(t);a.push(e)}const m=[];for(let t=0;t<c-u;t++){var d,p;const n=t+u,o=null!==(d=null===(p=a[t])||void 0===p?void 0:p.word)&&void 0!==d?d:new Jt(0);if(this.bitmapCache.set(n,{address:i[t],word:o}),o&&!o.eqn(0))for(let t=0;t<256;t++)if(o.shrn(t).and(new Jt(1)).eqn(1)){const o=this.getTickAddressSync(((n<<8)+t)*e);m.push(o)}}return this.accountsToFetch={bitmaps:i,ticks:m},[...i,...m]}getTick(t){let e=this.tickCache.get(t);if(!e)throw new Error("Tick not cached");return{address:e.address,liquidityNet:e.liquidityNet}}async getTickAddress(t){return this.getTickAddressSync(t)}getTickAddressSync(e){return t.findProgramAddressSync([me,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),de(this.pool.fee),de(e)],this.program.programId)[0]}async getBitmapAddress(t){return this.getBitmapAddressSync(t)}getBitmapAddressSync(e){return t.findProgramAddressSync([pe,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),de(this.pool.fee),le(e)],this.program.programId)[0]}getBitmap(t){let e=this.bitmapCache.get(t);if(!e)throw new Error("Bitmap not cached");return e}nextInitializedTickWithinOneWord(t,e,n){let o=P.toNumber(P.divide(P.BigInt(t),P.BigInt(n)));t<0&&t%n!=0&&(o-=1),e||(o+=1);const{wordPos:i,bitPos:a}=re(o),s=this.getBitmap(i),{next:r,initialized:u}=he(s.word,a,e);return[ge(i,r,n),u,i,a,s.address]}updateCachedAccountInfos(t){for(const e of this.accountsToFetch.bitmaps){const n=t.get(e.toBase58());if(n){const t=this.program.coder.accounts.decode("tickBitmapState",n.data);this.bitmapCache.set(t.wordPos,{address:e,word:ce(t.word)})}}for(const e of this.accountsToFetch.ticks){const n=t.get(e.toBase58());if(n){const t=this.program.coder.accounts.decode("tickState",n.data);this.tickCache.set(t.tick,{address:e,liquidityNet:P.BigInt(t.liquidityNet)})}}}}const Co=P.BigInt(1e6),Ro=new $t(fe,U,no);class Vo{constructor(e,n){this.address=void 0,this.label="Cykura",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolState=void 0,this.pool=void 0,this.tickDataProvider=void 0,this.tokens=void 0,this.vaults=void 0,this.feePct=void 0,this.fee=void 0,this.address=e,this.id=e.toBase58(),this.poolState=Ro.coder.accounts.decode("poolState",n.data);const{token0:o,token1:i,fee:a,sqrtPriceX32:s,liquidity:r,tick:u}=this.poolState;this.tickDataProvider=new Oo(Ro,{token0:o,token1:i,fee:a}),this.tokens={token0:new ye(101,o,0,"",""),token1:new ye(101,i,0,"","")},this.pool=new Se(this.tokens.token0,this.tokens.token1,a,P.BigInt(s.toString()),P.BigInt(r.toString()),u,this.tickDataProvider),this.vaults={vault0:t.findProgramAddressSync([this.address.toBuffer(),F.toBuffer(),o.toBuffer()],D)[0],vault1:t.findProgramAddressSync([this.address.toBuffer(),F.toBuffer(),i.toBuffer()],D)[0]},this.fee=P.BigInt(this.poolState.fee),this.feePct=this.poolState.fee/P.toNumber(Co)}getAccountsForUpdate(){return[this.address,...this.tickDataProvider.lazyLoadAccountsToCache(this.pool.tickCurrent,this.pool.tickSpacing)]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Could not find poolAccountInfo ${this.address.toBase58()}`);this.poolState=Ro.coder.accounts.decode("poolState",e.data);const{fee:n,sqrtPriceX32:o,liquidity:i,tick:a}=this.poolState;this.pool=new Se(this.tokens.token0,this.tokens.token1,n,P.BigInt(o.toString()),P.BigInt(i.toString()),a,this.tickDataProvider),this.tickDataProvider.updateCachedAccountInfos(t)}getQuote({sourceMint:t,amount:e}){const n=t.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[o,i,a]=this.pool.getOutputAmount(Ae.fromRawAmount(n,e)),s=f(P.subtract(this.pool.sqrtRatioX32,i.sqrtRatioX32)).div(this.pool.sqrtRatioX32.toString());return{notEnoughLiquidity:!1,inAmount:e,outAmount:o.quotient,feeAmount:P.divide(P.multiply(e,this.fee),Co),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:s.toNumber()}}getSwapLegAndAccounts(e){const[n,o]=e.sourceMint.equals(this.poolState.token0)?[this.vaults.vault0,this.vaults.vault1]:[this.vaults.vault1,this.vaults.vault0],i=t.findProgramAddressSync([ke,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),de(this.poolState.fee),le(this.poolState.observationIndex)],U)[0],a=e.sourceMint.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[,,s]=this.pool.getOutputAmount(Ae.fromRawAmount(a,e.amount)),r=t.findProgramAddressSync([ke,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),de(this.poolState.fee),le((this.poolState.observationIndex+1)%this.poolState.observationCardinalityNext)],U)[0],u={poolAddress:this.address,inputVault:n,outputVault:o,nextObservationState:r,lastObservationState:i,swapAccountMetas:s};return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){return[$n({cykura:{}}),O.instruction.cykuraSwap({accounts:{swapProgram:U,signer:o,factoryState:K,poolState:t.poolAddress,inputTokenAccount:e,outputTokenAccount:n,inputVault:t.inputVault,outputVault:t.outputVault,lastObservationState:t.lastObservationState,coreProgram:U,tokenProgram:F},remainingAccounts:[...t.swapAccountMetas,{pubkey:t.nextObservationState,isSigner:!1,isWritable:!0},uo]}).keys]}({...e,additionalArgs:u})}get reserveTokenMints(){return[this.poolState.token0,this.poolState.token1]}}const No={DkwiQyA2JfD8ARfvMbMqu2DD4XKRkewRZVDE94SZNxSS:{price:1}},Uo=we(J,no);class Ko{constructor(t,e){this.address=void 0,this.id=void 0,this.label="DeltaFi",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapInfo=void 0,this.feePct=void 0,this.prices=void 0,this.pythAddresses=void 0,this.address=t,this.id=t.toBase58(),this.swapInfo=Uo.coder.accounts.decode("SwapInfo",e.data);const{swapConfig:o}=this.swapInfo;this.feePct=o.tradeFeeNumerator/o.tradeFeeDenominator,this.pythAddresses=[this.swapInfo.pythPriceBase,this.swapInfo.pythPriceQuote].filter((t=>!n.programId.equals(t)))}getAccountsForUpdate(){return[this.address,...this.pythAddresses]}getPriceData(t,e){const{id:n}=this,o=t.get(e.toBase58())||No[n];if(!o)throw new Error(`Missing pyth account info for ${e.toBase58()}`);return"data"in o?Te(o.data):o}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Missing ${this.address.toBase58()}`);this.swapInfo=Uo.coder.accounts.decode("SwapInfo",e.data);try{const e=this.getPriceData(t,this.swapInfo.pythPriceBase),n=this.getPriceData(t,this.swapInfo.pythPriceQuote);if(e.price&&n.price){const t=new Pe(e.price).dividedBy(new Pe(n.price)),o=new Pe(e.price+e.confidence).dividedBy(new Pe(n.price-n.confidence)),i=new Pe(e.price-e.confidence).dividedBy(new Pe(n.price+n.confidence));this.prices={marketPrice:t,highPrice:o,lowPrice:i}}else this.prices=void 0}catch(t){this.prices=void 0}}getQuote({destinationMint:t,amount:e}){if(!this.prices)throw new Error("Missing price data from pyth");const{swapInfo:n}=this,{amountIn:o,amountOut:i,priceImpact:a}=Me(n,t.equals(n.mintQuote)?{sellBase:{}}:{sellQuote:{}},new Pe(e.toString()),this.prices.marketPrice,this.prices.highPrice,this.prices.lowPrice),s=i.multipliedBy(n.swapConfig.tradeFeeNumerator.toString()).dividedBy(n.swapConfig.tradeFeeDenominator.toString()).decimalPlaces(0),r=i.minus(s);return{notEnoughLiquidity:!1,inAmount:P.BigInt(o),outAmount:P.BigInt(r),feeAmount:P.BigInt(s),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:Number(a)}}getSwapLegAndAccounts(t){var e;if(!this.prices)throw new Error("Missing price data from pyth");const{swapSourceToken:n,swapDestinationToken:o,adminDestinationToken:i}=this.swapInfo.mintBase.equals(t.sourceMint)?{swapSourceToken:this.swapInfo.tokenBase,swapDestinationToken:this.swapInfo.tokenQuote,adminDestinationToken:this.swapInfo.adminFeeTokenQuote}:{swapSourceToken:this.swapInfo.tokenQuote,swapDestinationToken:this.swapInfo.tokenBase,adminDestinationToken:this.swapInfo.adminFeeTokenBase};return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){return[$n((i=t.stable,{deltaFi:{stable:i}})),O.instruction.deltafiSwap({accounts:{swapProgram:J,marketConfig:t.marketConfig,swapInfo:t.swapInfo,userSourceToken:e,userDestinationToken:n,swapSourceToken:t.swapSourceToken,swapDestinationToken:t.swapDestinationToken,deltafiUser:G,adminDestinationToken:t.adminDestinationToken,pythPriceBase:t.pythPriceBase,pythPriceQuote:t.pythPriceQuote,userAuthority:o,tokenProgram:F},remainingAccounts:t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[uo]}).keys];var i}({additionalArgs:{stable:!!this.swapInfo.swapType.stableSwap,marketConfig:this.swapInfo.configKey,swapInfo:this.address,swapSourceToken:n,swapDestinationToken:o,adminDestinationToken:i,pythPriceBase:this.swapInfo.pythPriceBase,pythPriceQuote:this.swapInfo.pythPriceQuote,referrer:null===(e=t.quoteMintToReferrer)||void 0===e?void 0:e.get(t.destinationMint.toBase58())},...t})}get reserveTokenMints(){return[this.swapInfo.mintQuote,this.swapInfo.mintBase]}}const zo=t=>B.fromBuffer(t.data.slice(64,72)),Wo=t=>B.fromBuffer(t.data.slice(36,44));function Qo(t){const e=t.readBigUInt64LE();return Number(e)}function jo(t){const e=t.readBigInt64LE(32);return Number(e)}class Xo{constructor(t,e){this.address=void 0,this.id=void 0,this.label="GooseFX",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.pairLayout=void 0,this.quoter=void 0,this.gooseFxAccounts=void 0,this.fixedAccounts=void 0,this.oracleAccounts=[],this.quoteParams=void 0,this.isQuoteInvalid=!0,this.slot=void 0,this.address=t,this.id=t.toBase58(),this.pairLayout=ve.decode(e.data);const[n,o]=this.pairLayout.mints,a=new be;this.quoter=a.getSyncQuoter(n,o),this.gooseFxAccounts=this.quoter.getAccounts();const{pairAddress:s,sslIn:r,sslOut:u,liabilityVaultIn:c,liabilityVaultOut:m,swappedLiabilityVaultIn:d,swappedLiabilityVaultOut:p}=this.gooseFxAccounts;this.fixedAccounts=[i,s,r,u,c,m,d,p],this.updateOracles()}updateOracles(){const t=Number(this.pairLayout.nOracle.toString()),e=this.pairLayout.oracles.slice(0,t).reduce(((t,e)=>{const n=Number(e.n);for(const o of e.elements.slice(0,n))t.push(o.address);return t}),[]);this.oracleAccounts=e}getAccountsForUpdate(){return[...this.fixedAccounts,...this.oracleAccounts]}isSuspended(t){if(this.quoteParams){let e=Boolean(this.quoteParams.suspended);if(void 0!==t)for(const n of this.quoteParams.publishedSlots)e||=n+this.quoteParams.maxDelay<=t;return e}return!0}update(t){var e;const[n,o,i,a,s,r,u,c]=An(t,this.fixedAccounts);if(!(o&&i&&a&&s&&r&&u&&c))throw new Error("Missing account data");const m=Be.OracleRegistry;this.pairLayout=ve.decode(o.data);const{oracles:d,nOracle:p,maxDelay:l}=this.pairLayout,h=Number(p.toString()),g=new m;this.updateOracles();let S=[];for(const e of d.slice(0,h)){const n=Number(e.n);for(const o of e.elements.slice(0,n)){const e=t.get(o.address.toBase58());if(!e)return void(this.isQuoteInvalid=!0);g.add_oracle(o.address.toBuffer(),e.data),S.push(BigInt(Te(e.data).aggregate.publishSlot))}}this.slot=BigInt(Qo(n.data)),this.isQuoteInvalid&&(this.isQuoteInvalid=!1),null===(e=this.quoteParams)||void 0===e||e.registry.free(),this.quoteParams={liabilityIn:BigInt(zo(s).toString()),liabilityOut:BigInt(zo(r).toString()),pairData:o.data,sslInData:i.data,sslOutData:a.data,swappedLiabilityIn:BigInt(zo(u).toString()),swappedLiabilityOut:BigInt(zo(c).toString()),registry:g,suspended:new Ie(i).isSuspended()||new Ie(a).isSuspended(),maxDelay:l,publishedSlots:S}}getQuote({sourceMint:t,amount:e}){if(!this.quoteParams||this.isQuoteInvalid)throw new Error("Missing quote data");if(this.isSuspended(this.slot))throw new Error("Quote suspended");const{quoteParams:n}=this,o=Be.swap;let i;const a=t.equals(this.pairLayout.mints[0]);i=a?o(n.sslInData.slice(),n.sslOutData.slice(),n.pairData.slice(),n.liabilityIn,n.liabilityOut,n.swappedLiabilityIn,n.swappedLiabilityOut,n.registry,BigInt(e.toString())):o(n.sslOutData.slice(),n.sslInData.slice(),n.pairData.slice(),n.liabilityOut,n.liabilityIn,n.swappedLiabilityOut,n.swappedLiabilityIn,n.registry,BigInt(e.toString()));const s=this.pairLayout.feeRates[a?0:1],r={notEnoughLiquidity:!1,inAmount:P.BigInt(i.amount_in.toString()),outAmount:P.BigInt(i.amount_out.toString()),feeAmount:P.BigInt(i.fee_paid.toString()),feeMint:t.toBase58(),feePct:s/1e4,priceImpactPct:i.price_impact};return i.free(),r}getSwapLegAndAccounts(t){var e;if(!this.quoteParams)throw new Error("Missing quote data");const n=t.sourceMint.equals(this.pairLayout.mints[0]),{gooseFxAccounts:o}=this,[i,a,s,r,u,c]=n?[o.sslIn,o.liabilityVaultIn,o.swappedLiabilityVaultIn,o.sslOut,o.liabilityVaultOut,o.swappedLiabilityVaultOut]:[o.sslOut,o.liabilityVaultOut,o.swappedLiabilityVaultOut,o.sslIn,o.liabilityVaultIn,o.swappedLiabilityVaultIn];return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){const i=[];return i.push(t.referrer?{pubkey:t.referrer,isSigner:!1,isWritable:!0}:uo),t.oracles.forEach((t=>{i.push({pubkey:t,isSigner:!1,isWritable:!1})})),i.push(uo),[$n({gooseFx:{}}),O.instruction.goosefxSwap({accounts:{swapProgram:H,controller:Z,pair:t.pair,sslIn:t.sslIn,sslOut:t.sslOut,liabilityVaultIn:t.liabilityVaultIn,swappedLiabilityVaultIn:t.swappedLiabilityVaultIn,liabilityVaultOut:t.liabilityVaultOut,swappedLiabilityVaultOut:t.swappedLiabilityVaultOut,userInAta:e,userOutAta:n,feeCollectorAta:t.feeCollectorAta,userWallet:o,feeCollector:t.feeCollector,tokenProgram:F},remainingAccounts:i}).keys]}({additionalArgs:{pair:this.gooseFxAccounts.pairAddress,sslIn:i,sslOut:r,liabilityVaultIn:a,swappedLiabilityVaultIn:s,liabilityVaultOut:u,swappedLiabilityVaultOut:c,feeCollectorAta:rt({walletAddress:this.pairLayout.feeCollector,tokenMintAddress:t.sourceMint}),feeCollector:this.pairLayout.feeCollector,oracles:this.oracleAccounts,referrer:null===(e=t.quoteMintToReferrer)||void 0===e?void 0:e.get(t.sourceMint.toBase58())},...t})}get reserveTokenMints(){return this.pairLayout.mints}}const Yo=new $t(Re,j,no);class _o{static parsePoolStructure(t){return Yo.coder.accounts.decode("pool",t.data)}static parseTickmap(t){return Yo.coder.accounts.decode("tickmap",t.data)}static parseTick(t){return{...Yo.coder.accounts.decode("tick",t.data)}}static getQuote(t,e,n,o,i,a){const{currentTickIndex:s,fee:r,tickSpacing:u,tokenX:c,liquidity:m,sqrtPrice:d}=t,p={currentTickIndex:s,tickSpacing:u,liquidity:m,fee:r,sqrtPrice:d},l={xToY:o.equals(c),byAmountIn:a===yn.ExactIn,swapAmount:new x(i.toString()),priceLimit:o.equals(c)?Le(De):Le(qe),slippage:xe(0),ticks:e,tickmap:n,pool:p};return Ee(l)}static getTickIndexToTickPubkeyHash(t,e,n){if(!n){const{tickAddress:n}=this.getTickAddress(t,e.currentTickIndex),o=new Map;return o.set(e.currentTickIndex,n),o}const o=Oe(n.bitmap,e.currentTickIndex,e.tickSpacing,Ce,Infinity,"down"),i=Oe(n.bitmap,e.currentTickIndex,e.tickSpacing,Ce,Infinity,"up");return o.concat([e.currentTickIndex]).concat(i).reduce(((e,n)=>{const{tickAddress:o}=this.getTickAddress(t,n);return e.set(n,o),e}),new Map)}static getTickAddress(e,n){const o=Buffer.alloc(4);o.writeInt32LE(n);const[i,a]=t.findProgramAddressSync([Buffer.from(Gt.bytes.utf8.encode("tickv1")),e.toBuffer(),o],Yo.programId);return{tickAddress:i,tickBump:a}}}class $o{constructor(t,e){this.address=void 0,this.id=void 0,this.label="Invariant",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolStructure=void 0,this.tickmap=void 0,this.tickPkToTickIndexHash=void 0,this.ticks=new Map,this.feePct=void 0,this.address=t,this.id=t.toBase58(),this.poolStructure=_o.parsePoolStructure(e),this.tickPkToTickIndexHash=_o.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.feePct=new te(this.poolStructure.fee.v.toString()).div(Ve.toString()).toNumber()}getAccountsForUpdate(){const t=this.tickPkToTickIndexHash.values();return[this.address,this.poolStructure.tickmap,...t]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Missing invariant pool data ${this.address.toBase58()}`);this.poolStructure=_o.parsePoolStructure(e);const n=t.get(this.poolStructure.tickmap.toBase58());n&&(this.tickmap=_o.parseTickmap(n)),this.tickPkToTickIndexHash=_o.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.ticks.clear();for(const[e,n]of this.tickPkToTickIndexHash){const o=t.get(n.toBase58());if(!o)continue;const i=_o.parseTick(o);this.ticks.set(e,i)}}getQuote({sourceMint:t,amount:e,swapMode:n}){if(!this.tickmap)throw new Error("Missing tickmap");const o=_o.getQuote(this.poolStructure,this.ticks,this.tickmap,t,e,n),i=new te(o.priceImpact.toString()).div(Ve.toString()).toNumber();if(0!==o.status)throw new Error(`Invariant simulation failed: ${this.address}`);const a=o.accumulatedAmountIn.add(o.accumulatedFee);return{notEnoughLiquidity:!1,inAmount:P.BigInt(a.toString()),outAmount:P.BigInt(o.accumulatedAmountOut.toString()),feeAmount:P.BigInt(o.accumulatedFee.toString()),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:i}}getSwapLegAndAccounts(t){var e;if(!this.tickmap)throw new Error("Missing tickmap");const n=_o.getQuote(this.poolStructure,this.ticks,this.tickmap,t.sourceMint,t.amount,t.swapMode),o={};this.tickPkToTickIndexHash.forEach(((t,e)=>{o[e]=t}));const i=n.crossedTicks.concat(this.poolStructure.currentTickIndex).map((t=>{const e=o[t];if(!e)throw new Error("Missing tick account.");return e})),a=t.sourceMint.equals(this.poolStructure.tokenX);return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){const[i,a]=t.xToY?[e,n]:[n,e],s=t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[];return t.crossedTickAddresses.forEach((t=>{s.push({pubkey:t,isSigner:!1,isWritable:!0})})),s.push(uo),[$n(Kn(t.xToY)),O.instruction.invariantSwap({accounts:{swapProgram:j,tokenProgram:F,owner:o,state:X,pool:t.pool,tickmap:t.tickmap,accountX:i,accountY:a,reserveX:t.reserveX,reserveY:t.reserveY,programAuthority:Y},remainingAccounts:s}).keys]}({...t,additionalArgs:{xToY:a,pool:this.address,tickmap:this.poolStructure.tickmap,reserveX:this.poolStructure.tokenXReserve,reserveY:this.poolStructure.tokenYReserve,crossedTickAddresses:i,referrer:null===(e=t.quoteMintToReferrer)||void 0===e?void 0:e.get(t.sourceMint.toBase58())}})}get reserveTokenMints(){return[this.poolStructure.tokenX,this.poolStructure.tokenY]}}class Ho{constructor(e,n){var o;this.ammAccountInfo=void 0,this.id=void 0,this.label="Lifinity",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapState=void 0,this.poolInfo=void 0,this.ammData=void 0,this.slot=void 0,this.ammAccountInfo=n,this.id=e.toBase58(),this.swapState=((e,n)=>{const o=n.owner,i=Ne.decode(n.data),[a]=t.findProgramAddressSync([e.toBuffer()],o);return{programId:o,authority:a,amm:e,tokenAMint:i.tokenAMint,tokenBMint:i.tokenBMint,poolMint:i.poolMint,feeAccount:i.poolFeeAccount,pythAccount:i.pythAccount,pythPcAccount:i.pythPcAccount,configAccount:i.configAccount,poolCoinTokenAccount:i.tokenAAccount,poolCoinMint:i.tokenAMint,poolPcTokenAccount:i.tokenBAccount,poolPcMint:i.tokenBMint}})(e,n),this.poolInfo={amm:(o=this.swapState).amm.toBase58(),configAccount:o.configAccount.toBase58(),feeAccount:o.feeAccount.toBase58(),pythAccount:o.pythAccount.toBase58(),pythPcAccount:o.pythPcAccount.toBase58(),poolCoinMint:o.poolCoinMint.toBase58(),poolCoinTokenAccount:o.poolCoinTokenAccount.toBase58(),poolMint:o.poolMint.toBase58(),poolPcTokenAccount:o.poolPcTokenAccount.toBase58(),poolPcMint:o.poolPcMint.toBase58(),poolCoinDecimal:0,poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:0}}getAccountsForUpdate(){return[this.swapState.poolCoinTokenAccount,this.swapState.poolPcTokenAccount,this.swapState.configAccount,this.swapState.pythAccount,this.swapState.pythPcAccount,i]}update(t){const e=[];this.getAccountsForUpdate().forEach(((n,o)=>{const i=t.get(n.toBase58());i&&e.push({publicKey:n,account:i})})),this.ammData=Ue([{publicKey:this.swapState.amm,account:this.ammAccountInfo},...e],this.poolInfo),this.slot=Qo(e[e.length-1].account.data)}getQuote({sourceMint:t,amount:e}){if(!this.ammData||!this.slot)throw new Error("Accounts not loaded, missing ammData");if(this.isTradeFrozen)throw new Error("Trade is frozen");const n=this.swapState.poolCoinMint.equals(t)?Ke.AtoB:Ke.BtoA;if(!this.ammData.pyth.status.equals(1)||this.ammData.pythPc&&!this.ammData.pythPc.status.equals(1))throw new Error("Pyth accounts are outdated");const o=new te(e.toString()),i=ze(o,this.slot,this.ammData.amm,this.ammData.fees,this.ammData.coinBalance,this.ammData.pcBalance,this.ammData.config,this.ammData.pyth,this.ammData.pythPc,n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:P.BigInt(i.amountSwapped.toString()),feeAmount:P.BigInt(i.fee.ceil().toString()),feeMint:t.toBase58(),feePct:i.feePercent.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({swapState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){const[a,s]=e.equals(t.tokenAMint)?[t.poolCoinTokenAccount,t.poolPcTokenAccount]:[t.poolPcTokenAccount,t.poolCoinTokenAccount];return[$n({lifinity:{}}),O.instruction.lifinitySwap({accounts:{swapProgram:t.programId,authority:t.authority,amm:t.amm,userTransferAuthority:i,sourceInfo:n,destinationInfo:o,swapSource:a,swapDestination:s,poolMint:t.poolMint,feeAccount:t.feeAccount,tokenProgram:F,pythAccount:t.pythAccount,pythPcAccount:t.pythPcAccount,configAccount:t.configAccount}}).keys]}({swapState:this.swapState,...t})}get reserveTokenMints(){return[this.swapState.poolCoinMint,this.swapState.poolPcMint]}get isTradeFrozen(){var t;return 1===(null===(t=this.ammData)||void 0===t?void 0:t.amm.freezeTrade)}}class Zo{constructor(t,e){this.address=void 0,this.id=void 0,this.label="Lifinity V2",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.ammState=void 0,this.poolInfo=void 0,this.ammData=void 0,this.slot=void 0,this.address=t;const n=new Ht(We);var o;this.id=t.toBase58(),this.ammState=n.decode("amm",e.data),this.poolInfo={amm:this.id,poolMint:(o=this.ammState).poolMint.toBase58(),feeAccount:o.feeAccount.toBase58(),oracleMainAccount:o.oracleMainAccount.toBase58(),oracleSubAccount:o.oracleSubAccount.toBase58(),oraclePcAccount:o.oraclePcAccount.toBase58(),poolCoinTokenAccount:o.tokenAAccount.toBase58(),poolCoinMint:o.tokenAMint.toBase58(),poolCoinDecimal:0,poolPcTokenAccount:o.tokenBAccount.toBase58(),poolPcMint:o.tokenBMint.toBase58(),poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:o.baseDecimals}}getAccountsForUpdate(){return[this.address,this.ammState.tokenAAccount,this.ammState.tokenBAccount,this.ammState.oracleMainAccount,this.ammState.oracleSubAccount,this.ammState.oraclePcAccount,i]}update(t){const e=this.getAccountsForUpdate().reduce(((e,n)=>{const o=t.get(n.toBase58());return o&&e.push({publicKey:n,account:o}),e}),new Array);this.ammData=Qe(e,this.poolInfo),this.slot=Qo(e[e.length-1].account.data)}getQuote({sourceMint:t,amount:e}){if(!this.ammData)throw new Error("Accounts not loaded, missing ammData");if(void 0===this.slot)throw new Error("Slot not fetched");if(this.isTradeFrozen)throw new Error("Trade is frozen");const n=this.ammState.tokenAMint.equals(t)?je.AtoB:je.BtoA;if(this.ammData.oracleMain&&!this.ammData.oracleMain.status.equals(1)||this.ammData.oracleSub&&!this.ammData.oracleSub.status.equals(1)||this.ammData.oraclePc&&!this.ammData.oraclePc.status.equals(1))throw new Error("Pyth accounts are outdated");const o=new te(e.toString()),i=Xe(o,this.slot,this.ammData.amm,this.ammData.fees,this.ammData.coinBalance,this.ammData.pcBalance,this.ammData.config,this.ammData.oracleMain,this.ammData.oracleSub,this.ammData.oraclePc,n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:P.BigInt(i.amountSwapped.toString()),feeAmount:P.BigInt(i.fee.ceil().toString()),feeMint:t.toBase58(),feePct:i.feePercent.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({ammState:e,amm:n,sourceMint:o,userSourceTokenAccount:i,userDestinationTokenAccount:a,userTransferAuthority:s}){const[r,u]=o.equals(e.tokenAMint)?[e.tokenAAccount,e.tokenBAccount]:[e.tokenBAccount,e.tokenAAccount];return[$n({lifinityV2:{}}),O.instruction.lifinityV2Swap({accounts:{swapProgram:N,authority:t.findProgramAddressSync([n.toBuffer()],N)[0],amm:n,userTransferAuthority:s,sourceInfo:i,destinationInfo:a,swapSource:r,swapDestination:u,poolMint:e.poolMint,feeAccount:e.feeAccount,tokenProgram:F,oracleMainAccount:e.oracleMainAccount,oracleSubAccount:e.oracleSubAccount,oraclePcAccount:e.oraclePcAccount}}).keys]}({ammState:this.ammState,amm:this.address,...e})}get reserveTokenMints(){return[this.ammState.tokenAMint,this.ammState.tokenBMint]}get isTradeFrozen(){return 1===this.ammState.freezeTrade}}var Jo="0.1.0",Go="marinade_finance",ti=[{name:"initialize",accounts:[{name:"creatorAuthority",isMut:!1,isSigner:!0},{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!1,isSigner:!1},{name:"liqPool",accounts:[{name:"lpMint",isMut:!1,isSigner:!1},{name:"solLegPda",isMut:!1,isSigner:!1},{name:"msolLeg",isMut:!1,isSigner:!1}]},{name:"treasuryMsolAccount",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"data",type:{defined:"InitializeData"}}]},{name:"changeAuthority",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"data",type:{defined:"ChangeAuthorityData"}}]},{name:"addValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!1,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"score",type:"u32"}]},{name:"removeValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"}]},{name:"setValidatorScore",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"},{name:"score",type:"u32"}]},{name:"configValidatorSystem",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0}],args:[{name:"extraRuns",type:"u32"}]},{name:"deposit",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"depositStakeAccount",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeAuthority",isMut:!1,isSigner:!0},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"msolMint",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"liquidUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"addLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"lpMintAuthority",isMut:!1,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!1,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"removeLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"burnFrom",isMut:!0,isSigner:!1},{name:"burnFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"transferMsolTo",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokens",type:"u64"}]},{name:"configLp",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"params",type:{defined:"ConfigLpParams"}}]},{name:"configMarinade",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"params",type:{defined:"ConfigMarinadeParams"}}]},{name:"orderUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"burnMsolFrom",isMut:!0,isSigner:!1},{name:"burnMsolAuthority",isMut:!1,isSigner:!0},{name:"newTicketAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"claim",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"ticketAccount",isMut:!0,isSigner:!1},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"stakeReserve",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeConfig",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"updateActive",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"updateDeactivated",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"}]},{name:"deactivateStake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"splitStakeAccount",isMut:!0,isSigner:!0},{name:"splitStakeRentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"emergencyUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorManagerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"partialUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorManagerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"splitStakeAccount",isMut:!0,isSigner:!0},{name:"splitStakeRentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"},{name:"desiredUnstakeAmount",type:"u64"}]},{name:"mergeStakes",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"destinationStake",isMut:!0,isSigner:!1},{name:"sourceStake",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"destinationStakeIndex",type:"u32"},{name:"sourceStakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]}],ei=[{name:"State",type:{kind:"struct",fields:[{name:"msolMint",type:"publicKey"},{name:"adminAuthority",type:"publicKey"},{name:"operationalSolAccount",type:"publicKey"},{name:"treasuryMsolAccount",type:"publicKey"},{name:"reserveBumpSeed",type:"u8"},{name:"msolMintAuthorityBumpSeed",type:"u8"},{name:"rentExemptForTokenAcc",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"stakeSystem",type:{defined:"StakeSystem"}},{name:"validatorSystem",type:{defined:"ValidatorSystem"}},{name:"liqPool",type:{defined:"LiqPool"}},{name:"availableReserveBalance",type:"u64"},{name:"msolSupply",type:"u64"},{name:"msolPrice",type:"u64"},{name:"circulatingTicketCount",docs:["count tickets for delayed-unstake"],type:"u64"},{name:"circulatingTicketBalance",docs:["total lamports amount of generated and not claimed yet tickets"],type:"u64"},{name:"lentFromReserve",type:"u64"},{name:"minDeposit",type:"u64"},{name:"minWithdraw",type:"u64"},{name:"stakingSolCap",type:"u64"},{name:"emergencyCoolingDown",type:"u64"}]}},{name:"TicketAccountData",type:{kind:"struct",fields:[{name:"stateAddress",type:"publicKey"},{name:"beneficiary",type:"publicKey"},{name:"lamportsAmount",type:"u64"},{name:"createdEpoch",type:"u64"}]}}],ni=[{name:"LiqPool",type:{kind:"struct",fields:[{name:"lpMint",type:"publicKey"},{name:"lpMintAuthorityBumpSeed",type:"u8"},{name:"solLegBumpSeed",type:"u8"},{name:"msolLegAuthorityBumpSeed",type:"u8"},{name:"msolLeg",type:"publicKey"},{name:"lpLiquidityTarget",docs:["Liquidity target. If the Liquidity reach this amount, the fee reaches lp_min_discount_fee"],type:"u64"},{name:"lpMaxFee",docs:["Liquidity pool max fee"],type:{defined:"Fee"}},{name:"lpMinFee",docs:["SOL/mSOL Liquidity pool min fee"],type:{defined:"Fee"}},{name:"treasuryCut",docs:["Treasury cut"],type:{defined:"Fee"}},{name:"lpSupply",type:"u64"},{name:"lentFromSolLeg",type:"u64"},{name:"liquiditySolCap",type:"u64"}]}},{name:"List",type:{kind:"struct",fields:[{name:"account",type:"publicKey"},{name:"itemSize",type:"u32"},{name:"count",type:"u32"},{name:"newAccount",type:"publicKey"},{name:"copiedCount",type:"u32"}]}},{name:"StakeRecord",type:{kind:"struct",fields:[{name:"stakeAccount",type:"publicKey"},{name:"lastUpdateDelegatedLamports",type:"u64"},{name:"lastUpdateEpoch",type:"u64"},{name:"isEmergencyUnstaking",type:"u8"}]}},{name:"StakeSystem",type:{kind:"struct",fields:[{name:"stakeList",type:{defined:"List"}},{name:"delayedUnstakeCoolingDown",type:"u64"},{name:"stakeDepositBumpSeed",type:"u8"},{name:"stakeWithdrawBumpSeed",type:"u8"},{name:"slotsForStakeDelta",docs:["set by admin, how much slots before the end of the epoch, stake-delta can start"],type:"u64"},{name:"lastStakeDeltaEpoch",docs:["Marks the start of stake-delta operations, meaning that if somebody starts a delayed-unstake ticket","after this var is set with epoch_num the ticket will have epoch_created = current_epoch+1","(the user must wait one more epoch, because their unstake-delta will be execute in this epoch)"],type:"u64"},{name:"minStake",type:"u64"},{name:"extraStakeDeltaRuns",docs:["can be set by validator-manager-auth to allow a second run of stake-delta to stake late stakers in the last minute of the epoch","so we maximize user's rewards"],type:"u32"}]}},{name:"ValidatorRecord",type:{kind:"struct",fields:[{name:"validatorAccount",docs:["Validator vote pubkey"],type:"publicKey"},{name:"activeBalance",docs:["Validator total balance in lamports"],type:"u64"},{name:"score",type:"u32"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"duplicationFlagBumpSeed",type:"u8"}]}},{name:"ValidatorSystem",type:{kind:"struct",fields:[{name:"validatorList",type:{defined:"List"}},{name:"managerAuthority",type:"publicKey"},{name:"totalValidatorScore",type:"u32"},{name:"totalActiveBalance",docs:["sum of all active lamports staked"],type:"u64"},{name:"autoAddValidatorEnabled",docs:["allow & auto-add validator when a user deposits a stake-account of a non-listed validator"],type:"u8"}]}},{name:"Fee",type:{kind:"struct",fields:[{name:"basisPoints",type:"u32"}]}},{name:"InitializeData",type:{kind:"struct",fields:[{name:"adminAuthority",type:"publicKey"},{name:"validatorManagerAuthority",type:"publicKey"},{name:"minStake",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"liqPool",type:{defined:"LiqPoolInitializeData"}},{name:"additionalStakeRecordSpace",type:"u32"},{name:"additionalValidatorRecordSpace",type:"u32"},{name:"slotsForStakeDelta",type:"u64"}]}},{name:"LiqPoolInitializeData",type:{kind:"struct",fields:[{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"lpTreasuryCut",type:{defined:"Fee"}}]}},{name:"ChangeAuthorityData",type:{kind:"struct",fields:[{name:"admin",type:{option:"publicKey"}},{name:"validatorManager",type:{option:"publicKey"}},{name:"operationalSolAccount",type:{option:"publicKey"}},{name:"treasuryMsolAccount",type:{option:"publicKey"}}]}},{name:"ConfigLpParams",type:{kind:"struct",fields:[{name:"minFee",type:{option:{defined:"Fee"}}},{name:"maxFee",type:{option:{defined:"Fee"}}},{name:"liquidityTarget",type:{option:"u64"}},{name:"treasuryCut",type:{option:{defined:"Fee"}}}]}},{name:"ConfigMarinadeParams",type:{kind:"struct",fields:[{name:"rewardsFee",type:{option:{defined:"Fee"}}},{name:"slotsForStakeDelta",type:{option:"u64"}},{name:"minStake",type:{option:"u64"}},{name:"minDeposit",type:{option:"u64"}},{name:"minWithdraw",type:{option:"u64"}},{name:"stakingSolCap",type:{option:"u64"}},{name:"liquiditySolCap",type:{option:"u64"}},{name:"autoAddValidatorEnabled",type:{option:"bool"}}]}},{name:"CommonError",type:{kind:"enum",variants:[{name:"WrongReserveOwner"},{name:"NonEmptyReserveData"},{name:"InvalidInitialReserveLamports"},{name:"ZeroValidatorChunkSize"},{name:"TooBigValidatorChunkSize"},{name:"ZeroCreditChunkSize"},{name:"TooBigCreditChunkSize"},{name:"TooLowCreditFee"},{name:"InvalidMintAuthority"},{name:"MintHasInitialSupply"},{name:"InvalidOwnerFeeState"},{name:"InvalidProgramId"},{name:"UnexpectedAccount"},{name:"CalculationFailure"},{name:"AccountWithLockup"},{name:"NumberTooLow"},{name:"NumberTooHigh"},{name:"FeeTooHigh"},{name:"FeesWrongWayRound"},{name:"LiquidityTargetTooLow"},{name:"TicketNotDue"},{name:"TicketNotReady"},{name:"WrongBeneficiary"},{name:"StakeAccountNotUpdatedYet"},{name:"StakeNotDelegated"},{name:"StakeAccountIsEmergencyUnstaking"},{name:"InsufficientLiquidity"},{name:"InvalidValidator"}]}}],oi={__proto__:null,version:Jo,name:Go,instructions:ti,accounts:ei,types:ni,default:{version:Jo,name:Go,instructions:ti,accounts:ei,types:ni}};function ii(t,e,n){return n.isZero()?t:t.mul(e).div(n)}class ai{constructor(t,e){this.address=void 0,this.id=void 0,this.label="Marinade",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.marinadeFinanceProgram=void 0,this.marinadeStateResponse=void 0,this.liqPoolSolLegPdaAddress=void 0,this.marinadeState=void 0,this.id=t.toBase58(),this.marinadeFinanceProgram=new $t(oi,Q,{}),this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",e.data),this.address=t,this.liqPoolSolLegPdaAddress=this.findProgramDerivedAddress("liq_sol")}getAccountsForUpdate(){return[this.address,this.liqPoolSolLegPdaAddress,this.marinadeStateResponse.liqPool.msolLeg]}update(t){const[e,n,o]=An(t,this.getAccountsForUpdate());this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",e.data);const i=b(o.data);if(!i)throw new Error(`liqPoolMSOLLeg token account cannot be deserialized ${this.marinadeStateResponse.liqPool.msolLeg.toBase58()}`);this.marinadeState=new si(this.marinadeStateResponse,new q(n.lamports),i.amount)}getQuote({sourceMint:t,amount:e}){if(!this.marinadeState)throw new Error("Update was not run to create a complete marinadeState");const n=new q(e.toString()),o=t.equals(L)?this.marinadeState.depositQuote(n):this.marinadeState.liquidUnstakeQuote(n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:P.BigInt(o.outAmount.toString()),feeAmount:P.BigInt(o.feeAmount.toString()),feeMint:this.marinadeStateResponse.msolMint.toBase58(),feePct:o.feePct,priceImpactPct:0}}getSwapLegAndAccounts(e){return e.sourceMint.equals(L)?function({additionalArgs:e,userSourceTokenAccount:i,userDestinationTokenAccount:a,userTransferAuthority:s}){const r=t.findProgramAddressSync([Buffer.from("temp-wsol-token-account"),s.toBuffer()],W)[0],u=t.findProgramAddressSync([Buffer.from("temp-sol-pda"),s.toBuffer()],W)[0];return[$n({marinadeDeposit:{}}),O.instruction.marinadeDeposit({accounts:{marinadeFinanceProgram:Q,state:e.address,msolMint:e.marinadeStateResponse.msolMint,liqPoolSolLegPda:e.liqPoolSolLegPda,liqPoolMsolLeg:e.marinadeStateResponse.liqPool.msolLeg,liqPoolMsolLegAuthority:e.liqPoolMsolLegAuthority,reservePda:e.reservePda,transferFrom:u,mintTo:a,msolMintAuthority:e.msolMintAuthority,systemProgram:n.programId,tokenProgram:F,userWsolTokenAccount:i,tempWsolTokenAccount:r,userTransferAuthority:s,wsolMint:L,rent:o}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress,liqPoolMsolLegAuthority:this.findProgramDerivedAddress("liq_st_sol_authority"),reservePda:this.findProgramDerivedAddress("reserve"),msolMintAuthority:this.findProgramDerivedAddress("st_mint")},...e}):function({additionalArgs:e,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:a}){const s=t.findProgramAddressSync([Buffer.from("temp-sol-pda"),a.toBuffer()],W)[0];return[$n({marinadeUnstake:{}}),O.instruction.marinadeUnstake({accounts:{marinadeFinanceProgram:Q,state:e.address,msolMint:e.marinadeStateResponse.msolMint,liqPoolSolLegPda:e.liqPoolSolLegPda,liqPoolMsolLeg:e.marinadeStateResponse.liqPool.msolLeg,treasuryMsolAccount:e.marinadeStateResponse.treasuryMsolAccount,getMsolFrom:o,getMsolFromAuthority:a,transferSolTo:s,systemProgram:n.programId,tokenProgram:F,userWsolTokenAccount:i}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress},...e})}get reserveTokenMints(){return[L,this.marinadeStateResponse.msolMint]}findProgramDerivedAddress(e,n=[]){const o=[this.address.toBuffer(),Buffer.from(e),...n],[i]=t.findProgramAddressSync(o,this.marinadeFinanceProgram.programId);return i}}class si{constructor(t,e,n){this.state=void 0,this.liqPoolSolLegPdaLamports=void 0,this.liqPoolMSOLLegAmount=void 0,this.state=t,this.liqPoolSolLegPdaLamports=e,this.liqPoolMSOLLegAmount=n}depositQuote(t){let e=t;const n=this.calcMSOLFromLamports(e),o=q.min(n,this.liqPoolMSOLLegAmount);let i=new q(0);if(e=(()=>{if(o.gt(new q(0))){const t=n.eq(o)?e:this.calcLamportsFromMSOLAmount(o);return i=i.add(o),ri(e,t)}return e})(),e.gt(new q(0))){this.checkStakingCap(e);const t=this.calcMSOLFromLamports(e);i=i.add(t)}return{outAmount:i,feeAmount:0,feePct:0,priceImpactPct:0}}checkStakingCap(t){if(this.totalLamportsUnderControl().add(t).gt(this.state.stakingSolCap))throw new Error("Staking cap reached")}calcMSOLFromLamports(t){return e=t,n=this.totalVirtualStakedLamports(),(o=this.state.msolSupply).eq(new q(0))?e:ii(e,o,n);var e,n,o}calcLamportsFromMSOLAmount(t){return ii(t,this.totalVirtualStakedLamports(),this.state.msolSupply)}totalVirtualStakedLamports(){return ri(this.totalLamportsUnderControl(),this.state.circulatingTicketBalance)}totalLamportsUnderControl(){return this.state.validatorSystem.totalActiveBalance.add(this.totalCoolingDown()).add(this.state.availableReserveBalance)}totalCoolingDown(){return this.state.stakeSystem.delayedUnstakeCoolingDown.add(this.state.emergencyCoolingDown)}liquidUnstakeQuote(t){const e=ri(this.liqPoolSolLegPdaLamports,this.state.rentExemptForTokenAcc),n=this.calcLamportsFromMSOLAmount(t),o=function(t,e,n,o,i){if(i.gte(o))return e;const a=o.sub(i);return a.gte(n)?t:e-ii(new q(e-t),a,n).toNumber()}(this.state.liqPool.lpMinFee.basisPoints,this.state.liqPool.lpMaxFee.basisPoints,this.state.liqPool.lpLiquidityTarget,e,n),i=t.mul(new q(o)).div(new q(1e4)),a=this.calcLamportsFromMSOLAmount(t.sub(i));if(a.add(this.state.rentExemptForTokenAcc).gt(this.liqPoolSolLegPdaLamports))throw new Error("Insufficient liquidity");return{outAmount:a,feeAmount:i,feePct:o/1e4,priceImpactPct:0}}}function ri(t,e){return t.gt(e)?t.sub(e):new q(0)}const ui=Math.pow(10,10),ci=Wt([Qt("version"),Qt("isInitialized"),Qt("nonce"),In("amplificationCoefficient"),In("feeNumerator"),In("adminFeeNumerator"),jt("tokenAccountsLength"),In("precisionFactor"),In("precisionMultiplierA"),In("precisionMultiplierB"),In("precisionMultiplierC"),In("precisionMultiplierD"),vn("tokenAccountA"),vn("tokenAccountB"),vn("tokenAccountC"),vn("tokenAccountD")]),mi=(t,e)=>{const n=e.owner,o=ci.decode(e.data),i=o.tokenAccountsLength,a=Ln([t.toBuffer(),Buffer.from([o.nonce])],n),s=[o.precisionMultiplierA.toNumber(),o.precisionMultiplierB.toNumber(),o.precisionMultiplierC.toNumber(),o.precisionMultiplierD.toNumber()].slice(0,i),r=[o.tokenAccountA,o.tokenAccountB,o.tokenAccountC,o.tokenAccountD].slice(0,i);return{programId:n,authority:a,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:t,amplificationCoefficient:o.amplificationCoefficient.toNumber(),feeNumerator:o.feeNumerator.toNumber(),tokenAccountsLength:i,precisionFactor:o.precisionFactor.toNumber(),precisionMultipliers:s,tokenAccounts:r}};class di{constructor(e,n,o){this.address=void 0,this.params=void 0,this.id=void 0,this.label="Mercurial",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapLayout=void 0,this.tokenMints=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.address=e,this.params=o,this.id=e.toBase58(),this.swapLayout=mi(e,n),this.calculator=di.calculatorFromSwapState(this.swapLayout),this.tokenMints=o.tokenMints.map((e=>new t(e)))}getAccountsForUpdate(){return[this.address,...this.swapLayout.tokenAccounts]}static calculatorFromSwapState(t){return new y(P.BigInt(t.tokenAccountsLength),P.BigInt(t.amplificationCoefficient),t.precisionMultipliers.map((t=>P.BigInt(t))),new S(P.BigInt(t.feeNumerator),P.BigInt(ui)))}update(t){const[e,...n]=An(t,this.getAccountsForUpdate());this.swapLayout=di.decodeSwapLayout(this.address,e),this.calculator=di.calculatorFromSwapState(this.swapLayout),this.tokenReserveAmounts=Mn(n)}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(!this.tokenReserveAmounts)throw new Error(wn);const o=this.tokenReserveAmounts.findIndex(((e,n)=>this.tokenMints[n].equals(t))),i=this.tokenReserveAmounts.findIndex(((t,n)=>this.tokenMints[n].equals(e))),a=this.calculator.exchange(this.tokenReserveAmounts,n,o,i),s=this.swapLayout.feeNumerator/ui;return{notEnoughLiquidity:!1,inAmount:n,outAmount:a.expectedOutputAmount,feeAmount:a.fees,feeMint:e.toBase58(),feePct:s,priceImpactPct:a.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({swapLayout:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){const i=[];for(const e of t.tokenAccounts)i.push({pubkey:e,isSigner:!1,isWritable:!0});return[$n({mercurial:{}}),O.instruction.mercurialSwap({accounts:mo(t,e,n,o),remainingAccounts:i}).keys]}({swapLayout:this.swapLayout,...t})}get reserveTokenMints(){return this.params.tokenMints.map((e=>new t(e)))}}di.decodeSwapLayout=mi;const pi=new $t(Ye,_e,no),li=new $t($e,_e,no),hi=t=>pi.coder.accounts.decode("pool",t.data),gi=t=>li.coder.accounts.decode("vault",t.data);class Si{constructor(e,n,o){var i,a;this.address=void 0,this.id=void 0,this.label="Meteora",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.data=void 0,this.depegAccount=void 0,this.depegAccounts=new Map,this.vaultLpMint=void 0,this.vaultToken=void 0,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.poolState=hi(n),this.vaultLpMint={a:new t(o.vaultLpMint.a),b:new t(o.vaultLpMint.b)},this.vaultToken={a:new t(o.vaultToken.a),b:new t(o.vaultToken.b)};const s=this.poolState.curveType,r=Object.keys((null==s||null===(i=s.stable)||void 0===i||null===(a=i.depeg)||void 0===a?void 0:a.depegType)||{})[0];if(r&&"none"!==r)if("lido"===r||"marinade"===r)this.depegAccount={pubkey:Ze[r]};else{if("splStake"!==r)throw new Error("depegType not supported");this.depegAccount={pubkey:this.poolState.stake}}const{ownerTradeFeeDenominator:u,ownerTradeFeeNumerator:c,tradeFeeDenominator:m,tradeFeeNumerator:d}=this.poolState.fees;this.feePct=new te(c.toString()).div(u.toString()).add(new te(d.toString()).div(m.toString())).toNumber()}getAccountsForUpdate(){var t;const e=[this.poolState.aVault,this.poolState.bVault,this.poolState.aVaultLp,this.poolState.bVaultLp,this.poolState.lpMint,this.vaultLpMint.a,this.vaultLpMint.b,this.vaultToken.a,this.vaultToken.b,i];return null!==(t=this.depegAccount)&&void 0!==t&&t.pubkey&&e.push(this.depegAccount.pubkey),e}update(t){const[e,n,o,i,a,s,r,u,c,m,d]=An(t,this.getAccountsForUpdate());d&&this.depegAccount&&this.depegAccounts.set(this.depegAccount.pubkey.toBase58(),d),this.data={vaultA:gi(e),vaultB:gi(n),poolAVaultLpAmount:zo(o),poolBVaultLpAmount:zo(i),poolLpTotalSupply:Wo(a),vaultALpTotalSupply:Wo(s),vaultBLpTotalSupply:Wo(r),vaultAReserve:zo(u),vaultBReserve:zo(c),currentTime:jo(m.data)}}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(void 0===this.data||this.depegAccount&&0===this.depegAccounts.size)throw new Error("Missing initial fetch");const o=new x(n.toString()),i=He(t,o,{currentTime:this.data.currentTime,depegAccounts:this.depegAccounts,poolState:this.poolState,poolVaultALp:this.data.poolAVaultLpAmount,poolVaultBLp:this.data.poolBVaultLpAmount,vaultA:this.data.vaultA,vaultALpSupply:this.data.vaultALpTotalSupply,vaultB:this.data.vaultB,vaultBLpSupply:this.data.vaultBLpTotalSupply,vaultAReserve:this.data.vaultAReserve,vaultBReserve:this.data.vaultBReserve});return{notEnoughLiquidity:!1,inAmount:n,outAmount:P.BigInt(i.amountOut.toString()),feeAmount:P.BigInt(i.fee.toString()),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(t){var e,n;if(void 0===this.data)throw new Error("Unable to fetch accounts.");const o=t.sourceMint.equals(this.poolState.tokenAMint)?this.poolState.adminTokenAFee:this.poolState.adminTokenBFee;return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){const i=[];return i.push(t.referrer?{pubkey:t.referrer,isSigner:!1,isWritable:!0}:uo),i.push(t.depeg?{pubkey:t.depeg,isSigner:!1,isWritable:!1}:uo),[$n({meteora:{}}),O.instruction.meteoraSwap({accounts:{swapProgram:_,pool:t.pool,userSourceToken:e,userDestinationToken:n,aVault:t.aVault,bVault:t.bVault,aTokenVault:t.aTokenVault,bTokenVault:t.bTokenVault,aVaultLpMint:t.aVaultLpMint,bVaultLpMint:t.bVaultLpMint,aVaultLp:t.aVaultLp,bVaultLp:t.bVaultLp,adminTokenFee:t.adminTokenFee,user:o,vaultProgram:$,tokenProgram:F},remainingAccounts:i}).keys]}({additionalArgs:{pool:this.address,aVault:this.poolState.aVault,bVault:this.poolState.bVault,aTokenVault:this.vaultToken.a,bTokenVault:this.vaultToken.b,aVaultLpMint:this.vaultLpMint.a,bVaultLpMint:this.vaultLpMint.b,aVaultLp:this.poolState.aVaultLp,bVaultLp:this.poolState.bVaultLp,adminTokenFee:o,referrer:null===(e=t.quoteMintToReferrer)||void 0===e?void 0:e.get(t.sourceMint.toBase58()),depeg:null===(n=this.depegAccount)||void 0===n?void 0:n.pubkey},...t})}get currentTime(){var t;if(void 0===this.data)throw new Error("Missing initial fetch");return null===(t=this.data)||void 0===t?void 0:t.currentTime}get poolVaults(){if(void 0===this.data)throw new Error("Missing initial fetch");return[this.data.vaultA,this.data.vaultB]}get poolVaultLPShares(){if(void 0===this.data)throw new Error("Missing initial fetch");return[this.data.poolAVaultLpAmount,this.data.poolBVaultLpAmount]}get poolVaultLPTotalSupplies(){if(void 0===this.data)throw new Error("Missing initial fetch");return[this.data.vaultALpTotalSupply,this.data.vaultBLpTotalSupply]}get reserveTokenMints(){return[this.poolState.tokenAMint,this.poolState.tokenBMint]}}Si.accountInfoToMeteoraSwapLayout=hi,Si.accountInfoToVaultLayout=gi;const ki=Wt([Xt("status"),Xt("nonce"),Xt("orderNum"),Xt("depth"),Xt("coinDecimals"),Xt("pcDecimals"),Xt("state"),Xt("resetFlag"),Xt("minSize"),Xt("volMaxCutRatio"),Xt("amountWaveRatio"),Xt("coinLotSize"),Xt("pcLotSize"),Xt("minPriceMultiplier"),Xt("maxPriceMultiplier"),Xt("systemDecimalsValue"),Xt("minSeparateNumerator"),Xt("minSeparateDenominator"),Xt("tradeFeeNumerator"),Xt("tradeFeeDenominator"),Xt("pnlNumerator"),Xt("pnlDenominator"),Xt("swapFeeNumerator"),Xt("swapFeeDenominator"),Xt("needTakePnlCoin"),Xt("needTakePnlPc"),Xt("totalPnlPc"),Xt("totalPnlCoin"),Bn("poolTotalDepositPc"),Bn("poolTotalDepositCoin"),Bn("swapCoinInAmount"),Bn("swapPcOutAmount"),Xt("swapCoin2PcFee"),Bn("swapPcInAmount"),Bn("swapCoinOutAmount"),Xt("swapPc2CoinFee"),vn("poolCoinTokenAccount"),vn("poolPcTokenAccount"),vn("coinMintAddress"),vn("pcMintAddress"),vn("lpMintAddress"),vn("ammOpenOrders"),vn("serumMarket"),vn("serumProgramId"),vn("ammTargetOrders"),vn("poolWithdrawQueue"),vn("poolTempLpTokenAccount"),vn("ammOwner"),vn("pnlOwner")]);class fi{constructor(e,n,o){this.ammId=void 0,this.id=void 0,this.label="Raydium",this.shouldPrefetch=!1,this.exactOutputSupported=!0,this.hasDynamicAccounts=!1,this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.feePct=void 0,this.calculator=void 0,this.ammId=e,this.id=e.toBase58();const i=ki.decode(n.data);this.status=i.status,this.coinMint=new t(i.coinMintAddress),this.pcMint=new t(i.pcMintAddress),this.poolCoinTokenAccount=new t(i.poolCoinTokenAccount),this.poolPcTokenAccount=new t(i.poolPcTokenAccount),this.serumProgramId=new t(i.serumProgramId),this.serumMarket=new t(i.serumMarket),this.ammOpenOrders=new t(i.ammOpenOrders),this.ammTargetOrders=new t(i.ammTargetOrders),this.serumMarketKeys=Object.keys(o).reduce(((e,n)=>{if(!o[n])throw new Error(`Could not find ${n} in params`);return e[n]=new t(o[n]),e}),{});const a=i.swapFeeNumerator,s=i.swapFeeDenominator;this.feePct=new te(a.toString()).div(s.toString()),this.calculator=new k(new S(P.BigInt(a),P.BigInt(s)),A)}static decodeSerumMarketKeysString(t,e,n,o){if(!e.equals(ft))return{serumBids:t.toBase58(),serumAsks:t.toBase58(),serumEventQueue:t.toBase58(),serumCoinVaultAccount:t.toBase58(),serumPcVaultAccount:t.toBase58(),serumVaultSigner:t.toBase58()};const i=u.getLayout(e).decode(o.data),a=Ln([n.toBuffer(),i.vaultSignerNonce.toArrayLike(Buffer,"le",8)],e);return{serumBids:i.bids.toBase58(),serumAsks:i.asks.toBase58(),serumEventQueue:i.eventQueue.toBase58(),serumCoinVaultAccount:i.baseVault.toBase58(),serumPcVaultAccount:i.quoteVault.toBase58(),serumVaultSigner:a.toBase58()}}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders]}update(t){const[e,n,o,i]=An(t,this.getAccountsForUpdate()),[a,s]=[zo(n),zo(o)],r=c.fromAccountInfo(this.ammOpenOrders,i,i.owner),u=ki.decode(e.data);this.coinReserve=P.BigInt(a.add(r.baseTokenTotal).sub(new B(String(u.needTakePnlCoin)))),this.pcReserve=P.BigInt(s.add(r.quoteTokenTotal).sub(new B(String(u.needTakePnlPc))))}getQuoteInternal({amount:t,sourceMint:e,coinReserve:n,pcReserve:o,swapMode:i}){const a=this.coinMint.equals(e)?1:0;if(i==yn.ExactIn){const e=this.calculator.exchange([n,o],t,a);return{inAmount:t,outAmount:e.expectedOutputAmount,feeAmount:e.fees,priceImpactPct:e.priceImpact.toNumber()}}{const e=this.calculator.exchangeForExactOutput([n,o],t,a);return{inAmount:e.expectedInputAmount,outAmount:t,feeAmount:e.fees,priceImpactPct:e.priceImpact.toNumber()}}}getQuote({sourceMint:t,amount:e,swapMode:n}){const{coinReserve:o,pcReserve:i}=this;if(!this.isTradable)throw new Error("Pool is not tradable");if(!o||!i)throw new Error("Pool token accounts balances not refreshed or empty");return{...this.getQuoteInternal({amount:e,sourceMint:t,coinReserve:o,pcReserve:i,swapMode:n}),notEnoughLiquidity:!1,feeMint:t.toBase58(),feePct:this.feePct.toNumber()}}getSwapLegAndAccounts(t){return function({raydiumAmm:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){return[$n({raydium:{}}),O.instruction.raydiumSwap({accounts:lo(t,e,n,o)}).keys]}({raydiumAmm:this,...t})}createExactOutSwapInstruction(t){return function({raydiumAmm:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o,outAmount:i,inAmount:a,slippageBps:s,platformFee:r,overflowFeeAccount:u}){var c;return O.instruction.raydiumSwapExactOutput(i,{amount:a,slippageBps:s},null!==(c=null==r?void 0:r.feeBps)&&void 0!==c?c:0,{accounts:lo(t,e,n,o),remainingAccounts:So(null==r?void 0:r.feeAccount,u)})}({raydiumAmm:this,...t,outAmount:new q(t.amount.toString()),inAmount:new q(t.inAmount.toString())})}get reserveTokenMints(){return[this.coinMint,this.pcMint]}get isTradable(){return 1===this.status||6===this.status}}const yi=new $t({version:"0.0.1",name:"add_decimals",instructions:[],accounts:[{name:"wrappedToken",type:{kind:"struct",fields:[{name:"decimals",type:"u8"},{name:"multiplier",type:"u64"},{name:"wrappedUnderlyingMint",type:"publicKey"},{name:"wrappedUnderlyingTokens",type:"publicKey"},{name:"wrapperMint",type:"publicKey"},{name:"nonce",type:"u8"}]}}],errors:[]},V,no);class Ai{constructor(t,e){this.address=void 0,this.accountInfo=void 0,this.id=void 0,this.label="Saber (Decimals)",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.wrappedToken=void 0,this.multiplierJsbi=void 0,this.address=t,this.accountInfo=e,this.id=t.toBase58(),this.wrappedToken=yi.coder.accounts.decode("wrappedToken",e.data),this.multiplierJsbi=P.BigInt(this.wrappedToken.multiplier)}getAccountsForUpdate(){return new Array}update(t){}toWrappedAmount(t){return P.multiply(this.multiplierJsbi,t)}toUnderlyingAmount(t){return P.divide(t,this.multiplierJsbi)}getAmounts(t,e){if(e)return[t,this.toWrappedAmount(t)];{const e=this.toUnderlyingAmount(t);return[this.toWrappedAmount(e),e]}}getQuote({sourceMint:t,amount:e}){const n=this.wrappedToken.wrappedUnderlyingMint.equals(t),[o,i]=this.getAmounts(e,n);return{notEnoughLiquidity:!1,inAmount:o,outAmount:i,feeAmount:M,feeMint:t.toBase58(),feePct:0,priceImpactPct:0}}getSwapLegAndAccounts(t){return function({wrapper:t,wrappedToken:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,deposit:a}){return[$n(a?{saberAddDecimalsDeposit:{}}:{saberAddDecimalsWithdraw:{}}),O.instruction.saberAddDecimals({accounts:{addDecimalsProgram:V,wrapper:t,wrapperMint:e.wrapperMint,wrapperUnderlyingTokens:e.wrappedUnderlyingTokens,owner:i,userUnderlyingTokens:a?n:o,userWrappedTokens:a?o:n,tokenProgram:F}}).keys]}({wrapper:this.address,wrappedToken:this.wrappedToken,...t,deposit:this.wrappedToken.wrappedUnderlyingMint.equals(t.sourceMint)})}get reserveTokenMints(){return[this.wrappedToken.wrappedUnderlyingMint,this.wrappedToken.wrapperMint]}get wrapperMint(){return this.wrappedToken.wrapperMint}}class Mi{constructor(t){this.stableSwap=void 0,this.id=void 0,this.label="Saber",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenReserveAmounts=void 0,this.stableSwapState=void 0,this.calculator=void 0,this.stableSwap=t,this.id=t.config.swapAccount.toBase58(),this.stableSwapState=t.state,this.calculator=new y(w,d(this.stableSwap.state),[T,T],new S(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getAccountsForUpdate(){return[this.stableSwap.config.swapAccount,i,this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(t){const[e,n,...o]=An(t,this.getAccountsForUpdate());this.stableSwapState=p(e.data);const i=jo(n.data);this.calculator.setAmp(d(this.stableSwapState,i)),this.calculator.setTraderFee(new S(this.stableSwapState.fees.trade.numerator,this.stableSwapState.fees.trade.denominator)),this.tokenReserveAmounts=Mn(o)}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(this.stableSwap.state.isPaused)throw new Error("Saber pool is paused");if(!this.tokenReserveAmounts)throw new Error(wn);const[o,i]=this.stableSwap.state.tokenA.mint.equals(t)?[0,1]:[1,0],a=this.calculator.exchange(this.tokenReserveAmounts,n,o,i),s=new te(this.stableSwap.state.fees.trade.asFraction.toFixed(4));return{notEnoughLiquidity:!1,inAmount:n,outAmount:a.expectedOutputAmount,feeAmount:a.fees,feeMint:e.toBase58(),feePct:s.toNumber(),priceImpactPct:a.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({stableSwap:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){return[$n({saber:{}}),O.instruction.saberSwap({accounts:go(t,e,n,o,i)}).keys]}({stableSwap:this.stableSwap,...t})}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const wi=Wt([zt(8,"discriminator"),vn("factory"),Qt("bump"),In("index"),vn("admin"),vn("token0Reserves"),vn("token0Mint"),vn("token0Fees"),vn("token1Reserves"),vn("token1Mint"),vn("token1Fees"),Qt("isPaused"),vn("poolMint"),In("tradeFeeKbps"),In("withdrawFeeKbps"),In("adminTradeFeeKbps"),In("adminWithdrawFeeKbps")]);class Ti{constructor(t,e){this.id=void 0,this.label="Sencha",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.calculator=void 0,this.tokenReserveAmounts=void 0,this.id=t.toBase58(),this.poolState=((t,e)=>{const n=e.owner,o=wi.decode(e.data);return{programId:n,isPaused:Boolean(o.isPaused),bump:o.bump,ammId:t,token0Reserves:o.token0Reserves,token1Reserves:o.token1Reserves,token0Mint:o.token0Mint,token1Mint:o.token1Mint,token0Fees:o.token0Fees,token1Fees:o.token1Fees,poolMint:o.poolMint,tradeFeeKbps:o.tradeFeeKbps.toNumber()}})(t,e),this.calculator=new k(new S(P.BigInt(this.poolState.tradeFeeKbps),P.BigInt(1e7)),new S(M,M),!1)}get isPaused(){return this.poolState.isPaused}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(t){const e=An(t,this.getAccountsForUpdate());this.tokenReserveAmounts=Mn(e)}getQuote({sourceMint:t,amount:e}){if(this.isPaused)throw new Error("Sencha pool is paused");if(!this.tokenReserveAmounts)throw new Error(wn);const n=this.poolState.token0Mint.equals(t)?1:0;let o=this.calculator.exchange(this.tokenReserveAmounts,e,n),i=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:e,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:t.toBase58(),feePct:i,priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({poolState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){const[a,s]=e.equals(t.token0Mint)?[t.token0Reserves,t.token1Reserves]:[t.token1Reserves,t.token0Reserves],[r,u]=e.equals(t.token0Mint)?[t.token0Fees,t.token1Fees]:[t.token1Fees,t.token0Fees];return[$n({sencha:{}}),O.instruction.senchaSwap({accounts:{swapProgram:t.programId,tokenProgram:F,swap:t.ammId,userAuthority:i,inputUserAccount:n,inputTokenAccount:a,inputFeesAccount:r,outputUserAccount:o,outputTokenAccount:s,outputFeesAccount:u}}).keys]}({poolState:this.poolState,...t})}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}const Pi=4e-4,vi=1e-4,bi=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z","EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ","8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m","2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"],Ii=["B2na8Awyd7cpC59iEU43FagJAPLigr3AP3s38KM982bu"];function*Bi(t){const e=t.isBids;for(const{key:n,quantity:o}of t.slab.items(e)){const t=P.BigInt(n.ushrn(64).toString());yield[t,P.BigInt(o.toString())]}}function Fi(t,e){const n=t._decoded.baseLotSize;return n.isZero()?new te(0):function(t,e){const n=new te(t.div(e).toString()),o=t.umod(e),i=o.gcd(e);return n.add(new te(o.div(i).toString()).div(new te(e.div(i).toString())))}(e.mul(t._decoded.quoteLotSize).mul(t._baseSplTokenMultiplier),n.mul(t._quoteSplTokenMultiplier))}class Li{constructor(t){this.market=void 0,this.id=void 0,this.label=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this._orderbooks=void 0,this.isOpenbook=void 0,this.market=t,this.id=t.address.toBase58(),this.isOpenbook=t.programId.equals(ft),this.label=this.isOpenbook?"Openbook":"Serum"}get orderbooks(){return this._orderbooks}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(t){const[e,n]=An(t,this.getAccountsForUpdate()),o=m.decode(this.market,e.data),i=m.decode(this.market,n.data);this._orderbooks={asks:o,bids:i}}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const o=function({market:t,asks:e,bids:n,fromAmount:o,fromMint:i,toMint:a,isOpenbook:s}){const r=s?Ii.includes(t.address.toBase58())?vi:Pi:bi.includes(t.address.toBase58())?vi:Pi;return i.equals(t.quoteMintAddress)&&a.equals(t.baseMintAddress)?function(t,e,n,o){let i=M,a=M,s=M,r=M,u=M;const c=t.quoteSizeLotsToNumber(new q(1));let m=c?P.BigInt(new te(n.toString()).div(1+o).div(c).floor()):M;const d=P.BigInt(t.baseSizeLotsToNumber(new q(1)).toString());for(let[t,n]of Bi(e)){P.equal(a,M)&&(a=t),s=t;const e=P.multiply(n,d),o=P.multiply(n,t);if(u=P.add(u,e),P.greaterThanOrEqual(o,m)){const e=P.divide(m,t);r=P.add(r,P.multiply(t,e)),i=P.add(i,P.multiply(d,e)),m=M;break}r=P.add(r,P.multiply(t,n)),i=P.add(i,e),m=P.subtract(m,o)}let p=0;if(P.notEqual(a,M)){const t=new te(a.toString());p=new te(s.toString()).sub(t).div(t).toNumber()}const l=Fi(t,new q(a.toString())),h=Fi(t,new q(r.toString())),g=h.mul(d.toString()).ceil(),S=h.mul(d.toString()).mul(o).ceil();return{side:"buy",notEnoughLiquidity:P.lessThanOrEqual(u,i),minimum:{in:P.BigInt(l.mul(d.toString()).mul(1+o).ceil()),out:d},inAmount:P.BigInt(g.add(S)),outAmount:i,feeAmount:P.BigInt(S),priceImpactPct:p,feePct:o}}(t,e,o,r):function(t,e,n,o){let i=P.BigInt(0),a=P.BigInt(0),s=P.BigInt(0),r=P.BigInt(0),u=n,c=P.BigInt(0);const m=P.BigInt(t.baseSizeLotsToNumber(new q(1))),d=P.BigInt(t.quoteSizeLotsToNumber(new q(1)));for(const[t,n]of Bi(e)){P.equal(a,M)&&(a=t),s=t;const e=P.multiply(m,n),o=P.multiply(n,P.multiply(t,d));if(r=P.add(r,e),P.greaterThanOrEqual(e,u)){const e=P.divide(u,m),n=P.multiply(e,t);i=P.add(i,P.multiply(n,d)),u=P.subtract(u,n),c=P.add(c,P.multiply(e,m));break}i=P.add(i,o),u=P.subtract(u,e),c=P.add(c,e)}let p=new te(i.toString()).mul(1-o).floor(),l=0;const h=Fi(t,new q(a.toString()));if(P.notEqual(a,M)){const e=Fi(t,new q(s.toString()));l=h.minus(e).div(h).toNumber()}return{side:"sell",notEnoughLiquidity:P.greaterThan(P.BigInt(n),r),minimum:{in:m,out:P.BigInt(h.mul(P.toNumber(m)).mul(1-o).floor().toString())},inAmount:c,outAmount:P.BigInt(p),feeAmount:P.BigInt(new te(i.toString()).mul(o).round()),priceImpactPct:l,feePct:o}}(t,n,o,r)}({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:t,toMint:e,fromAmount:n,isOpenbook:this.isOpenbook});return{notEnoughLiquidity:o.notEnoughLiquidity,minInAmount:o.minimum.in,minOutAmount:o.minimum.out,inAmount:o.inAmount,outAmount:o.outAmount,feeAmount:o.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:o.feePct,priceImpactPct:o.priceImpactPct}}getSwapLegAndAccounts(t){var e;if(!t.openOrdersAddress)throw new Error("Missing open orders");return function({market:t,sourceMint:e,openOrdersAddress:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:a,referrer:s,isOpenbook:r}){const{side:u,coinWallet:c,pcWallet:m}=e.equals(t.baseMintAddress)?{side:On.Ask,coinWallet:o,pcWallet:i}:{side:On.Bid,coinWallet:i,pcWallet:o};return[$n(r?Qn(u):Cn(u)),O.instruction.serumSwap({accounts:ho(t,n,o,c,m,a),remainingAccounts:s?[{pubkey:s,isSigner:!1,isWritable:!0}]:[uo]}).keys]}({market:this.market,openOrdersAddress:t.openOrdersAddress,referrer:null==t||null===(e=t.quoteMintToReferrer)||void 0===e?void 0:e.get(this.market.quoteMintAddress.toBase58()),isOpenbook:this.isOpenbook,...t})}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}Li.getL2=Bi;const Di=Wt([Qt("version"),Qt("isInitialized"),Qt("bumpSeed"),vn("tokenProgramId"),vn("tokenAccountA"),vn("tokenAccountB"),vn("tokenPool"),vn("mintA"),vn("mintB"),vn("feeAccount"),In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator"),In("hostFeeNumerator"),In("hostFeeDenominator"),Qt("curveType"),zt(32,"curveParameters")]),qi=Wt([Qt("version"),Qt("isInitialized"),Qt("bumpSeed"),vn("tokenProgramId"),vn("tokenAccountA"),vn("tokenAccountB"),vn("tokenPool"),vn("mintA"),vn("mintB"),vn("feeAccount"),In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator"),Qt("curveType"),zt(32,"curveParameters"),Qt("poolNonce")]);var xi;!function(t){t[t.ConstantProduct=0]="ConstantProduct",t[t.Stable=2]="Stable"}(xi||(xi={}));class Ei{constructor(e,n,o){if(this.label=void 0,this.id=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenSwapState=void 0,this.curveType=void 0,this.feePct=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.label=o,this.id=e.toBase58(),this.tokenSwapState=function(e,n){const o=n.owner,i=o.equals(yt)?qi.decode(n.data):Di.decode(n.data);if(!i.isInitialized)throw new Error("Invalid token swap state");const a=Ln([e.toBuffer(),Buffer.from([i.bumpSeed])],o),s=new t(i.tokenPool),r=new t(i.feeAccount),u=new t(i.tokenAccountA),c=new t(i.tokenAccountB),m=new t(i.mintA),d=new t(i.mintB);return{address:e,programId:o,tokenProgramId:new t(i.tokenProgramId),poolToken:s,feeAccount:r,authority:a,tokenAccountA:u,tokenAccountB:c,mintA:m,mintB:d,tradeFeeNumerator:i.tradeFeeNumerator,tradeFeeDenominator:i.tradeFeeDenominator,ownerTradeFeeNumerator:i.ownerTradeFeeNumerator,ownerTradeFeeDenominator:i.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:i.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:i.ownerWithdrawFeeDenominator,curveType:i.curveType,curveParameters:i.curveParameters,poolNonce:"poolNonce"in i?i.poolNonce:void 0}}(e,n),this.curveType=this.tokenSwapState.curveType,!(this.curveType in xi))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);const i=Ei.getFeeFraction(this.tokenSwapState.tradeFeeNumerator,this.tokenSwapState.tradeFeeDenominator),a=Ei.getFeeFraction(this.tokenSwapState.ownerTradeFeeNumerator,this.tokenSwapState.ownerTradeFeeDenominator);this.calculator=this.tokenSwapState.curveType===xi.ConstantProduct?new k(i,a):new g(P.BigInt(this.tokenSwapState.curveParameters[0]),i,a),this.feePct=Ei.getFeeDecimal(this.tokenSwapState.tradeFeeNumerator,this.tokenSwapState.tradeFeeDenominator).add(Ei.getFeeDecimal(this.tokenSwapState.ownerTradeFeeNumerator,this.tokenSwapState.ownerTradeFeeDenominator)).toNumber()}static getFeeFraction(t,e){return new S(P.BigInt(t.toString()),P.BigInt(e.toString()))}static getFeeDecimal(t,e){return t.eq(new B(0))?new te(0):new te(t.toString()).div(e.toString())}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(t){const e=An(t,this.getAccountsForUpdate());this.tokenReserveAmounts=Mn(e)}getQuote({sourceMint:t,amount:e}){if(!this.tokenReserveAmounts)throw new Error(wn);const n=this.reserveTokenMints[0].equals(t)?1:0,o=this.calculator.exchange(this.tokenReserveAmounts,e,n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(t){return function({tokenSwapState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,isStep:a}){const[s,r]=e.equals(t.mintA)?[t.tokenAccountA,t.tokenAccountB]:[t.tokenAccountB,t.tokenAccountA];return[$n(a?{step:{}}:{tokenSwap:{}}),(a?O.instruction.stepSwap:O.instruction.tokenSwap)({accounts:{tokenSwapProgram:t.programId,tokenProgram:F,swap:t.address,authority:t.authority,userTransferAuthority:i,source:n,swapSource:s,swapDestination:r,destination:o,poolMint:t.poolToken,poolFee:t.feeAccount}}).keys]}({tokenSwapState:this.tokenSwapState,...t,isStep:this.tokenSwapState.programId.equals(yt)})}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}function Oi(t){return t.reduce(((e,n)=>(t.forEach((t=>{n!==t&&e.push([n,t])})),e)),new Array)}const Ci=P.BigInt(100);class Ri{constructor(t,e,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.market=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.portion1=0,this.portion2=0,this.firstAmm=t,this.secondAmm=e,this.reserveTokenMints=n,this.market=t instanceof Li?t.market:e instanceof Li?e.market:null}static getAmmIdsFromSplitTradeAmmId(t){const e=t.split("-");return e.length>1?e:[]}static create(t,e){if(!function(t,e){return!Sn(pn,t.label,e.label)}(t,e))return;const n=Oi(t.reserveTokenMints),o=Oi(e.reserveTokenMints);for(const i of n)for(const n of o)if(i.every(((t,e)=>t.equals(n[e]))))return new Ri(t,e,i)}setPortions(t,e){if(t+e!==100)throw new Error("Split trade portions must sum to 100");this.portion1=t,this.portion2=e}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((t,e)=>e.portion-t.portion)).map((({label:t,portion:e})=>`${t} (${e}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(t){}getQuote(t){const e=t.sourceMint.toBase58(),n=t.amount;let o={outAmount:M,portion:0,firstQuote:void 0,secondQuote:void 0};for(let e=100;e-=5;e>0){const i=P.divide(P.multiply(n,P.BigInt(e)),Ci),a=P.subtract(n,i),s=this.firstAmm.getQuote({...t,amount:i}),r=this.secondAmm.getQuote({...t,amount:a}),u=P.add(s.outAmount,r.outAmount);if(P.lessThan(u,o.outAmount))break;o={outAmount:u,portion:e,firstQuote:s,secondQuote:r}}if(!o.firstQuote||!o.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:i,portion:a,firstQuote:s,secondQuote:r}=o,u=a,c=100-u;this.portion1=u,this.portion2=c;let m={amount:s.feeAmount,mint:s.feeMint},d={amount:r.feeAmount,mint:r.feeMint};m.mint!==d.mint&&(m.mint!==e&&(m={amount:P.divide(P.divide(P.multiply(m.amount,P.multiply(n,P.BigInt(u))),Ci),o.outAmount),mint:e}),d.mint!==e&&(d={amount:P.divide(P.divide(P.multiply(P.multiply(d.amount,n),P.BigInt(c)),Ci),o.outAmount),mint:e}));const p=(u*s.feePct+c*r.feePct)/100,l=(u*s.priceImpactPct+c*r.priceImpactPct)/100;return{notEnoughLiquidity:!1,inAmount:t.amount,outAmount:i,feeAmount:P.add(m.amount,d.amount),feeMint:m.mint,feePct:p,priceImpactPct:l}}getSwapLegAndAccounts(t){let[e,n]=this.firstAmm.getSwapLegAndAccounts(t),[o,i]=this.secondAmm.getSwapLegAndAccounts(t),a=[Hn(this.portion1,e),Hn(this.portion2,o)],s=[...n,...i];return[_n(a),s]}}function Vi(t,e){const n=tn.parse(e);if(!n)throw new Error(`Failed to parse whirlpool ${t.toBase58()}`);return n}function Ni(t,e){const n=en.parse(e);if(!n)throw new Error(`Failed to parse tick array ${t.toBase58()}`);return n}class Ui{constructor(e,n){this.address=void 0,this.id=void 0,this.label="Orca (Whirlpools)",this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.hasDynamicAccounts=!0,this.whirlpoolData=void 0,this.tickArrays={aToB:[],bToA:[]},this.tickPks=void 0,this.oracle=void 0,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.whirlpoolData=Vi(e,n.data),this.oracle=t.findProgramAddressSync([Buffer.from("oracle"),e.toBuffer()],z)[0],this.feePct=new te(this.whirlpoolData.feeRate).div(1e6),this.tickPks=this.getTickArrayPks()}getTickArrayPks(){const t={aToB:[],bToA:[]};return[!0,!1].forEach((e=>{t[e?"aToB":"bToA"].push(...Je.getTickArrayPublicKeys(this.whirlpoolData.tickCurrentIndex,this.whirlpoolData.tickSpacing,e,z,this.address))})),t}getAccountsForUpdate(){return[this.address,...this.tickPks.aToB,...this.tickPks.bToA]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Missing ${this.address.toBase58()}`);this.whirlpoolData=Vi(this.address,e.data),this.tickPks=this.getTickArrayPks();const n={aToB:[],bToA:[]};[!0,!1].forEach((e=>{const o=e?"aToB":"bToA";for(const e of this.tickPks[o]){const i=e.toBase58(),a=t.get(i);if(!a)continue;const s=Ni(e,a.data);n[o].push({address:e,data:s})}})),this.tickArrays=n}getQuote({sourceMint:t,amount:e,swapMode:n}){const o=!!t.equals(this.whirlpoolData.tokenMintA),i=n===yn.ExactIn,a=Ge({amountSpecifiedIsInput:i,aToB:o,otherAmountThreshold:Je.getDefaultOtherAmountThreshold(i),sqrtPriceLimit:Je.getDefaultSqrtPriceLimit(o),tickArrays:this.tickArrays[o?"aToB":"bToA"],tokenAmount:new q(e.toString()),whirlpoolData:this.whirlpoolData}),s=P.BigInt(a.estimatedAmountIn.toString()),r=P.BigInt(a.estimatedAmountOut.toString()),u=P.BigInt(a.estimatedFeeAmount.toString()),c=a.aToB?new te(a.estimatedAmountOut.toString()).div(a.estimatedAmountIn.toString()):new te(a.estimatedAmountIn.toString()).div(a.estimatedAmountOut.toString()),m=(d=this.whirlpoolData.sqrtPrice,new te(d.toString()).mul(te.pow(2,-64))).pow(2);var d;const p=m.minus(c).div(m).abs().toNumber();return{notEnoughLiquidity:!1,inAmount:s,outAmount:r,feeAmount:u,feeMint:t.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:Number(p)}}getSwapLegAndAccounts(t){const e=t.sourceMint.equals(this.whirlpoolData.tokenMintA),n=t.swapMode===yn.ExactIn,{tickArray0:o,tickArray1:i,tickArray2:a}=Ge({amountSpecifiedIsInput:n,aToB:e,otherAmountThreshold:Je.getDefaultOtherAmountThreshold(n),sqrtPriceLimit:Je.getDefaultSqrtPriceLimit(e),tickArrays:this.tickArrays[e?"aToB":"bToA"],tokenAmount:new q(t.amount.toString()),whirlpoolData:this.whirlpoolData});return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){const[i,a]=t.aToB?[e,n]:[n,e];return[$n(Un(t.aToB)),O.instruction.whirlpoolSwap({accounts:{swapProgram:z,tokenProgram:F,tokenAuthority:o,whirlpool:t.whirlpool,tokenOwnerAccountA:i,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:a,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle}}).keys]}({additionalArgs:{aToB:e,whirlpool:this.address,tickArray0:o,tickArray1:i,tickArray2:a,oracle:this.oracle,...this.whirlpoolData},...t})}createExactOutSwapInstruction(t){const e=t.sourceMint.equals(this.whirlpoolData.tokenMintA),n=t.swapMode===yn.ExactIn,{tickArray0:o,tickArray1:i,tickArray2:a}=Ge({amountSpecifiedIsInput:n,aToB:e,otherAmountThreshold:Je.getDefaultOtherAmountThreshold(n),sqrtPriceLimit:Je.getDefaultSqrtPriceLimit(e),tickArrays:this.tickArrays[e?"aToB":"bToA"],tokenAmount:new q(t.amount.toString()),whirlpoolData:this.whirlpoolData});return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o,outAmount:i,inAmount:a,slippageBps:s,platformFee:r,overflowFeeAccount:u}){var c;const[m,d]=t.aToB?[e,n]:[n,e];return O.instruction.whirlpoolSwapExactOutput(i,{amount:a,slippageBps:s},t.aToB,null!==(c=null==r?void 0:r.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:z,tokenProgram:F,tokenAuthority:o,whirlpool:t.whirlpool,tokenOwnerAccountA:m,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:d,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle},remainingAccounts:So(null==r?void 0:r.feeAccount,u)})}({additionalArgs:{aToB:e,whirlpool:this.address,tickArray0:o,tickArray1:i,tickArray2:a,oracle:this.oracle,...this.whirlpoolData},...t,outAmount:new q(t.amount.toString()),inAmount:new q(t.inAmount.toString())})}get reserveTokenMints(){return[this.whirlpoolData.tokenMintA,this.whirlpoolData.tokenMintB]}}class Ki{constructor(e,n,o){this.address=void 0,this.id=void 0,this.label="Dradex",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.state=void 0,this.orderBookState=void 0,this.quoteCalculator=void 0,this.marketUser=void 0,this.address=e,this.id=e.toBase58(),this.state=nn.accounts.decode("market",n.data),this.marketUser=new t(o.marketUser)}getAccountsForUpdate(){return[this.address,...this.reserveTokenMints,this.state.orderBook.bids,this.state.orderBook.asks]}update(t){const e=t.get(this.id),n=t.get(this.state.orderBook.bids.toString()),o=t.get(this.state.orderBook.asks.toString()),i=this.reserveTokenMints.map((e=>t.get(e.toString())));if(!e||!n||!o||i.find((t=>!t)))throw new Error(`One of the required accounts is missing: ${this.address.toBase58()}`);if(i.length!==this.reserveTokenMints.length)throw new Error(`Missing mint info: ${this.address.toBase58()}`);this.state=nn.accounts.decode("market",e.data);const a=this.reserveTokenMints.map(((t,e)=>I(i[e].data,t)));this.orderBookState={bids:an.decode(n.data).items,asks:an.decode(o.data).items},this.quoteCalculator=new on(this.state,this.orderBookState,a)}getQuote(t){if(!this.quoteCalculator)throw new Error(`Quote calculator is not initialized: ${this.address.toBase58()}`);const e=this.quoteCalculator.getQuote(t);return{...e,priceImpactPct:e.priceImpactPct/100}}getSwapLegAndAccounts(t){var e;return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:o,userTransferAuthority:i,sourceMint:a}){const{side:s,t0User:r,t1User:u}=a.equals(t.t0)?{side:On.Ask,t0User:e,t1User:o}:{side:On.Bid,t0User:o,t1User:e};return[$n(zn(s)),O.instruction.dradexSwap({accounts:{swapProgram:et,pair:t.pair,market:t.market,eventQueue:t.eventQueue,dexUser:nt,marketUser:t.marketUser,bids:t.bids,asks:t.asks,t0Vault:t.t0Vault,t1Vault:t.t1Vault,t0User:r,t1User:u,master:ot,signer:i,systemProgram:n.programId,tokenProgram:F,logger:it},remainingAccounts:t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[uo]}).keys]}({additionalArgs:{pair:this.state.pair,market:this.address,eventQueue:this.state.eventQueue,marketUser:this.marketUser,bids:this.state.orderBook.bids,asks:this.state.orderBook.asks,t0:this.state.t0,t1:this.state.t1,t0Vault:this.state.t0Vault,t1Vault:this.state.t1Vault,referrer:null===(e=t.quoteMintToReferrer)||void 0===e?void 0:e.get(t.destinationMint.toBase58())},...t})}get reserveTokenMints(){return[this.state.t0,this.state.t1]}}class zi{constructor(t,e){this.address=void 0,this.label="Raydium CLMM",this.id=void 0,this.reserveTokenMints=void 0,this.hasDynamicAccounts=!0,this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.programId=void 0,this.poolState=void 0,this.coder=void 0,this.tickArrayPks=void 0,this.tickArrayCache={},this.ammV3PoolInfo=void 0,this.address=t,this.id=t.toBase58(),this.address=t,this.coder=new Ht(sn),this.poolState=this.coder.decode("poolState",e.data),this.reserveTokenMints=[this.poolState.tokenMint0,this.poolState.tokenMint1],this.programId=ut,this.tickArrayPks=rn.getTickArrayPks(this.address,this.poolState,this.programId)}getAccountsForUpdate(){return[this.address,this.poolState.ammConfig,...this.tickArrayPks]}update(t){const e=t.get(this.id);if(!e)throw new Error("Missing poolStateAccountInfo");const n=t.get(this.poolState.ammConfig.toBase58());if(!n)throw new Error("Missing ammConfigAccoutnInfo");this.poolState=this.coder.decode("poolState",e.data);const o=this.coder.decode("ammConfig",n.data);this.tickArrayPks=rn.getTickArrayPks(this.address,this.poolState,this.programId);const i={};for(const e of this.tickArrayPks){const n=t.get(e.toBase58());if(!n)continue;const o=this.coder.decode("tickArrayState",n.data);i[o.startTickIndex]={...o,address:e}}this.tickArrayCache=i,this.ammV3PoolInfo=rn.formatPoolInfo({address:this.address,poolState:this.poolState,ammConfig:o,programId:this.programId})}getQuote(t){if(0!==this.poolState.status)throw new Error("Pool is not swapable");if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");if(t.swapMode===yn.ExactIn){const{amountOut:e,fee:n,priceImpact:o}=rn.computeAmountOut({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:t.sourceMint,amountIn:new q(t.amount.toString()),slippage:0});return{notEnoughLiquidity:!1,inAmount:t.amount,outAmount:P.BigInt(e.toString()),feeAmount:P.BigInt(n.toString()),feeMint:t.sourceMint.toString(),feePct:this.ammV3PoolInfo.ammConfig.tradeFeeRate/10**6,priceImpactPct:o}}{const{amountIn:e,fee:n,priceImpact:o}=rn.computeAmountIn({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:t.destinationMint,amountOut:new q(t.amount.toString()),slippage:0});return{notEnoughLiquidity:!1,inAmount:P.BigInt(e.toString()),outAmount:t.amount,feeAmount:P.BigInt(n.toString()),feeMint:t.sourceMint.toString(),feePct:this.ammV3PoolInfo.ammConfig.tradeFeeRate/10**6,priceImpactPct:o}}}getSwapLegAndAccounts(t){if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");const{remainingAccounts:e}=rn.computeAmountOut({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:t.sourceMint,amountIn:new q(t.amount.toString()),slippage:0}),[n,o]=t.sourceMint.equals(this.poolState.tokenMint0)?[this.poolState.tokenVault0,this.poolState.tokenVault1]:[this.poolState.tokenVault1,this.poolState.tokenVault0],i=e.shift();if(!i)throw new Error("Missing at least one tick array");return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o}){const i=t.remainingAccounts.map((t=>({pubkey:t,isWritable:!0,isSigner:!1})));return i.push(uo),[$n({raydiumClmm:{}}),O.instruction.raydiumClmmSwap({accounts:{swapProgram:ut,payer:o,ammConfig:t.ammConfig,poolState:t.poolState,inputTokenAccount:e,outputTokenAccount:n,inputVault:t.inputVault,outputVault:t.outputVault,observationState:t.observationState,tokenProgram:F,tickArray:t.tickArray},remainingAccounts:i}).keys]}({additionalArgs:{poolState:this.address,inputVault:n,outputVault:o,observationState:this.poolState.observationKey,tickArray:i,remainingAccounts:e,...this.poolState},...t})}createExactOutSwapInstruction(t){if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");const{remainingAccounts:e}=rn.computeAmountIn({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:t.destinationMint,amountOut:new q(t.amount.toString()),slippage:0}),[n,o]=t.sourceMint.equals(this.poolState.tokenMint0)?[this.poolState.tokenVault0,this.poolState.tokenVault1]:[this.poolState.tokenVault1,this.poolState.tokenVault0],i=e.shift();if(!i)throw new Error("Missing at least one tick array");return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o,outAmount:i,inAmount:a,slippageBps:s,platformFee:r,overflowFeeAccount:u}){var c;const m=t.remainingAccounts.map((t=>({pubkey:t,isWritable:!0,isSigner:!1})));return m.push(uo),m.push(...So(null==r?void 0:r.feeAccount,u)),O.instruction.raydiumClmmSwapExactOutput(i,{amount:a,slippageBps:s},null!==(c=null==r?void 0:r.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:ut,payer:o,ammConfig:t.ammConfig,poolState:t.poolState,inputTokenAccount:e,outputTokenAccount:n,inputVault:t.inputVault,outputVault:t.outputVault,observationState:t.observationState,tokenProgram:F,tickArray:t.tickArray},remainingAccounts:m})}({additionalArgs:{poolState:this.address,inputVault:n,outputVault:o,observationState:this.poolState.observationKey,tickArray:i,remainingAccounts:e,...this.poolState},...t,outAmount:new q(t.amount.toString()),inAmount:new q(t.inAmount.toString())})}}const Wi=new $t({version:"0.1.1",name:"marcopolo",instructions:[{name:"createPool",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!0},{name:"poolYAccount",isMut:!0,isSigner:!0},{name:"adminXAccount",isMut:!0,isSigner:!1},{name:"adminYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"projectOwner",isMut:!1,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"lpFee",type:{defined:"FixedPoint"}},{name:"buybackFee",type:{defined:"FixedPoint"}},{name:"projectFee",type:{defined:"FixedPoint"}},{name:"mercantiFee",type:{defined:"FixedPoint"}},{name:"initialTokenX",type:{defined:"Token"}},{name:"initialTokenY",type:{defined:"Token"}},{name:"bump",type:"u8"}]},{name:"createProvider",accounts:[{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"tokenXAmount",type:{defined:"Token"}},{name:"tokenYAmount",type:{defined:"Token"}},{name:"bump",type:"u8"}]},{name:"createState",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"nonce",type:"u8"}]},{name:"addTokens",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"deltaX",type:{defined:"Token"}},{name:"deltaY",type:{defined:"Token"}}]},{name:"withdrawBuyback",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"buybackXAccount",isMut:!0,isSigner:!1},{name:"buybackYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"swap",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"swapperXAccount",isMut:!0,isSigner:!1},{name:"swapperYAccount",isMut:!0,isSigner:!1},{name:"swapper",isMut:!0,isSigner:!0},{name:"referrerXAccount",isMut:!0,isSigner:!1},{name:"referrerYAccount",isMut:!0,isSigner:!1},{name:"referrer",isMut:!0,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"deltaIn",type:{defined:"Token"}},{name:"priceLimit",type:{defined:"FixedPoint"}},{name:"xToY",type:"bool"}]},{name:"withdrawShares",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"shares",type:{defined:"Token"}}]},{name:"withdrawLpFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"withdrawProjectFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"projectOwnerXAccount",isMut:!0,isSigner:!1},{name:"projectOwnerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"projectOwner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"createFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supply",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"createDualFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenProjectFirst",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"createTripleFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenProjectFirst",isMut:!1,isSigner:!1},{name:"tokenProjectSecond",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!0},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"supplyProjectSecond",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"withdrawRewards",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"closePool",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"buybackXAccount",isMut:!0,isSigner:!1},{name:"buybackYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"withdrawMercantiFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"mercantiXAccount",isMut:!0,isSigner:!1},{name:"mercantiYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"addSupply",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"supplyProjectSecond",type:{defined:"Token"}},{name:"duration",type:"u64"}]},{name:"updateFees",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1}],args:[{name:"newBuybackFee",type:{defined:"FixedPoint"}},{name:"newProjectFee",type:{defined:"FixedPoint"}},{name:"newProviderFee",type:{defined:"FixedPoint"}},{name:"newMercantiFee",type:{defined:"FixedPoint"}}]},{name:"resetFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"farm",type:{kind:"struct",fields:[{name:"pool",type:"publicKey"},{name:"tokens",type:{array:["publicKey",3]}},{name:"tokenAccounts",type:{array:["publicKey",3]}},{name:"supply",type:{array:[{defined:"Token"},3]}},{name:"supplyLeft",type:{array:[{defined:"Token"},3]}},{name:"accumulatedSecondsPerShare",type:{defined:"FixedPoint"}},{name:"offsetSecondsPerShare",type:{defined:"FixedPoint"}},{name:"startTime",type:"u64"},{name:"endTime",type:"u64"},{name:"lastUpdate",type:"u64"},{name:"bump",type:"u8"},{name:"farmType",type:{defined:"FarmType"}}]}},{name:"pool",type:{kind:"struct",fields:[{name:"tokenX",type:"publicKey"},{name:"tokenY",type:"publicKey"},{name:"poolXAccount",type:"publicKey"},{name:"poolYAccount",type:"publicKey"},{name:"admin",type:"publicKey"},{name:"projectOwner",type:"publicKey"},{name:"tokenXReserve",type:{defined:"Token"}},{name:"tokenYReserve",type:{defined:"Token"}},{name:"selfShares",type:{defined:"Token"}},{name:"allShares",type:{defined:"Token"}},{name:"buybackAmountX",type:{defined:"Token"}},{name:"buybackAmountY",type:{defined:"Token"}},{name:"projectAmountX",type:{defined:"Token"}},{name:"projectAmountY",type:{defined:"Token"}},{name:"mercantiAmountX",type:{defined:"Token"}},{name:"mercantiAmountY",type:{defined:"Token"}},{name:"lpAccumulatorX",type:{defined:"FixedPoint"}},{name:"lpAccumulatorY",type:{defined:"FixedPoint"}},{name:"constK",type:{defined:"Product"}},{name:"price",type:{defined:"FixedPoint"}},{name:"lpFee",type:{defined:"FixedPoint"}},{name:"buybackFee",type:{defined:"FixedPoint"}},{name:"projectFee",type:{defined:"FixedPoint"}},{name:"mercantiFee",type:{defined:"FixedPoint"}},{name:"farmCount",type:"u64"},{name:"bump",type:"u8"}]}},{name:"provider",type:{kind:"struct",fields:[{name:"tokenX",type:"publicKey"},{name:"tokenY",type:"publicKey"},{name:"owner",type:"publicKey"},{name:"shares",type:{defined:"Token"}},{name:"lastFeeAccumulatorX",type:{defined:"FixedPoint"}},{name:"lastFeeAccumulatorY",type:{defined:"FixedPoint"}},{name:"lastSecondsPerShare",type:{defined:"FixedPoint"}},{name:"lastWithdrawTime",type:"u64"},{name:"tokensOwedX",type:{defined:"Token"}},{name:"tokensOwedY",type:{defined:"Token"}},{name:"currentFarmCount",type:"u64"},{name:"bump",type:"u8"}]}},{name:"state",type:{kind:"struct",fields:[{name:"admin",type:"publicKey"},{name:"programAuthority",type:"publicKey"},{name:"bump",type:"u8"},{name:"nonce",type:"u8"}]}}],types:[{name:"FixedPoint",type:{kind:"struct",fields:[{name:"v",type:"u128"}]}},{name:"Token",type:{kind:"struct",fields:[{name:"v",type:"u64"}]}},{name:"Product",type:{kind:"struct",fields:[{name:"v",type:"u128"}]}},{name:"FarmType",type:{kind:"enum",variants:[{name:"Single"},{name:"Dual"},{name:"Triple"}]}}],errors:[{code:6e3,name:"DeltaTooBig",msg:"Delta greater than provider's tokens"},{code:6001,name:"TokenUnderflow",msg:"Token amount underflow"},{code:6002,name:"WrongRatio",msg:"Wrong tokens ratio"},{code:6003,name:"TooMuchShares",msg:"Too much shares provided"},{code:6004,name:"SwapToBig",msg:"Swap too big"},{code:6005,name:"FeeExceeded",msg:"Fee exceeded 100%"},{code:6007,name:"ScalesNotEqual",msg:"Scales have to be equal"},{code:6008,name:"FeeExceededDeltaOut",msg:"Fees exceeded delta_out"},{code:6009,name:"PriceLimitExceeded",msg:"Price limit exceeded"},{code:6010,name:"MintMismatch",msg:"Mint mismatch"},{code:6011,name:"TokensAreTheSame",msg:"Tokens are the same"},{code:6012,name:"WrongFarm",msg:"Cannot add supply to wrong farm"},{code:6013,name:"RewardsExceedingSupply",msg:"Cannot withdraw rewards exceeding supply left"},{code:6014,name:"FarmNotEnded",msg:"Farm has not ended, cannot add additional rewards"},{code:6015,name:"ZeroAmount",msg:"Must provide a nonzero amount"},{code:6016,name:"InvariantChanged",msg:"Invariant has changed"}],metadata:{address:"9tKE7Mbmj4mxDjWatikzGAtkoWosiiZX9y6J4Hfm2R8H"}},gt,no),Qi=new te(10).pow(12);class ji{constructor(t,e){this.address=void 0,this.id=void 0,this.label=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.isBonkSwap=void 0,this.pool=void 0,this.calculator=void 0,this.feePct=void 0,this.tokenReserveAmounts=void 0,this.address=t,this.id=t.toBase58(),this.pool=this.decodePoolState(e),this.isBonkSwap=e.owner.equals(pt),this.label=this.isBonkSwap?"BonkSwap":"Oasis";const n=this.pool.lpFee.v.add(this.pool.buybackFee.v).add(this.pool.mercantiFee.v).add(this.pool.projectFee.v);this.feePct=new te(n.toString()).div(Qi),this.calculator=new k(new S(P.BigInt(n),P.BigInt(Qi)),A,!1)}decodePoolState(t){return Wi.coder.accounts.decode("pool",t.data)}getAccountsForUpdate(){return[this.address]}update(t){const e=t.get(this.id);if(!e)throw new Error(`Pool account info is not found: ${this.id}`);const n=this.decodePoolState(e);this.pool=n,this.tokenReserveAmounts=[P.BigInt(n.tokenXReserve.v),P.BigInt(n.tokenYReserve.v)]}getQuote({destinationMint:t,amount:e}){const{tokenX:n}=this.pool;if(!this.tokenReserveAmounts)throw new Error(wn);const o=t.equals(n)?0:1,i=this.calculator.exchange(this.tokenReserveAmounts,e,o);return{notEnoughLiquidity:!1,inAmount:e,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:t.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(t){const e=At;return function({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:i,userTransferAuthority:a,sourceMint:s}){const r=s.equals(t.tokenX),{swapperXAccount:u,swapperYAccount:c}=r?{swapperXAccount:e,swapperYAccount:i}:{swapperXAccount:i,swapperYAccount:e};let[m,d,p]=t.isBonkSwap?[pt,lt,ht]:[gt,St,kt];return[$n(Wn(r)),O.instruction.marcoPoloSwap({accounts:{swapProgram:m,state:d,pool:t.pool,tokenX:t.tokenX,tokenY:t.tokenY,poolXAccount:t.poolXAccount,poolYAccount:t.poolYAccount,swapperXAccount:u,swapperYAccount:c,swapper:a,referrerXAccount:t.referrerXAccount,referrerYAccount:t.referrerYAccount,referrer:t.referrer,programAuthority:p,systemProgram:n.programId,tokenProgram:F,associatedTokenProgram:D,rent:o}}).keys]}({additionalArgs:{pool:this.address,tokenX:this.pool.tokenX,tokenY:this.pool.tokenY,poolXAccount:this.pool.poolXAccount,poolYAccount:this.pool.poolYAccount,referrer:e,referrerXAccount:rt({walletAddress:e,tokenMintAddress:this.pool.tokenX}),referrerYAccount:rt({walletAddress:e,tokenMintAddress:this.pool.tokenY}),isBonkSwap:this.isBonkSwap},...t})}get reserveTokenMints(){return[this.pool.tokenX,this.pool.tokenY]}}ji.getProgram=()=>Wi;const Xi=P.BigInt(1e4);class Yi{constructor(t,e){this.address=void 0,this.id=void 0,this.label="Phoenix",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.marketData=void 0,this.ladder=void 0,this.outAmountWithoutFeesMultiplier=void 0,this.baseLotsPerBaseUnit=void 0,this.baseLotSize=void 0,this.quoteLotSize=void 0,this.tickSizeInQuoteLotsPerBaseUnitPerTick=void 0,this.address=t,this.id=t.toBase58(),this.marketData=un(e.data),this.outAmountWithoutFeesMultiplier=P.BigInt(1e4-this.marketData.takerFeeBps),this.baseLotsPerBaseUnit=P.BigInt(this.marketData.baseLotsPerBaseUnit);const n=this.marketData.header;this.baseLotSize=P.BigInt(n.baseLotSize.toString()),this.quoteLotSize=P.BigInt(n.quoteLotSize.toString()),this.tickSizeInQuoteLotsPerBaseUnitPerTick=P.divide(P.BigInt(n.tickSizeInQuoteAtomsPerBaseUnit.toString()),this.quoteLotSize)}getAccountsForUpdate(){return[this.address,i]}update(t){const[e,n]=An(t,this.getAccountsForUpdate());if(!e)throw new Error(`Missing market accountInfo ${this.address.toBase58()}`);const o=cn.load({address:this.address,buffer:e.data,tokenList:[]});this.marketData=o.data;const i=Qo(n.data),a=jo(n.data);this.ladder=mn(o,-1,i,a)}JSBImin(t,e){return P.lessThan(t,e)?t:e}computeQuote({sourceMint:t,amount:e}){if(!this.ladder)throw new Error(`Missing ladder for Phoenix: ${this.address.toBase58()}`);let n,o=P.BigInt(0),i=M,a=!1;if(t.equals(this.marketData.header.baseParams.mintKey)){let t=P.divide(e,this.baseLotSize);const s=P.BigInt(t);for(const{priceInTicks:e,sizeInBaseLots:i}of this.ladder.bids){if(P.lessThanOrEqual(t,M))break;const a=P.BigInt(e.toString()),s=P.BigInt(i.toString()),r=this.JSBImin(s,t),u=P.divide(P.multiply(P.multiply(P.multiply(a,r),this.tickSizeInQuoteLotsPerBaseUnitPerTick),this.quoteLotSize),this.baseLotsPerBaseUnit);if(!n){const t=P.multiply(r,this.baseLotSize);n=new te(u.toString()).div(t.toString())}o=P.add(o,u),t=P.subtract(t,r)}i=P.multiply(P.subtract(s,t),this.baseLotSize),P.greaterThan(t,M)&&(a=!0)}else{let t=P.divide(e,this.quoteLotSize);const s=P.BigInt(t);for(const{priceInTicks:e,sizeInBaseLots:i}of this.ladder.asks){if(P.lessThanOrEqual(t,M))break;const a=P.BigInt(e.toString()),s=P.BigInt(i.toString()),r=P.divide(P.divide(P.multiply(t,this.baseLotsPerBaseUnit),this.tickSizeInQuoteLotsPerBaseUnitPerTick),a);let u,c;P.greaterThan(s,r)?(u=r,c=t):(u=s,c=P.divide(P.multiply(P.multiply(a,u),this.tickSizeInQuoteLotsPerBaseUnitPerTick),this.baseLotsPerBaseUnit));const m=P.multiply(u,this.baseLotSize);if(!n){const t=P.multiply(c,this.quoteLotSize);n=new te(m.toString()).div(t.toString())}o=P.add(o,m),t=P.subtract(t,c)}i=P.multiply(P.subtract(s,t),this.quoteLotSize),P.greaterThan(t,M)&&(a=!0)}const s=this.computAmountAfterFees(o),r=P.subtract(o,s),u=new te(o.toString()).div(e.toString());if(!n)throw new Error("No best price");return{notEnoughLiquidity:a,inAmount:i,outAmount:s,feeAmount:r,priceImpactPct:n.sub(u).div(n).toNumber()}}computAmountAfterFees(t){return P.divide(P.multiply(t,this.outAmountWithoutFeesMultiplier),Xi)}getQuote({sourceMint:t,amount:e}){const{notEnoughLiquidity:n,inAmount:o,outAmount:i,feeAmount:a,priceImpactPct:s}=this.computeQuote({sourceMint:t,amount:e});return{notEnoughLiquidity:n,inAmount:o,outAmount:i,feeAmount:a,feeMint:t.toBase58(),feePct:this.marketData.takerFeeBps/1e4,priceImpactPct:s}}getSwapLegAndAccounts(e){return function({additionalArgs:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){const{side:a,baseAccount:s,quoteAccount:r}=e.equals(t.baseMint)?{side:On.Ask,baseAccount:n,quoteAccount:o}:{side:On.Bid,baseAccount:o,quoteAccount:n};return[$n(jn(a)),O.instruction.phoenixSwap({accounts:{swapProgram:ct,logAuthority:t.logAuthority,market:t.market,trader:i,baseAccount:s,quoteAccount:r,baseVault:t.baseVault,quoteVault:t.quoteVault,tokenProgram:F}}).keys]}({...e,additionalArgs:{logAuthority:t.findProgramAddressSync([Buffer.from("log")],ct)[0],market:this.address,baseVault:this.marketData.header.baseParams.vaultKey,quoteVault:this.marketData.header.quoteParams.vaultKey,baseMint:this.marketData.header.baseParams.mintKey}})}get reserveTokenMints(){return[this.marketData.header.baseParams.mintKey,this.marketData.header.quoteParams.mintKey]}}function _i(t,e,n){return Math.floor(t*e/n)}function $i(t,e){let n=t.coder.accounts.decode("tokenInfo",e),o=n.numTokens.toNumber(),i=[];for(let t=0;t<o;t++)i.push({id:t,mint:n.tokenMint[t].toBase58(),pdaAccount:n.pdaTokenAccount[t].toBase58(),pyth:n.pyth[t].toBase58(),decimals:n.decimals[t]});return i}class Hi{constructor(t,e,n){this.address=void 0,this.id=void 0,this.label="Symmetry",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.fundState=void 0,this.tokenInfos=void 0,this.curveData=void 0,this.pythPrices=[],this.address=t,this.id=t.toBase58(),this.fundState=oo.coder.accounts.decode("fundState",e.data),this.tokenInfos=$i(oo,Buffer.from(n.tokenInfoData,"base64"));for(let t=0;t<this.tokenInfos.length;t++)this.pythPrices.push({aggregate:{price:0}})}getAccountsForUpdate(){let e=[this.address,io,ao];for(let n=0;n<this.fundState.numOfTokens.toNumber();n++)e.push(new t(this.tokenInfos[this.fundState.currentCompToken[n].toNumber()].pyth));return e}update(t){const[e,n,o]=An(t,this.getAccountsForUpdate());this.tokenInfos=$i(oo,n.data),this.curveData=oo.coder.accounts.decode("prismData",o.data);let i=this.pythPrices;for(let e=0;e<this.fundState.numOfTokens.toNumber();e++){const n=this.fundState.currentCompToken[e].toNumber(),o=this.tokenInfos[n].pyth,a=t.get(o);if(!a)throw new Error(`Account info ${o} missing`);let s=Te(a.data);i[n]=s}this.fundState=oo.coder.accounts.decode("fundState",e.data),this.pythPrices=i}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(!this.curveData)throw new Error("Can't calculate quote without curve data");const o=function(t,e,n,o,i,a,s){let r=s,u=0,c=n.numOfTokens.toNumber(),m=t.findIndex((t=>t.mint===i.toBase58())),d=t.findIndex((t=>t.mint===a.toBase58())),p=-1,l=-1;for(let e=0;e<c;e++){let i=n.currentCompToken[e].toNumber(),a=n.currentCompAmount[e].toNumber();u+=o[i].aggregate.price*(a/10**t[i].decimals),i==m&&(p=e),i==d&&(l=e)}if(-1==p||-1==l||0==u)return;let h=n.weightSum.toNumber(),g=10**t[m].decimals,S=o[m].aggregate.price,k=.99999*S-o[m].confidence/2,f=10**t[d].decimals,y=o[d].aggregate.price,A=1.00001*y+o[d].confidence/2,M=s*k/g,w=n.targetWeight[p].toNumber()*u/n.weightSum.toNumber()*g/S,T=n.targetWeight[l].toNumber()*u/n.weightSum.toNumber()*f/y,P=M;0!=m&&(P=function(t,e,n,o,i,a){let s=0;s=t>e?e:t;let r=0,u=o,c=10**a,m=n,d=m,p=0;for(let e=0;e<10;e++){let n=Math.floor((9*i.price[e].toNumber()+m)/10);if(n<d&&(d=n),p+=i.amount[e].toNumber(),p<=t-s)continue;let o=Math.min(p-(t-s),i.amount[e].toNumber()),a=_i(o,d,c);if(o>u)return _i(u,d,c)+r;r+=a,u-=o}return r+=_i(u,d,c),r}(n.currentCompAmount[p].toNumber(),Math.floor(w),Math.floor(1e6*k),s,e.sell[m],t[m].decimals)/1e6);let v=P*f/A;0!=d&&(v=function(t,e,n,o,i,a){let s=0;s=t<e?e:t;let r=o,u=0,c=10**a,m=n,d=m,p=0;for(let e=0;e<10;e++){let n=Math.floor((9*i.price[e].toNumber()+m)/10);if(n>d&&(d=n),p+=i.amount[e].toNumber(),p<=s-t)continue;let o=Math.min(p-(s-t),i.amount[e].toNumber()),a=_i(o,d,c);if(a>r)return _i(r,c,d)+u;u+=o,r-=a}return u+=_i(r,c,d),u}(n.currentCompAmount[l].toNumber(),Math.floor(T),Math.floor(1e6*A),Math.floor(1e6*P),e.buy[d],t[d].decimals));let b=M*f/A,I=0;b>n.currentCompAmount[l].toNumber()&&(I=b-n.currentCompAmount[l].toNumber(),b=n.currentCompAmount[l].toNumber()),v>b&&(v=b);let B=b-v,F=B-Math.floor(5*B/100)-Math.floor(20*B/100)-Math.floor(20*B/100);u=u+M-(b-F)*y/f;let L=n.targetWeight[p].toNumber()/h,D=n.currentCompAmount[p].toNumber(),q=n.targetWeight[l].toNumber()/h,x=(n.currentCompAmount[l].toNumber()-(b-F))/f,E=n.rebalanceThreshold.toNumber()/1e4*(n.lpOffsetThreshold.toNumber()/1e4);if(x*y/u<q*(1-E)&&q*(1-E)>0)return;let O=(D+s)/g,C=n.rebalanceThreshold.toNumber()/1e4*(n.lpOffsetThreshold.toNumber()/1e4);if(O*S/u>L*(1+C)&&0!=m&&L*(1+C)<1)return;let R=B+I,V=b-F+R;return{inAmount:r,outAmount:Math.floor(v),feeMint:a,feeAmount:Math.ceil(R),priceImpact:R/V,feePct:R/V}}(this.tokenInfos,this.curveData,this.fundState,this.pythPrices,t,e,P.toNumber(n));if(!o)throw new Error("Can't calculate quote");return{notEnoughLiquidity:!1,inAmount:P.BigInt(o.inAmount),outAmount:P.BigInt(o.outAmount),feeAmount:P.BigInt(o.feeAmount),feeMint:o.feeMint.toBase58(),feePct:o.feePct,priceImpactPct:o.priceImpact}}getSwapLegAndAccounts(e){return function({additionalArgs:e,sourceMint:n,destinationMint:o,userSourceTokenAccount:i,userDestinationTokenAccount:a,userTransferAuthority:s}){let r=e.tokenInfos.findIndex((t=>t.mint===n.toBase58())),u=e.tokenInfos.findIndex((t=>t.mint===o.toBase58())),c=rt({walletAddress:so,tokenMintAddress:o}),m=rt({walletAddress:e.fundState.hostPubkey,tokenMintAddress:o}),d=rt({walletAddress:e.fundState.manager,tokenMintAddress:o}),p=[];for(let n=0;n<e.fundState.numOfTokens.toNumber();n++){let o=e.fundState.currentCompToken[n].toNumber();p.push({pubkey:new t(e.tokenInfos[o].pyth),isWritable:!1,isSigner:!1})}return[$n(Xn(new q(r),new q(u))),O.instruction.symmetrySwap({accounts:{swapProgram:E,buyer:s,fundState:e.fundAddress,pdaAccount:ro,pdaFromTokenAccount:e.tokenInfos[r].pdaAccount,buyerFromTokenAccount:i,pdaToTokenAccount:e.tokenInfos[u].pdaAccount,buyerToTokenAccount:a,swapFeeAccount:c,hostFeeAccount:m,managerFeeAccount:d,tokenInfo:io,prismData:ao,tokenProgram:F},remainingAccounts:[...p,uo]}).keys]}({additionalArgs:{fundAddress:this.address,tokenInfos:this.tokenInfos,fundState:this.fundState},...e})}get reserveTokenMints(){let e=[];for(let n=0;n<this.fundState.numOfTokens.toNumber();n++){let o=this.tokenInfos[this.fundState.currentCompToken[n].toNumber()].mint;e.push(new t(o))}return e}}const Zi=({amms:t,asLegacyTransaction:e,isSplit:n})=>{if(e){if(t.length>2)return!1;const[e,o]=t;return n?!Sn(ln,e.label,o.label):!Sn(hn,e.label,o.label)}return!0},Ji=new Map([[Mt.toString(),"Orca"],[wt.toString(),"Orca"],[yt.toString(),"Step"],[Tt.toString(),"Penguin"],[Pt.toString(),"Saros"],[vt.toString(),"Stepn"]]);function Gi(e,n,o){const i=new t(n.owner);if(i.equals(bt)||i.equals(It)||i.equals(ft)){const t=u.getLayout(i).decode(n.data);if(!t.accountFlags.initialized||!t.accountFlags.market)throw new Error("Invalid market");const e=new u(t,0,0,{},i);return new Li(e)}if(i.equals(dt))return new fi(e,n,o);if(i.equals(mt))return new di(e,n,o);if(i.equals(l)){const t=n.data.slice(2,3),o=h.loadWithData(e,n.data,Ln([e.toBuffer(),t],l));if(!o.state.isInitialized)return;return new Mi(o)}if(i.equals(V))return new Ai(e,n);if(i.equals(at))return new xo(e,n,o);if(i.equals(C)||i.equals(R))return new vo(e,n,o);if([...Ji.keys()].includes(i.toBase58())){var a;const t=null!==(a=Ji.get(n.owner.toBase58()))&&void 0!==a?a:"Unknown";return new Ei(e,n,t)}return i.equals(Bt)?new Eo(e,n,o):i.equals(Ft)?new Ti(e,n):i.equals(Lt)?new Ho(e,n):i.equals(N)?new Zo(e,n):i.equals(z)?new Ui(e,n):i.equals(U)?new Vo(e,n):i.equals(Q)?new ai(e,n):i.equals(_)?new Si(e,n,o):i.equals(H)?new Xo(e,n):i.equals(j)?new $o(e,n):i.equals(et)?new Ki(e,n,o):i.equals(tt)?new Do(e,n):i.equals(ut)?new zi(e,n):i.equals(gt)?new ji(e,n):i.equals(ct)?new Yi(e,n):i.equals(E)?new Hi(e,n,o):void 0}class ta{constructor(t,e){this.connection=void 0,this.ammIdToAddressLookupTable=void 0,this.ammIdToAddressLookupTableAccount=new Map,this.connection=t,this.ammIdToAddressLookupTable=e}async getAdressLookupTableAccounts(e){const n=new Map,o=[...e.reduce(((t,e)=>{const o=this.ammIdToAddressLookupTableAccount.get(e);if(o){const t=o.key.toBase58();n.has(t)||n.set(t,e)}else{const o=this.ammIdToAddressLookupTable.get(e);o&&(t.add(o),n.set(e,o))}return t}),new Set)];return(await fn(this.connection,o)).reduce(((e,i,s)=>{const r=o[s];if(i){const o=new a({key:new t(r),state:a.deserialize(i.data)});e.push(o);const s=n.get(r);s&&this.ammIdToAddressLookupTableAccount.set(s,o)}return e}),new Array)}}class ea{constructor(t){this.ammIdToAddressLookupTableAccount=void 0,this.ammIdToAddressLookupTableAccount=t}static async load(e,n){const o=[...n.entries()],i=await fn(e,o.map((([t,e])=>e))),s=new Map;for(const[e,n]of i.entries()){const[i,r]=o[e];n&&s.set(i,new a({key:new t(r),state:a.deserialize(n.data)}))}return new ea(s)}getAdressLookupTableAccounts(t){const e=new Set,n=t.reduce(((t,n)=>{const o=this.ammIdToAddressLookupTableAccount.get(n);if(o){const n=o.key.toBase58();e.has(n)||(t.push(o),e.add(n))}return t}),new Array);return Promise.resolve(n)}}async function na(t,e,n){const o=e.reduce(((t,e)=>{var n;const o=null==e||null===(n=e.params)||void 0===n?void 0:n.addressLookupTableAddress;return o&&t.set(e.pubkey,o),t}),new Map);return n?await ea.load(t,o):new ta(t,o)}const oa={};function ia(t){const e=t._bn.toString(),n=oa[e];if(n)return n;{const n=t.toBase58();return oa[e]=n,n}}function aa(t){const e=new Map;return t.forEach((t=>{Oi(t.reserveTokenMints).forEach((([n,o])=>{!function(t,e,n,o){let i=o.get(t);i||(i=new Map([[e,[]]]),o.set(t,i));let a=i.get(e);a||(a=[],i.set(e,a)),a.push(n)}(ia(n),ia(o),t,e)}))})),e}function sa(t,e,n){return Boolean(t&&e>100&&!t.has(n))}function ra(t){return t.marketInfos.map((t=>`${t.amm.id}-${t.inputMint}`)).join("-")}async function ua(e,i,a,s){const r=Dt(),u=a.address.toString();if(s){let t=s.get(u);if(t){let n=null;if(n=await e.getAccountInfo(t,"confirmed"),n)return{...r,address:t}}}const[c,m]=function(e,i,a){const[s]=t.findProgramAddressSync([Buffer.from("open_orders"),e.toBuffer(),a.toBuffer()],W);return[s,O.instruction.createOpenOrders({accounts:{openOrders:s,payer:a,dexProgram:i,systemProgram:n.programId,rent:o,market:e}})]}(a.address,a.programId,i);return await e.getAccountInfo(c)||(r.setupInstructions=[m]),null==s||s.set(a.address.toString(),c),{...r,address:c}}const ca={feeBps:0,feeAccounts:new Map};async function ma(t,e){return(await t.getTokenAccountsByOwner(e,{programId:F})).value.reduce(((t,e)=>{const n=b(e.account.data);return n&&t.set(n.mint.toBase58(),e.pubkey),t}),new Map)}const da=function(t){if(!Array.isArray(t))throw new TypeError(`Argument must be an array: ${t}`)},pa=function(t,e){return t*e.length},la={},ha=function(t,e){return String(e)};function ga(t){return null!=t}const Sa=P.BigInt(1e4);function ka({inputMint:t,outputMint:e}){return`${t}-${e}`}function fa({ammId:t,amount:e}){return`${t}-${e.toString()}`}function ya(t,e,n){return{ExactIn:P.greaterThanOrEqual(e.outAmount,t.outAmount)?1:-1,ExactOut:P.lessThanOrEqual(e.inAmount,t.inAmount)?1:-1}[n]}async function Aa({inputRouteSegment:e,inputMint:n,outputMint:o,amount:i,getDepositAndFeeForRoute:a,platformFeeBps:s,slippageBps:r,filterTopNResult:u=1,onlyDirectRoutes:c,swapMode:m,asLegacyTransaction:d}){const p=n.toBase58(),l=o.toBase58();if(!e.get(p))throw new Error("No routes found for the input and output mints");const h=c||m===yn.ExactOut?1:d?2:3,g=new Map,S=[],k=new Map;return function i({startMint:a,amount:s,level:r=1,walked:p=[a]}){const f=e.get(a);f&&f.forEach(((y,A)=>{const w=ka({inputMint:a,outputMint:A}),T=function({amms:e,inputMint:n,outputMint:o,amount:i,swapMode:a}){return e.map((e=>{try{return{quote:e.getQuote({amount:i,sourceMint:new t(n),destinationMint:new t(o),swapMode:a}),amm:e}}catch(t){return}})).filter(ga).sort(((t,e)=>ya(t.quote,e.quote,a)))}({amms:y,inputMint:a,outputMint:A,amount:s,swapMode:m}),{filteredAmms:v,quoteMap:b}=T.reduce(((t,e)=>(t.filteredAmms.length<u&&t.filteredAmms.push(e.amm),t.quoteMap.set(fa({ammId:e.amm.id,amount:s}),e.quote),t)),{filteredAmms:[],quoteMap:new Map});if(1===r&&A===l&&!c&&m===yn.ExactIn){let t=!1;!function(t,e){for(let n=0;n<t.length;n++)for(let o=n+1;o<t.length;o++)t[n].label!==t[o].label&&e(t[n],t[o])}(T.slice(0,Math.max(d?3:2,u)).map((({amm:t})=>t)),((e,i)=>{if(to&&t)return;const a=(()=>{if(Zi({amms:[e,i],asLegacyTransaction:d,isSplit:!0}))return Ri.create(e,i)})();a&&(t=!0,S.push({amms:[a],mints:[n,o]}))}))}if(f.set(A,v),g.set(w,b),A!==l&&b.size&&!p.includes(A)&&r<h){var I;const t=b.values().next().value.outAmount,e=null!==(I=k.get(A))&&void 0!==I?I:M;(Gn||P.greaterThan(t,e))&&(k.set(A,t),i({startMint:A,amount:t,level:r+1,walked:p.concat(A)}))}else if(A===l){1===r&&f.set(A,y);const n=p.concat(A),o=n.map((e=>new t(e))),i=n.reduce(((t,o,i)=>{var a;return i<n.length-1&&t.push(null===(a=e.get(n[i]))||void 0===a?void 0:a.get(n[i+1])),t}),[]),a=function(t){if(function(t){if(!Array.isArray(t))throw new TypeError("Argument must be an array of arrays");t.forEach(da),function({length:t}){if(t>=100)throw new TypeError(`Too many arrays (${t}): please use the 'big-cartesian' library instead of 'fast-cartesian'`)}(t),function(t){const e=t.reduce(pa,1);if(e>=4294967296){const t=Number.isFinite(e)?` (${e.toExponential(0)})`:"";throw new TypeError(`Too many combinations${t}: please use the 'big-cartesian' library instead of 'fast-cartesian'`)}}(t)}(t),0===t.length)return[];const e=[];return function(t){const e=la[t];if(void 0!==e)return e;const n=function(t){const e=Array.from({length:t},ha),n=e.map((t=>`for (const value${t} of arrays[${t}]) {`)).join("\n"),o=e.map((t=>`value${t}`)).join(", "),i="}\n".repeat(t);return new Function("arrays","result",`${n}\nresult.push([${o}])\n${i}`)}(t);return la[t]=n,n}(t.length)(t,e),e}(i);for(let t of a)(1===t.length||Zi({amms:t,asLegacyTransaction:d}))&&S.push({amms:t,mints:o})}}))}({startMint:p,amount:i}),S.map((t=>{const{amms:e,mints:n}=t;let o=[],u=i,c=M;const d=n,p=e.length;for(const[t,n]of e.entries())try{var l;const e=d[t],a=d[t+1],h=ka({inputMint:e.toBase58(),outputMint:a.toBase58()}),S=null===(l=g.get(h))||void 0===l?void 0:l.get(fa({ammId:n.id,amount:u}));if(P.equal(u,M))return;const k=S||n.getQuote({sourceMint:e,destinationMint:a,amount:u,swapMode:m}),f=Ma({quote:k,sourceMint:e,destinationMint:a,swapMode:m,legIndex:t,isLastLeg:p-1===t,platformFeeBps:s}),y=m===yn.ExactIn?k.outAmount:k.inAmount;let A=m===yn.ExactIn?P.subtract(y,f.amount):P.add(y,f.amount);P.lessThan(A,M)&&(A=M);const w=P.BigInt(m===yn.ExactIn?new te(A.toString()).mul(1-r/P.toNumber(Sa)).ceil():new te(A.toString()).mul(1+r/P.toNumber(Sa)).floor()),[T,v]=m===yn.ExactIn?[k.inAmount,A]:[A,u];o.push({amm:n,inputMint:e,outputMint:a,notEnoughLiquidity:k.notEnoughLiquidity,minInAmount:k.minInAmount,minOutAmount:k.minOutAmount,inAmount:T,outAmount:v,priceImpactPct:k.priceImpactPct,lpFee:{amount:k.feeAmount,mint:k.feeMint,pct:k.feePct},platformFee:f}),u=m===yn.ExactIn?A:i,c=w}catch(t){return}return{marketInfos:o,getDepositAndFee:()=>a({marketInfos:o}),inAmount:o[0].inAmount,outAmount:u,amount:i,otherAmountThreshold:c,swapMode:m,slippageBps:r,priceImpactPct:1-o.reduce(((t,e)=>t*(1-e.priceImpactPct)),1)}})).filter(ga).sort(((t,e)=>ya(t,e,m)))}function Ma({quote:t,sourceMint:e,destinationMint:n,swapMode:o,legIndex:i,isLastLeg:a,platformFeeBps:s}){return a&&o===yn.ExactIn?{amount:P.divide(P.multiply(t.outAmount,P.BigInt(s)),Sa),mint:n.toBase58(),pct:s/100}:0===i&&o===yn.ExactOut?{amount:P.divide(P.multiply(t.inAmount,P.BigInt(s)),Sa),mint:e.toBase58(),pct:s/100}:{amount:M,mint:n.toBase58(),pct:0}}class wa{constructor(t,e,n,o,i,a,u=0,c=!0,m,d,p){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.intermediateTokens=void 0,this.shouldLoadSerumOpenOrders=void 0,this.addressLookupTableProvider=void 0,this.serumOpenOrdersPromise=void 0,this.user=void 0,this.routeCache=new Map,this.routeSegmentCache=new r({max:500}),this.getDepositAndFees=async({marketInfos:t,userPublicKey:e,serumOpenOrdersPromise:n=Promise.resolve(new Map)})=>(async({connection:t,owner:e,inputMint:n,marketInfos:o,feeCalculator:i,serumOpenOrdersPromise:a,wrapUnwrapSOL:s})=>{const r=await Promise.all(o.map((async n=>{const o=n.amm;if(o instanceof Li||o instanceof Ri){if(!o.market)return;return await ua(t,e.publicKey,o.market,await a)}}))),{userIntermediaryTokenAccountResults:u,userDestinationTokenAccountResult:c}=await qt({connection:t,outputMints:o.map((t=>t.outputMint)),owner:e,unwrapSOL:s}),m=!!s&&[n,...o.map((t=>t.outputMint))].some((t=>t.equals(xt)));return Et({intermediates:u,destination:c,openOrders:r,hasWrapUnwrapSOL:m,feeCalculator:i})})({connection:this.connection,feeCalculator:this.feeCalculator,inputMint:t[0].inputMint,marketInfos:t,serumOpenOrdersPromise:n,owner:new Ot(e),wrapUnwrapSOL:this.wrapUnwrapSOL}),this.getDepositAndFeesForUser=({marketInfos:t})=>{if(this.user&&this.serumOpenOrdersPromise){const e=new Ot(this.user);return this.getDepositAndFees({marketInfos:t,userPublicKey:e.publicKey,serumOpenOrdersPromise:this.serumOpenOrdersPromise})}return Promise.resolve(void 0)},this.exchange=async({routeInfo:t,userPublicKey:e,feeAccount:n,wrapUnwrapSOL:o,blockhashWithExpiryBlockHeight:i,asLegacyTransaction:a,computeUnitPriceMicroLamports:r})=>{var u;const{connection:c,serumOpenOrdersPromise:m}=this,d=e||this.user;if(!d)throw new Error("user not found");const p=new Ot(d),l=t.marketInfos.length-1,h=t.marketInfos[0].inputMint,g=t.marketInfos[l].outputMint,S=null!=o?o:this.wrapUnwrapSOL,[k,f,y]=await Promise.all([h.equals(xt)&&S?Ct({connection:c,owner:p,amount:t.swapMode===yn.ExactIn?t.amount:t.otherAmountThreshold}):{...Dt(),address:rt({tokenMintAddress:h,walletAddress:p.publicKey})},qt({connection:c,outputMints:t.marketInfos.map((t=>t.outputMint)),owner:p,unwrapSOL:S}),Promise.all(t.marketInfos.map((async({amm:t})=>{if(t instanceof Li||t instanceof Ri){if(!t.market)return;return await ua(c,p.publicKey,t.market,await m)}})))]),A={intermediates:f.userIntermediaryTokenAccountResults,destination:f.userDestinationTokenAccountResult,openOrders:y},M=A.openOrders.filter(Boolean).length>0,w=(n=null!==(u=n)&&void 0!==u?u:this.platformFeeAndAccounts.feeAccounts.get(t.swapMode===yn.ExactIn?g.toBase58():h.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*t.marketInfos[l].platformFee.pct),feeAccount:n}:void 0,{instruction:T}=await async function({user:t,openOrdersAddresses:e,userSourceTokenAccountAddress:n,userIntermediateTokenAccountAddresses:o,userDestinationTokenAccountAddress:i,routeInfo:a,platformFee:r,computeUnitPriceMicroLamports:u,quoteMintToReferrer:c}){if(a.marketInfos.length-1!==o.length)throw new Error("Missing intermediary token account address");const m=[n,...o,i],d=!!r&&r.feeBps>0,p=t.publicKey,l=[s.setComputeUnitLimit({units:14e5})];u&&u>0&&l.push(s.setComputeUnitPrice({microLamports:u}));const h=[];if(a.swapMode===yn.ExactIn){const t=function(t,e,n,o,i,a,s,r){const u=[],c=[];for(const[e,o]of t.marketInfos.entries()){const r=o.amm,[m,d]=i.slice(e),[p,l]=r.getSwapLegAndAccounts({sourceMint:o.inputMint,destinationMint:o.outputMint,userSourceTokenAccount:m,userDestinationTokenAccount:d,userTransferAuthority:n,openOrdersAddress:a[e],quoteMintToReferrer:s,swapMode:t.swapMode,amount:o.inAmount});u.push(p),c.push(...l)}return e&&r&&c.push({pubkey:r.feeAccount,isWritable:!0,isSigner:!1}),{swapInstruction:co(n,o,Yn(u),c,new x(t.amount.toString()),new x(t.outAmount.toString()),t.slippageBps,e&&r?r.feeBps:0)}}(a,d,p,i,m,e,c,r),{swapInstruction:n}=t;h.push(n)}else if(a.swapMode===yn.ExactOut){const{swapInstruction:t}=function(t,e,n,o,i,a){const s=t.marketInfos[0],r=s.amm;if(r.createExactOutSwapInstruction)return{swapInstruction:r.createExactOutSwapInstruction({sourceMint:s.inputMint,destinationMint:s.outputMint,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:e,quoteMintToReferrer:i,swapMode:t.swapMode,amount:t.amount,slippageBps:t.slippageBps,inAmount:t.inAmount,platformFee:a,overflowFeeAccount:null==i?void 0:i.get(s.inputMint.toBase58())})};throw new Error(`ExactOutInstruction missing for ${r.label}.`)}(a,p,n,i,c,r);h.push(t)}const{signers:g,cleanupInstructions:S}=Dt();return t.isKeyPair&&t.signer&&g.push(t.signer),{instruction:{setupInstructions:l,signers:g,cleanupInstructions:S,instructions:h}}}({user:p,openOrdersAddresses:A.openOrders.map((t=>null==t?void 0:t.address)),userSourceTokenAccountAddress:k.address,userIntermediateTokenAccountAddresses:A.intermediates.map((({address:t})=>t)),userDestinationTokenAccountAddress:A.destination.address,routeInfo:t,platformFee:w,computeUnitPriceMicroLamports:r,quoteMintToReferrer:this.quoteMintToReferrer,asLegacyTransaction:a}),P=new Rt(c,p.publicKey,p),v=[...A.intermediates,k,!A.destination.address.equals(k.address)&&A.destination];P.addInstruction(T),M&&A.openOrders.forEach((t=>{t&&P.addInstruction(t)})),v.forEach((t=>{t&&P.addInstruction(t)})),i=i||await this.connection.getLatestBlockhash("confirmed");const b=await this.addressLookupTableProvider.getAdressLookupTableAccounts(t.marketInfos.map((({amm:t})=>t instanceof Ri?[t.firstAmm.id,t.secondAmm.id]:t.id)).flat()),{transaction:I}=await P.build(i,b,a),B=A;return{swapTransaction:I,addressLookupTableAccounts:b,execute:({wallet:t,onTransaction:e}={})=>Vt({connection:this.connection,wallet:t,onTransaction:e,inputMint:h,outputMint:g,sourceAddress:k.address,destinationAddress:B.destination.address,swapTransaction:I,owner:p,wrapUnwrapSOL:S}).finally((()=>{this.routeCache.clear()}))}},this.connection=t,this.cluster=e,this.tokenRouteSegments=n,this.feeCalculator=o,this.platformFeeAndAccounts=i,this.quoteMintToReferrer=a,this.routeCacheDuration=u,this.wrapUnwrapSOL=c,this.intermediateTokens=m,this.shouldLoadSerumOpenOrders=d,this.addressLookupTableProvider=p}static async load({connection:e,cluster:n,user:o,platformFeeAndAccounts:i=ca,quoteMintToReferrer:a,routeCacheDuration:s=0,wrapUnwrapSOL:r=!0,marketsCache:u,restrictIntermediateTokens:c=!1,shouldLoadSerumOpenOrders:m=!1,ammsToExclude:d={GooseFX:!0,Serum:!0},mintsToExclude:p=[],usePreloadedAddressLookupTableCache:l=!1}){const[{tokenRouteSegments:h,addressLookupTableProvider:g,saberWrapperMints:S},{value:{feeCalculator:k}},f]=await Promise.all([wa.loadCoreData({connection:e,cluster:n,marketsCache:u,ammsToExclude:d,mintsToExclude:p,usePreloadedAddressLookupTableCache:l}),e.getRecentBlockhashAndContext("processed"),null!=a?a:ma(e,new t(At))]),y=!0===c?await wa.getIntermediateTokens(S):c?c.intermediateTokens:void 0,A=new wa(e,n,h,k,i,f,s,r,y?new Set(y):void 0,m,g);return o&&A.setUserPublicKey(o),A}static async loadCoreData({connection:t,cluster:e,marketsCache:n,ammsToExclude:o,mintsToExclude:i,usePreloadedAddressLookupTableCache:a}){let s;s=!n||"url"in n?await(async t=>await(await dn(t)).json())((null==n?void 0:n.url)||Ut[e]):n;const{amms:r,saberWrapperMints:u,addressLookupTableProvider:c}=await wa.fetchAmms(t,s,o,i,a);return{tokenRouteSegments:aa(r),addressLookupTableProvider:c,saberWrapperMints:u}}getAccountToAmmIdsMap(){const t=new Map;return this.tokenRouteSegments.forEach((e=>{Array.from(e.values()).forEach((e=>{e.forEach((e=>{e.getAccountsForUpdate().forEach((n=>{const o=t.get(n.toBase58())||new Set;o.add(e.id),t.set(n.toBase58(),o)}))}))}))})),t}getAmmIdToAmmMap(){const t=new Map;return this.tokenRouteSegments.forEach((e=>{Array.from(e.values()).forEach((e=>{e.forEach((e=>{t.set(e.id,e)}))}))})),t}async computeRoutes({inputMint:t,outputMint:e,amount:n,slippageBps:o,feeBps:i=0,forceFetch:a,onlyDirectRoutes:s,swapMode:r=yn.ExactIn,filterTopNResult:u,asLegacyTransaction:c}){const m=t.toBase58(),d=e.toBase58(),p=i||(this.platformFeeAndAccounts.feeAccounts.get(d)?this.platformFeeAndAccounts.feeBps:0),l=(new Date).getTime(),h=[m,d].sort(((t,e)=>t.localeCompare(e))).join()+s+r+c,g=this.routeCache.get(h);let S=this.routeSegmentCache.get(h);S||(S=function({inputMint:t,outputMint:e,tokenRouteSegments:n,swapMode:o,intermediateTokens:i,onlyDirectRoutes:a,asLegacyTransaction:s}){const r=new Map,u=n.get(t),c=n.get(e);if(u&&c){const m=Math.min(u.size,c.size),d=new Map,p=new Map,[l,h,g,S]=[u,c,t,e];for(let[t,e]of l.entries()){if(e=o===yn.ExactIn?e.slice():e.filter((t=>t.exactOutputSupported)),t===S){const t=e;d.set(S,t),p.set(g,t);continue}if(a||o===yn.ExactOut||sa(i,m,t))continue;let u=n.get(t)||new Map;for(let[n,o]of u){if(o=o.slice(),n===S){const n=o,i=r.get(t)||new Map;if(i.set(g,e),i.set(S,n),r.set(t,i),d.set(t,e),p.set(t,n),s)break}if(!s){if(sa(i,m,n))continue;const a=h.get(n);if(a){d.set(t,e);const i=r.get(t)||new Map;i.set(n,o),r.set(t,i);const s=r.get(n)||new Map;s.set(t,o),r.set(n,s);const u=r.get(n)||new Map;u.set(S,a),r.set(n,u),p.set(n,a)}}}}r.set(g,d),r.set(S,p)}return r}({inputMint:m,outputMint:d,tokenRouteSegments:this.tokenRouteSegments,intermediateTokens:this.intermediateTokens,onlyDirectRoutes:s,swapMode:r,asLegacyTransaction:c}),this.routeSegmentCache.set(h,S));let k=!1;if(-1===this.routeCacheDuration)k=!1;else if(0===this.routeCacheDuration)k=!0;else if(g){const{fetchTimestamp:t}=g;l-t>this.routeCacheDuration&&(k=!0)}else k=!0;(a||k)&&(await async function(t,e){const n=new Map,o=new Set,i=new Map;e.forEach((t=>{t.forEach((t=>{t.forEach((t=>{i.set(t.id,t),t.getAccountsForUpdate().forEach((t=>{o.add(t.toBase58())}))}))}))}));const a=Array.from(o);a.length>0&&((await fn(t,a)).forEach(((t,e)=>{t&&n.set(a[e],t)})),i.forEach((t=>{t.update(n)})))}(this.connection,S),this.routeCache.set(h,{fetchTimestamp:(new Date).getTime()}));try{return{routesInfos:await Aa({inputRouteSegment:S,inputMint:t,outputMint:e,amount:n,getDepositAndFeeForRoute:this.getDepositAndFeesForUser,onlyDirectRoutes:s,slippageBps:o,platformFeeBps:p,filterTopNResult:u,swapMode:r,asLegacyTransaction:c}),cached:!(a||k)}}catch(t){throw t}finally{this.routeCache.forEach((({fetchTimestamp:t},e)=>{t-l>this.routeCacheDuration&&this.routeCache.delete(e)}))}}setUserPublicKey(t){this.user=t;const e=new Ot(this.user);this.serumOpenOrdersPromise=this.shouldLoadSerumOpenOrders?wa.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:e.publicKey}):Promise.resolve(new Map)}static async fetchAmms(e,n,o,i,a=!1){return async function({connection:e,marketsCache:n,usePreloadedAddressLookupTableCache:o,ammsToExclude:i={},mintsToExclude:a=[]}){const s=(e=>e.map((e=>{const{data:[n,o],pubkey:i,...a}=e;return{...a,pubkey:new t(i),data:Buffer.from(n,o),owner:new t(a.owner)}})))(n);if(Jn){const t=[];if(t.length){const n=await async function(t,e){return await Promise.all((await fn(t,e.map((t=>t.toBase58())))).map((async(t,n)=>{const o=e[n];if(!t)throw new Error(`Failed to fetch pool ${o.toBase58()}`);return{pubkey:o,...t}})))}(e,t);s.push(...n)}}const r=[],u=[],c=s.map((t=>t.pubkey.toBase58())),m=await fn(e,c),d=new Set(a.map((t=>t.toBase58()))),p=s.filter(((t,e)=>m[e])).reduce(((t,e)=>{try{const n=Gi(e.pubkey,e,e.params);if(n){if(Sn(i,n.label))return t;if(a&&a.length&&n.reserveTokenMints.some((t=>d.has(t.toBase58()))))return t;t.push(n),n.shouldPrefetch&&r.push(n),n instanceof Ai&&u.push(n.wrapperMint.toBase58())}}catch(t){}return t}),new Array),[l,h,g]=await Promise.all([Tn(r,e),Fe(),await na(e,n,o)]);return{amms:p,saberWrapperMints:u,addressLookupTableProvider:g}}({connection:e,marketsCache:n,ammsToExclude:o,mintsToExclude:i,usePreloadedAddressLookupTableCache:a})}getRouteMap(t,e){return function(t,e,n,o){const i=new Map,a=new Set(t.keys());a.forEach((t=>{i.set(t,new Set)}));for(const[S,k]of t){const f=new Set(a);for(let t of k.keys()){var s,r;null===(s=i.get(S))||void 0===s||s.add(t),null===(r=i.get(t))||void 0===r||r.add(S),f.delete(t)}if(!n)for(let a of f){var u;let s=null===(u=i.get(S))||void 0===u?void 0:u.has(a);if(s)continue;const r=t.get(S),k=t.get(a);if(r&&k){const u=Math.min(r.size,k.size);let[f,y,A,M]=[r,k,S,a];for(let[r,k]of f.entries()){if(n||sa(e,u,r))continue;let f=t.get(r)||new Map;for(let[t,n]of f){if(t===M){if(!o){var c,m;null===(c=i.get(S))||void 0===c||c.add(a),null===(m=i.get(a))||void 0===m||m.add(S),s=!0;break}for(let t of k){for(let e of n)if(Zi({amms:[t,e],asLegacyTransaction:o})){var d,p;null===(d=i.get(S))||void 0===d||d.add(a),null===(p=i.get(a))||void 0===p||p.add(S),s=!0;break}if(s)break}}if(!o){var l;if(sa(e,u,t))continue;if(null===(l=y.get(t))||void 0===l?void 0:l.slice()){var h,g;null===(h=i.get(S))||void 0===h||h.add(a),null===(g=i.get(a))||void 0===g||g.add(S),s=!0;break}}}if(s)break}}}}return Array.from(i.entries()).reduce(((t,[e,n])=>(t.set(e,[...n]),t)),new Map)}(this.tokenRouteSegments,this.intermediateTokens,t,e)}static async getIntermediateTokens(t){const e=await async function(){const t=await(await dn("https://cache.jup.ag/top-tokens")).json();return new Set(t.filter(((t,e)=>e<60)))}();for(const t of Zn)e.add(t);return t.forEach((t=>e.add(t))),Array.from(e)}}wa.getRemoteRouteMap=Nt,wa.findSerumOpenOrdersForOwner=async({userPublicKey:t,cluster:e,connection:n})=>{const o=new Map;if(t){const i="mainnet-beta"===e?bt:It;(await c.findForOwner(n,t,i)).forEach((t=>{o.set(t.market.toString(),t.address)}))}return o};export{vo as AldrinAmm,Do as BalansolAmm,xo as CremaAmm,Eo as CropperAmm,Vo as CykuraAmm,Ko as DeltaFiAmm,Ki as DradexAmm,no as FAKE_PROVIDER,Xo as GooseFXAmm,Jn as IS_DEV,to as IS_PROD,Gn as IS_TEST,$o as InvariantAmm,wa as Jupiter,Ho as LifinityAmm,Zo as LifinityV2Amm,eo as MIN_SEGMENT_SIZE_FOR_INTERMEDIATE_MINTS,ji as MarcoPoloAmm,ai as MarinadeAmm,di as MercurialAmm,Si as MeteoraAmm,Yi as PhoenixAmm,fi as RaydiumAmm,zi as RaydiumClmm,Zn as SWAP_PROTOCOL_TOKENS,Ai as SaberAddDecimalsAmm,Mi as SaberAmm,Ti as SenchaAmm,Li as SerumAmm,Ei as SplTokenSwapAmm,Ri as SplitTradeAmm,yn as SwapMode,Hi as SymmetryAmm,Ui as WhirlpoolAmm,Gi as ammFactory,ma as getPlatformFeeAccounts,ra as getRouteInfoUniqueId};
//# sourceMappingURL=core.esm.min.js.map
