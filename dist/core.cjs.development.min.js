"use strict";

Object.defineProperty(exports, "__esModule", { value: !0 });


var e = require("@solana/web3.js"),
    t = require("lru-cache"),
    n = require("@project-serum/serum"),
    o = require("@saberhq/stableswap-sdk"),
    i = require("@jup-ag/math"),
    a = require("jsbi"),
    s = require("fzstd"),
    r = require("@mercurial-finance/optimist"),
    u = require("@solana/spl-token"),
    c = require("bn.js"),
    m = require("@jup-ag/common"),
    d = require("@solana/buffer-layout"),
    l = require("@noble/hashes/sha256"),
    p = require("@coral-xyz/anchor"),
    h = require("decimal.js"),
    g = require("@jup-ag/crema-sdk-v2"),
    A = require("@jup-ag/cykura-sdk"),
    f = require("@jup-ag/cykura-sdk-core"),
    S = require("@jup-ag/deltafi-sdk"),
    k = require("@pythnetwork/client"),
    y = require("bignumber.js"),
    M = require("@jup-ag/goosefx-ssl-sdk"),
    w = require("@jup-ag/invariant"),
    P = require("@jup-ag/lifinity-sdk"),
    T = require("@jup-ag/lifinity-sdk-v2"),
    I = require("@mercurial-finance/dynamic-amm-sdk"),
    b = require("@jup-ag/whirlpools-sdk"),
    v = require("@jup-ag/dradex-sdk"),
    R = require("@jup-ag/dradex-idl"),
    B = require("@jup-ag/raydium-clmm-sdk"),
    O = require("@jup-ag/phoenix-sdk"),
    D = require("cross-fetch");


function E(e) { return e && "object" == typeof e && "default" in e ? e : { default: e } }

function F(e) {
    if (e && e.__esModule) return e;

    var t = Object.create(null);

    return e && Object.keys(e).forEach(
        (
            function (n) {
                if ("default" !== n) {
                    var o = Object.getOwnPropertyDescriptor(e, n);

                    Object.defineProperty(
                        t, n, o.get ? o : { enumerable: !0, get: function () { return e[n] } }
                    )
                }
            }
        )
    ), t.default = e, t
}

var L = E(t), _ = E(a), q = F(s), x = E(c), C = E(h), N = E(D);


const K = { Raydium: { Openbook: !0 } }, 
    U = { 
        Symmetry: !0, 
        Openbook: !0, 
        Cykura: !0, 
        Meteora: { Lifinity: !0, "Lifinity V2": !0, Balansol: !0, Crema: !0, Dradex: !0, Raydium: !0, BonkSwap: !0, Oasis: !0 }, 
        Crema: { Balansol: !0, Raydium: !0, Lifinity: !0, "Lifinity V2": !0 }, 
        BonkSwap: { Lifinity: !0, "Lifinity V2": !0, Balansol: !0, Crema: !0, Dradex: !0, Raydium: !0, Oasis: !0 }, 
        Oasis: { Lifinity: !0, "Lifinity V2": !0, Balansol: !0, Crema: !0, Dradex: !0, Raydium: !0, BonkSwap: !0 }, 
        Dradex: { Lifinity: !0, "Lifinity V2": !0, Balansol: !0, Crema: !0, Raydium: !0 }, Balansol: { Raydium: !0 }, 
        Lifinity: { Raydium: !0 }, "Lifinity V2": { Raydium: !0 } 
    }, 
    V = { 
        Symmetry: !0, 
        Raydium: !0, 
        GooseFX: !0, 
        Meteora: !0, 
        Serum: !0, 
        Openbook: !0, 
        Dradex: !0, 
        Crema: !0, 
        Lifinity: !0, "Lifinity V2": !0 
    }, 
    G = (e, t, n) => {
        const o = e[t];

        if (o) {
            if (!0 === o || !0 === o["*"]) return !0;

            if (n) return !0 === o[n]
        } return !1
    }, 
    Y = (e, t, n) => G(e, t, n) || !!n && G(e, n, t);

function W(e, t) { 
    return Array.apply(0, new Array(Math.ceil(e.length / t))).map(((n, o) => e.slice(o * t, (o + 1) * t))) 
} 

async function z(t, n, o = 1e3, i = 100) {
    return (
        await Promise.all(
            W(n, o).map(
                (
                    async n => {
                        const o = W(n, i).map(
                            (
                                e => (
                                    { 
                                        methodName: "getMultipleAccounts", 
                                        args: t._buildArgs(
                                            [e], 
                                            t.commitment, 
                                            "base64+zstd"
                                        ) 
                                    }
                                )
                            )
                        );

                        return t._rpcBatchRequest(o).then(
                            (
                                t => t.reduce(
                                    (
                                        (t, n) => (
                                            n.result.value.forEach(
                                                (
                                                    n => {
                                                        if (n) {
                                                            const o = n;

                                                            o.data = Buffer.from(q.decompress(Buffer.from(n.data[0], "base64"))), o.owner = new e.PublicKey(n.owner), t.push(o)
                                                        } else t.push(null)
                                                    }
                                                )
                                            )
                                            , t
                                        )
                                    ), 
                                    []
                                )
                            )
                        ).catch((e => n.map((() => null))))
                    }
                )
            )
        )
    ).flat()
} 

var X;

exports.SwapMode = void 0, (X = exports.SwapMode || (exports.SwapMode = {})).ExactIn = "ExactIn", X.ExactOut = "ExactOut";

const j = (e, t) => t.map((t => {
        const n = e.get(t.toString());

        if (!n) throw new Error(`Account info ${t.toBase58()} missing`);

        return n
    })), 

    Q = e => e.map(
        (
            e => {
                const t = r.deserializeAccount(e.data);

                if (!t) throw new Error("Invalid token account");

                return t
            }
        )
    ).map((e => _.default.BigInt(e.amount))), 

    J = "Missing tokenReserveAmounts", 

    $ = async (e, t) => {
        const n = e.map((e => e.getAccountsForUpdate().map((e => e.toBase58())))).flat(), 
            o = new Map;

        (
            await z(t, n)).forEach(((e, t) => { e && o.set(n[t], e) })
        );

        for (let t of e) t.update(o)
    };


class Z extends d.Layout {
    constructor(e) {
        const t = d.blob(32);

        super(t.span, e), this.layout = void 0, this.layout = t
    }
    getSpan(e, t) {
        return this.layout.getSpan(e, t)
    }
    decode(t, n) {
        return new e.PublicKey(this.layout.decode(t, n))
    }

    encode(e, t, n) {
        return this.layout.encode(e.toBuffer(), t, n)
    }
}


const H = e => new Z(e);


class ee extends d.Layout {
    constructor(e = 8, t) {
        const n = d.blob(e);

        super(n.span, t), this.layout = void 0, this.layout = n
    }

    getSpan(e, t) { return this.layout.getSpan(e, t) }

    decode(e, t) { return new u.u64(this.layout.decode(e, t), 10, "le") }

    encode(e, t, n) { return this.layout.encode(e.toArrayLike(Buffer, "le", this.layout.span), t, n) }

}

const te = e => new ee(8, e), 
ne = e => new ee(16, e), 
oe = e => Buffer.isBuffer(e) ? e : e instanceof Uint8Array ? Buffer.from(e.buffer, e.byteOffset, e.byteLength) : Buffer.from(e);


function ie(t, n) {
    let o = Buffer.alloc(0);

    t.forEach(
        (
            function (t) {
                if (t.length > e.MAX_SEED_LENGTH) throw new TypeError("Max seed length exceeded");

                o = Buffer.concat([o, oe(t)])
            }
        )
    ),
        o = Buffer.concat([o, n.toBuffer(), Buffer.from("ProgramDerivedAddress")]);

    let i = l.sha256(new Uint8Array(o)), a = new x.default(i, 16).toArray(void 0, 32);

    return new e.PublicKey(a)
}


const ae =
    d.struct(
        [
            d.u8("version"),
            d.u8("isInitialized"),
            d.u8("nonce"),
            H("ammId"),
            H("serumProgramId"),
            H("serumMarket"),
            H("tokenProgramId"),
            H("tokenAAccount"),
            H("tokenBAccount"),
            H("poolMint"),
            H("mintA"),
            H("mintB")
        ]
    ),

    se = d.struct(
        [
            d.u8("isInitialized"), 
            H("stateOwner"), H("feeOwner"), 
            te("initialSupply"), te("returnFeeNumerator"), 
            te("fixedFeeNumerator"), te("feeDenominator"), d.u8("curveType"), 
            d.blob(32, "curveParameters")]
    ),

    re = new e.PublicKey("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),

    ue = (e, t) => {
        const n = t.owner,
            o = ae.decode(t.data);

        return {
            programId: n,
            authority: ie([e.toBuffer(), Buffer.from([o.nonce])], n),
            version: o.version,
            isInitialized: Boolean(o.isInitialized),
            nonce: o.nonce,
            ammId: o.ammId,
            serumProgramId: o.serumProgramId,
            tokenProgramId: o.tokenProgramId,
            tokenAAccount: o.tokenAAccount,
            tokenBAccount: o.tokenBAccount,
            serumMarket: o.serumMarket,
            poolMint: o.poolMint,
            mintA: o.mintA,
            mintB: o.mintB
        }
    },

    ce = {
        Bid: { bid: {} },
        Ask: { ask: {} }
    },
    me = e => ({ serum: { side: e } }),
    de = e => ({ crema: { aToB: e } }),
    le = e => ({ aldrin: { side: e } }),
    pe = e => ({ aldrinV2: { side: e } }),
    he = e => ({ whirlpool: { aToB: e } }),
    ge = e => ({ invariant: { xToY: e } }),
    Ae = e => ({ dradex: { side: e } }),
    fe = e => ({ marcoPolo: { xToY: e } }),
    Se = e => ({ openbook: { side: e } }),
    ke = e => ({ phoenix: { side: e } }),
    ye = (e, t) => ({ symmetry: { fromTokenId: e, toTokenId: t } }),
    Me = e => ({ chain: { swapLegs: e } }),
    we = e => ({ split: { splitLegs: e } }),
    Pe = e => ({ swap: { swap: e } }),
    Te = (e, t) => ({ percent: e, swapLeg: t }),
    Ie = ["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT", "DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],
    be = new p.AnchorProvider(null, null, { skipPreflight: !1 }),
    ve = new p.Program(
        {}
        ,
        m.SYMMETRY_PROGRAM_ID,
        be
    ),

    Re = new e.PublicKey("4Rn7pKKyiSNKZXKCoLqEpRznX1rhveV4dW1DCg6hRoVH"),
    Be = new e.PublicKey("4QMjSHuM3iS7Fdfi8kZJfHRKoEJSDHEtEwqbChsTcUVK"),
    Oe = new e.PublicKey("AWfpfzA6FYbqx4JLz75PDgsjH7jtBnnmJ6MXW5zNY2Ei"),
    De = new e.PublicKey("BLBYiq48WcLQ5SxiftyKmPtmsZPUBEnDEjqEnKGAR4zx"),
    Ee = { pubkey: m.JUPITER_PROGRAM_ID, isSigner: !1, isWritable: !1 };




function Fe(e, t, n, o, i, a, s, r) {
    return m.JUPITER_PROGRAM.instruction.route(
        n, i, a, s, r, 
        { 
            accounts: { 
                tokenProgram: u.TOKEN_PROGRAM_ID, 
                userTransferAuthority: e, 
                destinationTokenAccount: t 
            }, 
            remainingAccounts: o 
        }
    )
}


function Le(e, t, n, o) {
    return { 
        swapProgram: m.MERCURIAL_SWAP_PROGRAM_ID, 
        swapState: e.ammId, 
        tokenProgram: u.TOKEN_PROGRAM_ID, 
        poolAuthority: e.authority, 
        userTransferAuthority: o, 
        sourceTokenAccount: t, 
        destinationTokenAccount: n 
    }
}

const [_e] = e.PublicKey.findProgramAddressSync(
    [new Uint8Array(Buffer.from("amm authority".replace("Â ", " "), "utf-8"))], 
    m.RAYDIUM_AMM_V4_PROGRAM_ID
);



function qe(e, t, n, o) {
    if (!e.serumMarketKeys) throw new Error("RaydiumAmm is missing serumMarketKeys");

    return { 
        swapProgram: m.RAYDIUM_AMM_V4_PROGRAM_ID, 
        tokenProgram: u.TOKEN_PROGRAM_ID, 
        ammId: e.ammId, 
        ammAuthority: _e, 
        ammOpenOrders: e.ammOpenOrders, 
        poolCoinTokenAccount: e.poolCoinTokenAccount, 
        poolPcTokenAccount: e.poolPcTokenAccount, 
        serumProgramId: e.serumProgramId, 
        serumMarket: e.serumMarket, 
        serumBids: e.serumMarketKeys.serumBids, 
        serumAsks: e.serumMarketKeys.serumAsks, 
        serumEventQueue: e.serumMarketKeys.serumEventQueue, 
        serumCoinVaultAccount: e.serumMarketKeys.serumCoinVaultAccount, 
        serumPcVaultAccount: e.serumMarketKeys.serumPcVaultAccount, 
        serumVaultSigner: e.serumMarketKeys.serumVaultSigner, 
        userSourceTokenAccount: t, 
        userDestinationTokenAccount: n, 
        userSourceOwner: o 
    }
} 

function xe(t, n, o, i, a, s) {
    const r = e.PublicKey.createProgramAddressSync(
        [
            t.address.toBuffer(),
            t.decoded.vaultSignerNonce.toArrayLike(Buffer, "le", 8),
        ],
        t.programId
    );

    return {
        market: {
            market: t.address,
            openOrders: n,
            requestQueue: t.decoded.requestQueue,
            eventQueue: t.decoded.eventQueue,
            bids: t.bidsAddress,
            asks: t.asksAddress,
            coinVault: t.decoded.baseVault,
            pcVault: t.decoded.quoteVault,
            vaultSigner: r,
        },
        authority: s,
        orderPayerTokenAccount: o,
        coinWallet: i,
        pcWallet: a,
        dexProgram: t.programId,
        tokenProgram: u.TOKEN_PROGRAM_ID,
        rent: e.SYSVAR_RENT_PUBKEY,
    };
}


function Ce(e, t, n, o, i) {
    const a = t.equals(e.state.tokenA.mint)
            ? e.state.tokenB.adminFeeAccount
            : e.state.tokenA.adminFeeAccount,
        [s, r] = t.equals(e.state.tokenA.mint)
            ? [e.state.tokenA.reserve, e.state.tokenB.reserve]
            : [e.state.tokenB.reserve, e.state.tokenA.reserve];

    return {
        swapProgram: e.config.swapProgramID,
        tokenProgram: u.TOKEN_PROGRAM_ID,
        swap: e.config.swapAccount,
        swapAuthority: e.config.authority,
        userAuthority: i,
        inputUserAccount: n,
        inputTokenAccount: s,
        outputUserAccount: o,
        outputTokenAccount: r,
        feesTokenAccount: a,
    };
}


function Ne(e, t) {
    const n = [];

    return (
        n.push(
            e
                ? { pubkey: e, isSigner: !1, isWritable: !0 }
                : t
                ? { pubkey: t, isSigner: !1, isWritable: !0 }
                : Ee
        ),
        n
    );
}


const Ke = new u.u64(0);


class Ue {
    constructor(e, t) {
        (this.numerator = void 0),
            (this.denominator = void 0),
            (this.toString = () =>
                `${this.numerator.toString()}/${this.denominator.toString()}`),
            (this.numerator = e),
            (this.denominator = t);
    }
    static fromDecimal(e) {
        return Ue.fromFraction(e.toDecimalPlaces(1).mul(10).toNumber(), 1e3);
    }
    static fromFraction(e, t) {
        const n = "number" == typeof e ? new u.u64(e.toString()) : e,
            o = "number" == typeof t ? new u.u64(t.toString()) : t;

        return new Ue(n, o);
    }
    toDecimal() {
        return this.denominator.eq(Ke)
            ? new C.default(0)
            : new C.default(this.numerator.toString()).div(
                    new C.default(this.denominator.toString())
                );
    }
    add(e) {
        const t = this.denominator.gcd(e.denominator),
            n = this.denominator.div(t).mul(e.denominator),
            o = n.div(this.denominator),
            i = n.div(e.denominator),
            a = this.numerator.mul(o),
            s = e.numerator.mul(i),
            r = a.add(s);

        return new Ue(new u.u64(r.toString()), new u.u64(n.toString()));
    }
}
  
const Ve = d.struct(
    [
        te("tradeFeeNumerator"),
        te("tradeFeeDenominator"),
        te("ownerTradeFeeNumerator"),
        te("ownerTradeFeeDenominator"),
        te("ownerWithdrawFeeNumerator"),
        te("ownerWithdrawFeeDenominator"),
    ],
    "fees"
),
Ge = [
    d.blob(8, "padding"),
    H("lpTokenFreezeVault"),
    H("poolMint"),
    H("baseTokenVault"),
    H("baseTokenMint"),
    H("quoteTokenVault"),
    H("quoteTokenMint"),
    H("poolSigner"),
    d.u8("poolSignerNonce"),
    H("authority"),
    H("initializerAccount"),
    H("feeBaseAccount"),
    H("feeQuoteAccount"),
    H("feePoolTokenAccount"),
    Ve,
],
Ye = d.struct(Ge),
We = d.struct([...Ge, d.u8("curveType"), H("curve")]),
ze = d.struct([d.blob(8, "padding"), te("amp")]);


function Xe(e, t) {
    const n = !!t.owner.equals(m.ALDRIN_SWAP_V2_PROGRAM_ID),
        o = (n ? We : Ye).decode(t.data),
        i = "curveType" in o ? { curveType: o.curveType, curve: o.curve } : {};

    return {
        isV2: n,
        address: e,
        poolMint: o.poolMint,
        baseTokenVault: o.baseTokenVault,
        baseTokenMint: o.baseTokenMint,
        quoteTokenVault: o.quoteTokenVault,
        quoteTokenMint: o.quoteTokenMint,
        poolSigner: o.poolSigner,
        feeBaseAccount: o.feeBaseAccount,
        feeQuoteAccount: o.feeQuoteAccount,
        feePoolTokenAccount: o.feePoolTokenAccount,
        fees: {
            traderFee: Ue.fromFraction(
                o.fees.tradeFeeNumerator,
                o.fees.tradeFeeDenominator
            ),
            ownerFee: Ue.fromFraction(
                o.fees.ownerTradeFeeNumerator,
                o.fees.ownerTradeFeeDenominator
            ),
        },
        ...i,
    };
}


class AldrinAmm {
    constructor(e, t, n) {
        if (
            ((this.params = void 0),
            (this.id = void 0),
            (this.label = "Aldrin"),
            (this.shouldPrefetch = !1),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !1),
            (this.poolState = void 0),
            (this.tokenReserveAmounts = void 0),
            (this.calculator = void 0),
            (this.params = n),
            (this.poolState = Xe(e, t)),
            (this.id = e.toBase58()),
            1 === this.poolState.curveType)
        ) {
            const { amp: e } = this.params;

            if (!e) throw new Error("Amp is required for a stable curve");

            this.calculator = new i.TokenSwapStable(
                _.default.BigInt(e),
                new i.Fraction(
                    _.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),
                    _.default.BigInt(this.poolState.fees.traderFee.denominator.toString())
                ),
                new i.Fraction(
                    _.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),
                    _.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())
                )
            );
        } else
            this.calculator = new i.TokenSwapConstantProduct(
                new i.Fraction(
                    _.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),
                    _.default.BigInt(this.poolState.fees.traderFee.denominator.toString())
                ),
                new i.Fraction(
                    _.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),
                    _.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())
                )
            );
    }
    static decodeStableCurveAmp(e) {
        const { amp: t } = ze.decode(e.data);

        return 2 * t.toNumber();
    }
    getAccountsForUpdate() {
        return [this.poolState.quoteTokenVault, this.poolState.baseTokenVault];
    }
    update(e) {
        const t = j(e, this.getAccountsForUpdate());

        this.tokenReserveAmounts = Q(t);
    }
    getQuote({ sourceMint: e, amount: t }) {
        if (!this.tokenReserveAmounts) throw new Error(J);

        let n = new C.default(this.poolState.fees.traderFee.numerator.toString())
            .div(this.poolState.fees.traderFee.denominator.toString())
            .add(
                new C.default(this.poolState.fees.ownerFee.numerator.toString()).div(
                    this.poolState.fees.ownerFee.denominator.toString()
                )
            );

        const o = this.poolState.baseTokenMint.equals(e) ? 0 : 1;

        let i = this.calculator.exchange(this.tokenReserveAmounts, t, o);

        return {
            notEnoughLiquidity: !1,
            inAmount: t,
            outAmount: i.expectedOutputAmount,
            feeAmount: i.fees,
            feeMint: e.toBase58(),
            feePct: n.toNumber(),
            priceImpactPct: i.priceImpact.toNumber(),
        };
    }
    getSwapLegAndAccounts(e) {
        if (this.poolState.isV2) {
            if (!this.poolState.curve)
                throw new Error("Unable to fetch curve account.");

            return (function ({
                poolState: e,
                sourceMint: t,
                userSourceTokenAccount: n,
                userDestinationTokenAccount: o,
                curve: i,
                userTransferAuthority: a,
            }) {
                const [s, r, c] = t.equals(e.baseTokenMint)
                    ? [ce.Ask, n, o]
                    : [ce.Bid, o, n];

                return [
                    Pe(pe(s)),
                    m.JUPITER_PROGRAM.instruction.aldrinV2Swap({
                        accounts: {
                            swapProgram: m.ALDRIN_SWAP_V2_PROGRAM_ID,
                            pool: e.address,
                            poolSigner: e.poolSigner,
                            poolMint: e.poolMint,
                            baseTokenVault: e.baseTokenVault,
                            quoteTokenVault: e.quoteTokenVault,
                            feePoolTokenAccount: e.feePoolTokenAccount,
                            walletAuthority: a,
                            userBaseTokenAccount: r,
                            userQuoteTokenAccount: c,
                            curve: i,
                            tokenProgram: u.TOKEN_PROGRAM_ID,
                        },
                    }).keys,
                ];
            })({ poolState: this.poolState, curve: this.poolState.curve, ...e });
        }
        return (function ({
            poolState: e,
            sourceMint: t,
            userSourceTokenAccount: n,
            userDestinationTokenAccount: o,
            userTransferAuthority: i,
        }) {
            const [a, s, r] = t.equals(e.baseTokenMint)
                ? [ce.Ask, n, o]
                : [ce.Bid, o, n];

            return [
                Pe(le(a)),
                m.JUPITER_PROGRAM.instruction.aldrinSwap({
                    accounts: {
                        swapProgram: m.ALDRIN_SWAP_PROGRAM_ID,
                        pool: e.address,
                        poolSigner: e.poolSigner,
                        poolMint: e.poolMint,
                        baseTokenVault: e.baseTokenVault,
                        quoteTokenVault: e.quoteTokenVault,
                        feePoolTokenAccount: e.feePoolTokenAccount,
                        walletAuthority: i,
                        userBaseTokenAccount: s,
                        userQuoteTokenAccount: r,
                        tokenProgram: u.TOKEN_PROGRAM_ID,
                    },
                }).keys,
            ];
        })({ poolState: this.poolState, ...e });
    }
    get reserveTokenMints() {
        return [this.poolState.quoteTokenMint, this.poolState.baseTokenMint];
    }
}

je.accountInfoToAldrinPoolState = Xe;


const Qe = {
    version: "0.1.0",
    name: "balancer_amm",
    instructions: [
        {
            name: "swap",
            accounts: [
                { name: "authority", isMut: !0, isSigner: !0 },
                { name: "pool", isMut: !0, isSigner: !1 },
                { name: "taxMan", isMut: !0, isSigner: !1 },
                { name: "bidMint", isMut: !1, isSigner: !1 },
                { name: "treasurer", isMut: !1, isSigner: !1 },
                { name: "srcTreasury", isMut: !0, isSigner: !1 },
                { name: "srcAssociatedTokenAccount", isMut: !0, isSigner: !1 },
                { name: "askMint", isMut: !1, isSigner: !1 },
                { name: "dstTreasury", isMut: !0, isSigner: !1 },
                { name: "dstAssociatedTokenAccount", isMut: !0, isSigner: !1 },
                { name: "dstTokenAccountTaxman", isMut: !0, isSigner: !1 },
                { name: "systemProgram", isMut: !1, isSigner: !1 },
                { name: "tokenProgram", isMut: !1, isSigner: !1 },
                { name: "associatedTokenProgram", isMut: !1, isSigner: !1 },
                { name: "rent", isMut: !1, isSigner: !1 },
            ],
            args: [
                { name: "bidAmount", type: "u64" },
                { name: "limit", type: "u64" },
            ],
            returns: "u64",
        },
    ],
    accounts: [
        {
            name: "pool",
            type: {
                kind: "struct",
                fields: [
                    { name: "authority", type: "publicKey" },
                    { name: "fee", type: "u64" },
                    { name: "taxFee", type: "u64" },
                    { name: "state", type: { defined: "PoolState" } },
                    { name: "mintLpt", type: "publicKey" },
                    { name: "taxMan", type: "publicKey" },
                    { name: "mints", type: { vec: "publicKey" } },
                    { name: "actions", type: { vec: { defined: "MintActionState" } } },
                    { name: "treasuries", type: { vec: "publicKey" } },
                    { name: "reserves", type: { vec: "u64" } },
                    { name: "weights", type: { vec: "u64" } },
                ],
            },
        },
    ],
    types: [
        {
            name: "PoolState",
            type: {
                kind: "enum",
                variants: [
                    { name: "Uninitialized" },
                    { name: "Initialized" },
                    { name: "Frozen" },
                    { name: "Deleted" },
                ],
            },
        },
        {
            name: "MintActionState",
            type: {
                kind: "enum",
                variants: [
                    { name: "Active" },
                    { name: "BidOnly" },
                    { name: "AskOnly" },
                    { name: "Paused" },
                ],
            },
        },
    ],
    errors: [],
},
Je = 10 ** 9,
$e = (e, t) => {
    const n = e.map((e) => e.toNumber() / Je);

    return t.toNumber() / Je / n.reduce((e, t) => e + t, 0);
},
Ze = (e, t) => {
    const {
            balanceIn: n,
            balanceOut: o,
            weightIn: i,
            weightOut: a,
            swapFee: s,
        } = t,
        r = Number(n.toString()),
        u = Number(o.toString()),
        c = i,
        m = a,
        d = Number(s.toString()) / Je;

    return (
        (-r * m) / (u * (-1 + d) * (r / (e + r - e * d)) ** ((c + m) / m) * c)
    );
},
He = new p.BorshAccountsCoder(Qe);


class BalansolAmm {
    constructor(e, t) {
        (this.address = void 0),
            (this.label = "Balansol"),
            (this.id = void 0),
            (this.shouldPrefetch = !0),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !1),
            (this.poolData = void 0),
            (this.address = e),
            (this.id = e.toBase58()),
            (this.poolData = He.decode("pool", t.data));
    }
    getAccountsForUpdate() {
        return [new e.PublicKey(this.id)];
    }
    update(e) {
        let [t] = j(e, this.getAccountsForUpdate());

        const n = He.decode("pool", t.data);

        this.poolData = n;
    }
    getQuote({ sourceMint: e, destinationMint: t, amount: n }) {
        var o, i;

        if (!this.poolData)
            throw new Error(`Invalid pool data ${this.address.toBase58()}`);

        if (!this.poolData.state.initialized)
            throw new Error(`Pool is not initialized ${this.address.toBase58()}`);

        const a = this.poolData.mints.map((e) => e.toBase58()),
            s = a.indexOf(e.toBase58()),
            r = a.indexOf(t.toBase58());

        if (null === (o = this.poolData.actions[s]) || void 0 === o || !o.active)
            throw new Error(`Invalid bid mint state ${this.address.toBase58()}`);

        if (null === (i = this.poolData.actions[r]) || void 0 === i || !i.active)
            throw new Error(`Invalid ask mint state ${this.address.toBase58()}`);

        const u = $e(this.poolData.weights, this.poolData.weights[s]),
            c = $e(this.poolData.weights, this.poolData.weights[r]),
            m = ((e, t, n, o, i, a) => {
                const s = Number(t.toString()),
                    r = Number(n.toString());

                return (
                    s * (1 - (r / (r + e)) ** (i / o)) * (1 - Number(a.toString()) / Je)
                );
            })(
                Number(n.toString()),
                this.poolData.reserves[r],
                this.poolData.reserves[s],
                c,
                u,
                this.poolData.fee.add(this.poolData.taxFee)
            ),
            d = ((e, t) => {
                const n = Ze(0, t),
                    o = Ze(e, t);

                return o < n ? 0 : 1 - n / o;
            })(Number(n.toString()), {
                balanceIn: this.poolData.reserves[s],
                balanceOut: this.poolData.reserves[r],
                weightIn: u,
                weightOut: c,
                swapFee: this.poolData.fee.add(this.poolData.taxFee),
            }),
            l = this.poolData.fee.add(this.poolData.taxFee).toNumber() / 10 ** 9,
            p = (m / (1 - l)) * l;

        return {
            notEnoughLiquidity: !1,
            inAmount: n,
            outAmount: _.default.BigInt(Math.floor(m)),
            feeAmount: _.default.BigInt(Math.floor(p)),
            feeMint: t.toBase58(),
            feePct: 0,
            priceImpactPct: d,
        };
    }
    getSwapLegAndAccounts(t) {
        var n;

        if (!this.poolData)
            throw new Error(`Invalid pool data ${this.address.toBase58()}`);

        const o = this.poolData.mints.findIndex((e) => e.equals(t.sourceMint)),
            i = this.poolData.mints.findIndex((e) => e.equals(t.destinationMint)),
            [a] = e.PublicKey.findProgramAddressSync(
                [Buffer.from("treasurer"), this.address.toBuffer()],
                m.BALANSOL_PROGRAM_ID
            ),
            s = m.findAssociatedTokenAddress({
                tokenMintAddress: t.destinationMint,
                walletAddress: this.poolData.taxMan,
            });

        return (function ({
            additionalArgs: t,
            userSourceTokenAccount: n,
            userDestinationTokenAccount: o,
            userTransferAuthority: i,
            sourceMint: a,
            destinationMint: s,
        }) {
            return [
                Pe({ balansol: {} }),
                m.JUPITER_PROGRAM.instruction.balansolSwap({
                    accounts: {
                        swapProgram: m.BALANSOL_PROGRAM_ID,
                        authority: i,
                        pool: t.pool,
                        taxMan: t.taxMan,
                        bidMint: a,
                        treasurer: t.treasurer,
                        srcTreasury: t.srcTreasury,
                        srcAssociatedTokenAccount: n,
                        askMint: s,
                        dstTreasury: t.dstTreasury,
                        dstAssociatedTokenAccount: o,
                        dstTokenAccountTaxman: t.dstTokenAccountTaxman,
                        systemProgram: e.SystemProgram.programId,
                        tokenProgram: u.TOKEN_PROGRAM_ID,
                        associatedTokenProgram: u.ASSOCIATED_TOKEN_PROGRAM_ID,
                        rent: e.SYSVAR_RENT_PUBKEY,
                    },
                    remainingAccounts: t.referrer
                        ? [{ pubkey: t.referrer, isSigner: !1, isWritable: !0 }]
                        : [Ee],
                }).keys,
            ];
        })({
            ...t,
            additionalArgs: {
                pool: this.address,
                taxMan: this.poolData.taxMan,
                dstTokenAccountTaxman: s,
                treasurer: a,
                srcTreasury: this.poolData.treasuries[o],
                dstTreasury: this.poolData.treasuries[i],
                referrer:
                    null === (n = t.quoteMintToReferrer) || void 0 === n
                        ? void 0
                        : n.get(t.destinationMint.toBase58()),
            },
        });
    }
    get reserveTokenMints() {
        return this.poolData.mints;
    }
}

et.getIDL = () => Qe;

const tt = new p.BorshCoder(g.IDL);

class CremaAmm {
    constructor(e, t, n) {
        (this.address = void 0),
            (this.id = void 0),
            (this.label = "Crema"),
            (this.shouldPrefetch = !0),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !0),
            (this.clmmpoolData = void 0),
            (this.reserveTokenDecimals = void 0),
            (this.tickArrayMapPubkey = void 0),
            (this.feeRate = void 0),
            (this.tickArrayMap = void 0),
            (this.tickArrayPubkeys = []),
            (this.tickArrays = []),
            (this.arrayStartIndex = void 0),
            (this.swapTicks = void 0),
            (this.address = e),
            (this.id = e.toBase58()),
            (this.clmmpoolData = tt.accounts.decode("clmmpool", t.data)),
            (this.feeRate = this.clmmpoolData.feeRate),
            (this.tickArrayMapPubkey = g.PDAUtil.getTickArrayMapPDA(
                m.CREMA_PROGRAM_ID,
                e
            ).publicKey),
            (this.reserveTokenDecimals = [n.decimalA, n.decimalB]),
            (this.arrayStartIndex = 0);
    }
    getAccountsForUpdate() {
        return [this.address, this.tickArrayMapPubkey, ...this.tickArrayPubkeys];
    }
    update(e) {
        const t = e.get(this.address.toBase58());

        if (!t) throw new Error(`Missing poolData ${this.address.toBase58()}`);

        (this.clmmpoolData = tt.accounts.decode("clmmpool", t.data)),
            (this.feeRate = this.clmmpoolData.feeRate);

        const n = e.get(this.tickArrayMapPubkey.toBase58());

        if (!n)
            throw new Error(
                `Missing tickArrayMap ${this.tickArrayMapPubkey.toBase58()}`
            );

        const o = tt.accounts.decode("tickArrayMap", n.data);

        (this.tickArrayPubkeys = this.getTickArrayPubkeys(this.address, o)),
            (this.tickArrayMap = o);

        const i = g.TickUtil.getArrayIndex(
            this.clmmpoolData.currentTickIndex,
            this.clmmpoolData.tickSpacing
        );

        let a = !1;

        const s = [];

        for (let t = 0; t < this.tickArrayPubkeys.length; t++) {
            const n = e.get(this.tickArrayPubkeys[t].toBase58());

            if (n) {
                const e = tt.accounts.decode("tickArray", n.data);

                !1 === a && e.arrayIndex >= i && ((a = !0), (this.arrayStartIndex = t)),
                    s.push({ address: this.tickArrayPubkeys[t], data: e });
            }
        }
        this.tickArrays = s;

        const r = { aToB: [], bToA: [] };

        for (let e = this.arrayStartIndex; e > this.arrayStartIndex - 3; e--) {
            let t = this.tickArrays[e];

            t && r.aToB.push(t);
        }
        for (let e = this.arrayStartIndex; e < this.arrayStartIndex + 3; e++) {
            let t = this.tickArrays[e];

            t && r.bToA.push(t);
        }
        (this.swapTicks = { aToB: [], bToA: [] }),
            [r.aToB, r.bToA].forEach((e, t) => {
                for (let n = 0; n < e.length; n++) {
                    const o = e[n];

                    if (0 === t)
                        for (let e = g.TICK_ARRAY_SIZE - 1; e >= 0; e--)
                            o.data &&
                                o.data.ticks[e].isInitialized &&
                                this.swapTicks.aToB.push(o.data.ticks[e]);
                    else
                        for (let e = 0; e < g.TICK_ARRAY_SIZE; e++)
                            o.data &&
                                o.data.ticks[e].isInitialized &&
                                this.swapTicks.bToA.push(o.data.ticks[e]);
                }
            });
    }
    getTickArrayPubkeys(e, t) {
        let n = [];

        for (let e = 0; e < 868; e++) {
            let o = t.bitmap[e];

            for (let e = 0; e < 8; e++) n.push(((o >> e) & 1) > 0);
        }
        const o = [];

        for (let t = 0; t < n.length; t++)
            if (n[t]) {
                const n = g.PDAUtil.getTickArrayPDA(m.CREMA_PROGRAM_ID, e, t).publicKey;

                o.push(n);
            }
        return o;
    }
    getQuote(e) {
        let t, n, o;

        if (!this.swapTicks) throw new Error("swapTicks is not initialized");

        "ExactIn" === e.swapMode
            ? ((t = e.destinationMint), (o = !0))
            : ((t = e.sourceMint), (o = !1)),
            (n = !!e.sourceMint.equals(this.reserveTokenMints[0]));

        const i = new c.BN(e.amount.toString()),
            a = g.computeSwap(
                n,
                o,
                i,
                this.clmmpoolData,
                this.swapTicks[n ? "aToB" : "bToA"]
            ),
            s = g.TickMath.sqrtPriceX64ToPrice(
                this.clmmpoolData.currentSqrtPrice,
                this.reserveTokenDecimals[0],
                this.reserveTokenDecimals[1]
            ).toNumber(),
            r = g.TickMath.sqrtPriceX64ToPrice(
                a.nextSqrtPrice,
                this.reserveTokenDecimals[0],
                this.reserveTokenDecimals[1]
            ).toNumber();

        let u = !1;

        if (((u = o ? a.amountIn.lt(i) : a.amountOut.lt(i)), u))
            throw new Error("not enough liquidity");

        return {
            notEnoughLiquidity: u,
            inAmount: _.default.BigInt(a.amountIn),
            outAmount: _.default.BigInt(a.amountOut),
            feeMint: t.toString(),
            feeAmount: _.default.multiply(
                _.default.BigInt(e.amount),
                _.default.BigInt(this.feeRate)
            ),
            feePct: this.feeRate,
            priceImpactPct: Math.abs(s - r) / s,
        };
    }
    getSwapLegAndAccounts(e) {
        let t, n;

        if (!this.swapTicks) throw new Error("swapTicks is not initialized");

        const o = g.PDAUtil.getClmmConfigPDA(m.CREMA_PROGRAM_ID).publicKey;

        if (
            ((t = !!e.sourceMint.equals(this.reserveTokenMints[0])),
            (n = "ExactIn" === e.swapMode),
            !this.tickArrayMap)
        )
            throw new Error("tickArrayMap is not initialized");

        const i = new c.BN(e.amount.toString()),
            a = g.computeSwap(
                t,
                n,
                i,
                this.clmmpoolData,
                this.swapTicks[t ? "aToB" : "bToA"],
                this.address,
                this.tickArrayMap
            );

        return (function ({
            additionalArgs: e,
            userSourceTokenAccount: t,
            userDestinationTokenAccount: n,
            userTransferAuthority: o,
            sourceMint: i,
        }) {
            const {
                aToB: a,
                accountA: s,
                accountB: r,
            } = i.equals(e.tokenA)
                ? { aToB: !0, accountA: t, accountB: n }
                : { aToB: !1, accountA: n, accountB: t };

            let c = [];

            return (
                e.remainingAccounts.forEach((e) => {
                    c.push({ pubkey: e, isSigner: !1, isWritable: !0 });
                }),
                c.push(Ee),
                [
                    Pe(de(a)),
                    m.JUPITER_PROGRAM.instruction.cremaSwap({
                        accounts: {
                            swapProgram: m.CREMA_PROGRAM_ID,
                            clmmConfig: e.clmmConfig,
                            clmmpool: e.clmmpool,
                            tokenA: e.tokenA,
                            tokenB: e.tokenB,
                            accountA: s,
                            accountB: r,
                            tokenAVault: e.tokenAVault,
                            tokenBVault: e.tokenBVault,
                            tickArrayMap: e.tickArrayMap,
                            owner: o,
                            partner: m.CREMA_PARTNER_ACCOUNT,
                            partnerAtaA: m.findAssociatedTokenAddress({
                                walletAddress: m.CREMA_PARTNER_ACCOUNT,
                                tokenMintAddress: e.tokenA,
                            }),
                            partnerAtaB: m.findAssociatedTokenAddress({
                                walletAddress: m.CREMA_PARTNER_ACCOUNT,
                                tokenMintAddress: e.tokenB,
                            }),
                            tokenProgram: u.TOKEN_PROGRAM_ID,
                        },
                        remainingAccounts: c,
                    }).keys,
                ]
            );
        })({
            additionalArgs: {
                clmmConfig: o,
                clmmpool: this.address,
                tokenA: this.clmmpoolData.tokenA,
                tokenB: this.clmmpoolData.tokenB,
                tokenAVault: this.clmmpoolData.tokenAVault,
                tokenBVault: this.clmmpoolData.tokenBVault,
                tickArrayMap: this.tickArrayMapPubkey,
                remainingAccounts: a.swapTickArrays,
            },
            ...e,
        });
    }
    get reserveTokenMints() {
        return [this.clmmpoolData.tokenA, this.clmmpoolData.tokenB];
    }
}


class ot {
    static async getStateFromStateAccount(e) {
        const t = await e.getAccountInfo(re);

        if (!t) throw new Error("State account not found");

        return ((e) => {
            const t = se.decode(e.data);

            return {
                isInitialized: Boolean(t.isInitialized),
                stateOwner: t.stateOwner,
                feeOwner: t.feeOwner,
                initialSupply: t.initialSupply,
                returnFeeNumerator: t.returnFeeNumerator.toNumber(),
                fixedFeeNumerator: t.fixedFeeNumerator.toNumber(),
                feeDenominator: t.feeDenominator.toNumber(),
                curveType: t.curveType,
                curveParameters: t.curveParameters,
            };
        })(t);
    }
    constructor(t, n, o) {
        (this.id = void 0),
            (this.label = "Cropper"),
            (this.shouldPrefetch = !1),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !1),
            (this.poolState = void 0),
            (this.tokenReserveAmounts = void 0),
            (this.calculator = void 0),
            (this.feePct = void 0),
            (this.params = void 0),
            (this.id = t.toBase58()),
            (this.poolState = ue(t, n)),
            (this.params = {
                ...o,
                tokenAFeeAccount: new e.PublicKey(o.tokenAFeeAccount),
                tokenBFeeAccount: new e.PublicKey(o.tokenBFeeAccount),
            }),
            (this.feePct = new C.default(this.params.fixedFeeNumerator)
                .add(new C.default(this.params.returnFeeNumerator))
                .div(this.params.feeDenominator)),
            (this.calculator = new i.TokenSwapConstantProduct(
                new i.Fraction(
                    _.default.BigInt(this.params.fixedFeeNumerator),
                    _.default.BigInt(this.params.feeDenominator)
                ),
                new i.Fraction(
                    _.default.BigInt(this.params.returnFeeNumerator),
                    _.default.BigInt(this.params.feeDenominator)
                )
            ));
    }
    getAccountsForUpdate() {
        return [this.poolState.tokenAAccount, this.poolState.tokenBAccount];
    }
    update(e) {
        const t = j(e, this.getAccountsForUpdate());

        this.tokenReserveAmounts = Q(t);
    }
    getQuote({ sourceMint: e, amount: t }) {
        if (!this.tokenReserveAmounts) throw new Error(J);

        const n = this.poolState.mintA.equals(e) ? 1 : 0,
            o = this.calculator.exchange(this.tokenReserveAmounts, t, n);

        return {
            notEnoughLiquidity: !1,
            inAmount: t,
            outAmount: o.expectedOutputAmount,
            feeAmount: o.fees,
            feeMint: e.toBase58(),
            feePct: this.feePct.toNumber(),
            priceImpactPct: o.priceImpact.toNumber(),
        };
    }
    getSwapLegAndAccounts(e) {
        const t = e.sourceMint.equals(this.poolState.mintA)
            ? this.params.tokenAFeeAccount
            : this.params.tokenBFeeAccount;

        return (function ({
            poolState: e,
            feeAccount: t,
            sourceMint: n,
            userSourceTokenAccount: o,
            userDestinationTokenAccount: i,
            userTransferAuthority: a,
        }) {
            const [s, r] = n.equals(e.mintA)
                ? [e.tokenAAccount, e.tokenBAccount]
                : [e.tokenBAccount, e.tokenAAccount];

            return [
                Pe({ cropper: {} }),
                m.JUPITER_PROGRAM.instruction.cropperSwap({
                    accounts: {
                        tokenSwapProgram: e.programId,
                        tokenProgram: u.TOKEN_PROGRAM_ID,
                        swap: e.ammId,
                        swapState: re,
                        authority: e.authority,
                        userTransferAuthority: a,
                        source: o,
                        swapSource: s,
                        swapDestination: r,
                        destination: i,
                        poolMint: e.poolMint,
                        poolFee: t,
                    },
                }).keys,
            ];
        })({ poolState: this.poolState, feeAccount: t, ...e });
    }
    get reserveTokenMints() {
        return [this.poolState.mintA, this.poolState.mintB];
    }
}

ot.decodePoolState = ue;
class it {
    constructor(e, t) {
        (this.program = void 0),
            (this.pool = void 0),
            (this.bitmapCache = void 0),
            (this.tickCache = void 0),
            (this.accountsToFetch = { bitmaps: [], ticks: [] }),
            (this.program = e),
            (this.pool = t),
            (this.bitmapCache = new Map()),
            (this.tickCache = new Map());
    }
    async eagerLoadCache(e, t) {
        const n = _.default.toNumber(
                _.default.divide(_.default.BigInt(e), _.default.BigInt(t))
            ),
            { wordPos: o } = A.tickPosition(n);

        try {
            const e = [],
                { wordPos: n } = A.tickPosition(Math.floor(A.TickMath.MIN_TICK / t)),
                { wordPos: a } = A.tickPosition(Math.floor(A.TickMath.MAX_TICK / t)),
                s = Math.max(o - 10, n),
                r = Math.min(o + 10, a);

            for (let t = s; t < r; t++) e.push(this.getBitmapAddressSync(t));

            const u = await this.program.account.tickBitmapState.fetchMultiple(e),
                c = [];

            for (let n = 0; n < r - s; n++) {
                var i;

                const o = n + s,
                    a = null === (i = u[n]) || void 0 === i ? void 0 : i.word,
                    r = a ? A.generateBitmapWord(a) : new p.BN(0);

                if (
                    (this.bitmapCache.set(o, { address: e[n], word: r }), r && !r.eqn(0))
                )
                    for (let e = 0; e < 256; e++)
                        if (r.shrn(e).and(new p.BN(1)).eqn(1)) {
                            const n = this.getTickAddressSync(((o << 8) + e) * t);

                            c.push(n);
                        }
            }
            const m = await this.program.account.tickState.fetchMultiple(c);

            for (const e in c) {
                const t = m[e];

                if (!t) continue;

                const { tick: n, liquidityNet: o } = t;

                this.tickCache.set(n, {
                    address: c[e],
                    liquidityNet: _.default.BigInt(o),
                });
            }
        } catch (e) {}
    }
    lazyLoadAccountsToCache(e, t) {
        const n = _.default.toNumber(
                _.default.divide(_.default.BigInt(e), _.default.BigInt(t))
            ),
            { wordPos: o } = A.tickPosition(n),
            i = [],
            a = [],
            { wordPos: s } = A.tickPosition(Math.floor(A.TickMath.MIN_TICK / t)),
            { wordPos: r } = A.tickPosition(Math.floor(A.TickMath.MAX_TICK / t)),
            u = Math.max(o - 10, s),
            c = Math.min(o + 10, r);

        for (let e = u; e < c; e++) {
            i.push(this.getBitmapAddressSync(e));

            const t = this.bitmapCache.get(e);

            a.push(t);
        }
        const m = [];

        for (let e = 0; e < c - u; e++) {
            var d, l;

            const n = e + u,
                o =
                    null !==
                        (d = null === (l = a[e]) || void 0 === l ? void 0 : l.word) &&
                    void 0 !== d
                        ? d
                        : new p.BN(0);

            if ((this.bitmapCache.set(n, { address: i[e], word: o }), o && !o.eqn(0)))
                for (let e = 0; e < 256; e++)
                    if (o.shrn(e).and(new p.BN(1)).eqn(1)) {
                        const o = this.getTickAddressSync(((n << 8) + e) * t);

                        m.push(o);
                    }
        }
        return (this.accountsToFetch = { bitmaps: i, ticks: m }), [...i, ...m];
    }
    getTick(e) {
        let t = this.tickCache.get(e);

        if (!t) throw new Error("Tick not cached");

        return { address: t.address, liquidityNet: t.liquidityNet };
    }
    async getTickAddress(e) {
        return this.getTickAddressSync(e);
    }
    getTickAddressSync(t) {
        return e.PublicKey.findProgramAddressSync(
            [
                A.TICK_SEED,
                this.pool.token0.toBuffer(),
                this.pool.token1.toBuffer(),
                A.u32ToSeed(this.pool.fee),
                A.u32ToSeed(t),
            ],
            this.program.programId
        )[0];
    }
    async getBitmapAddress(e) {
        return this.getBitmapAddressSync(e);
    }
    getBitmapAddressSync(t) {
        return e.PublicKey.findProgramAddressSync(
            [
                A.BITMAP_SEED,
                this.pool.token0.toBuffer(),
                this.pool.token1.toBuffer(),
                A.u32ToSeed(this.pool.fee),
                A.u16ToSeed(t),
            ],
            this.program.programId
        )[0];
    }
    getBitmap(e) {
        let t = this.bitmapCache.get(e);

        if (!t) throw new Error("Bitmap not cached");

        return t;
    }
    nextInitializedTickWithinOneWord(e, t, n) {
        let o = _.default.toNumber(
            _.default.divide(_.default.BigInt(e), _.default.BigInt(n))
        );

        e < 0 && e % n != 0 && (o -= 1), t || (o += 1);

        const { wordPos: i, bitPos: a } = A.tickPosition(o),
            s = this.getBitmap(i),
            { next: r, initialized: u } = A.nextInitializedBit(s.word, a, t);

        return [A.buildTick(i, r, n), u, i, a, s.address];
    }
    updateCachedAccountInfos(e) {
        for (const t of this.accountsToFetch.bitmaps) {
            const n = e.get(t.toBase58());

            if (n) {
                const e = this.program.coder.accounts.decode("tickBitmapState", n.data);

                this.bitmapCache.set(e.wordPos, {
                    address: t,
                    word: A.generateBitmapWord(e.word),
                });
            }
        }
        for (const t of this.accountsToFetch.ticks) {
            const n = e.get(t.toBase58());

            if (n) {
                const e = this.program.coder.accounts.decode("tickState", n.data);

                this.tickCache.set(e.tick, {
                    address: t,
                    liquidityNet: _.default.BigInt(e.liquidityNet),
                });
            }
        }
    }
}
const at = _.default.BigInt(1e6),
    st = new p.Program(A.IDL, m.CYKURA_PROGRAM_ID, be);

class CykuraAmm {
    constructor(t, n) {
        (this.address = void 0),
            (this.label = "Cykura"),
            (this.id = void 0),
            (this.shouldPrefetch = !0),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !0),
            (this.poolState = void 0),
            (this.pool = void 0),
            (this.tickDataProvider = void 0),
            (this.tokens = void 0),
            (this.vaults = void 0),
            (this.feePct = void 0),
            (this.fee = void 0),
            (this.address = t),
            (this.id = t.toBase58()),
            (this.poolState = st.coder.accounts.decode("poolState", n.data));

        const {
            token0: o,
            token1: i,
            fee: a,
            sqrtPriceX32: s,
            liquidity: r,
            tick: c,
        } = this.poolState;

        (this.tickDataProvider = new it(st, { token0: o, token1: i, fee: a })),
            (this.tokens = {
                token0: new f.Token(101, o, 0, "", ""),
                token1: new f.Token(101, i, 0, "", ""),
            }),
            (this.pool = new A.Pool(
                this.tokens.token0,
                this.tokens.token1,
                a,
                _.default.BigInt(s.toString()),
                _.default.BigInt(r.toString()),
                c,
                this.tickDataProvider
            )),
            (this.vaults = {
                vault0: e.PublicKey.findProgramAddressSync(
                    [
                        this.address.toBuffer(),
                        u.TOKEN_PROGRAM_ID.toBuffer(),
                        o.toBuffer(),
                    ],
                    u.ASSOCIATED_TOKEN_PROGRAM_ID
                )[0],
                vault1: e.PublicKey.findProgramAddressSync(
                    [
                        this.address.toBuffer(),
                        u.TOKEN_PROGRAM_ID.toBuffer(),
                        i.toBuffer(),
                    ],
                    u.ASSOCIATED_TOKEN_PROGRAM_ID
                )[0],
            }),
            (this.fee = _.default.BigInt(this.poolState.fee)),
            (this.feePct = this.poolState.fee / _.default.toNumber(at));
    }
    getAccountsForUpdate() {
        return [
            this.address,
            ...this.tickDataProvider.lazyLoadAccountsToCache(
                this.pool.tickCurrent,
                this.pool.tickSpacing
            ),
        ];
    }
    update(e) {
        const t = e.get(this.address.toBase58());

        if (!t)
            throw new Error(
                `Could not find poolAccountInfo ${this.address.toBase58()}`
            );

        this.poolState = st.coder.accounts.decode("poolState", t.data);

        const { fee: n, sqrtPriceX32: o, liquidity: i, tick: a } = this.poolState;

        (this.pool = new A.Pool(
            this.tokens.token0,
            this.tokens.token1,
            n,
            _.default.BigInt(o.toString()),
            _.default.BigInt(i.toString()),
            a,
            this.tickDataProvider
        )),
            this.tickDataProvider.updateCachedAccountInfos(e);
    }
    getQuote({ sourceMint: e, amount: t }) {
        const n = e.equals(this.poolState.token0)
                ? this.tokens.token0
                : this.tokens.token1,
            [o, a, s] = this.pool.getOutputAmount(
                f.CurrencyAmount.fromRawAmount(n, t)
            ),
            r = i
                .toDecimal(_.default.subtract(this.pool.sqrtRatioX32, a.sqrtRatioX32))
                .div(this.pool.sqrtRatioX32.toString());

        return {
            notEnoughLiquidity: !1,
            inAmount: t,
            outAmount: o.quotient,
            feeAmount: _.default.divide(_.default.multiply(t, this.fee), at),
            feeMint: e.toBase58(),
            feePct: this.feePct,
            priceImpactPct: r.toNumber(),
        };
    }
    getSwapLegAndAccounts(t) {
        const [n, o] = t.sourceMint.equals(this.poolState.token0)
                ? [this.vaults.vault0, this.vaults.vault1]
                : [this.vaults.vault1, this.vaults.vault0],
            i = e.PublicKey.findProgramAddressSync(
                [
                    A.OBSERVATION_SEED,
                    this.poolState.token0.toBuffer(),
                    this.poolState.token1.toBuffer(),
                    A.u32ToSeed(this.poolState.fee),
                    A.u16ToSeed(this.poolState.observationIndex),
                ],
                m.CYKURA_PROGRAM_ID
            )[0],
            a = t.sourceMint.equals(this.poolState.token0)
                ? this.tokens.token0
                : this.tokens.token1,
            [, , s] = this.pool.getOutputAmount(
                f.CurrencyAmount.fromRawAmount(a, t.amount)
            ),
            r = e.PublicKey.findProgramAddressSync(
                [
                    A.OBSERVATION_SEED,
                    this.poolState.token0.toBuffer(),
                    this.poolState.token1.toBuffer(),
                    A.u32ToSeed(this.poolState.fee),
                    A.u16ToSeed(
                        (this.poolState.observationIndex + 1) %
                            this.poolState.observationCardinalityNext
                    ),
                ],
                m.CYKURA_PROGRAM_ID
            )[0],
            c = {
                poolAddress: this.address,
                inputVault: n,
                outputVault: o,
                nextObservationState: r,
                lastObservationState: i,
                swapAccountMetas: s,
            };

        return (function ({
            additionalArgs: e,
            userSourceTokenAccount: t,
            userDestinationTokenAccount: n,
            userTransferAuthority: o,
        }) {
            return [
                Pe({ cykura: {} }),
                m.JUPITER_PROGRAM.instruction.cykuraSwap({
                    accounts: {
                        swapProgram: m.CYKURA_PROGRAM_ID,
                        signer: o,
                        factoryState: m.CYKURA_FACTORY_STATE_ADDRESS,
                        poolState: e.poolAddress,
                        inputTokenAccount: t,
                        outputTokenAccount: n,
                        inputVault: e.inputVault,
                        outputVault: e.outputVault,
                        lastObservationState: e.lastObservationState,
                        coreProgram: m.CYKURA_PROGRAM_ID,
                        tokenProgram: u.TOKEN_PROGRAM_ID,
                    },
                    remainingAccounts: [
                        ...e.swapAccountMetas,
                        { pubkey: e.nextObservationState, isSigner: !1, isWritable: !0 },
                        Ee,
                    ],
                }).keys,
            ];
        })({ ...t, additionalArgs: c });
    }
    get reserveTokenMints() {
        return [this.poolState.token0, this.poolState.token1];
    }
}

const ut = { DkwiQyA2JfD8ARfvMbMqu2DD4XKRkewRZVDE94SZNxSS: { price: 1 } },
    ct = S.getDeltafiDexV2(m.DELTA_FI_PROGRAM_ID, be),
    mt = (e) => u.u64.fromBuffer(e.data.slice(64, 72)),
    dt = (e) => u.u64.fromBuffer(e.data.slice(36, 44));
    
function lt(e) {
    const t = e.readBigUInt64LE();

    return Number(t)
} 

function pt(e) {
    const t = e.readBigInt64LE(32);

    return Number(t)
} 
class ht {
    constructor(t, n) {
        (this.address = void 0),
            (this.id = void 0),
            (this.label = "GooseFX"),
            (this.shouldPrefetch = !1),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !0),
            (this.pairLayout = void 0),
            (this.quoter = void 0),
            (this.gooseFxAccounts = void 0),
            (this.fixedAccounts = void 0),
            (this.oracleAccounts = []),
            (this.quoteParams = void 0),
            (this.isQuoteInvalid = !0),
            (this.slot = void 0),
            (this.address = t),
            (this.id = t.toBase58()),
            (this.pairLayout = M.PAIR_LAYOUT.decode(n.data));

        const [o, i] = this.pairLayout.mints,
            a = new M.SyncSwap();

        (this.quoter = a.getSyncQuoter(o, i)),
            (this.gooseFxAccounts = this.quoter.getAccounts());

        const {
            pairAddress: s,
            sslIn: r,
            sslOut: u,
            liabilityVaultIn: c,
            liabilityVaultOut: m,
            swappedLiabilityVaultIn: d,
            swappedLiabilityVaultOut: l,
        } = this.gooseFxAccounts;

        (this.fixedAccounts = [e.SYSVAR_CLOCK_PUBKEY, s, r, u, c, m, d, l]),
            this.updateOracles();
    }
    updateOracles() {
        const e = Number(this.pairLayout.nOracle.toString()),
            t = this.pairLayout.oracles.slice(0, e).reduce((e, t) => {
                const n = Number(t.n);

                for (const o of t.elements.slice(0, n)) e.push(o.address);

                return e;
            }, []);

        this.oracleAccounts = t;
    }
    getAccountsForUpdate() {
        return [...this.fixedAccounts, ...this.oracleAccounts];
    }
    isSuspended(e) {
        if (this.quoteParams) {
            let t = Boolean(this.quoteParams.suspended);

            if (void 0 !== e)
                for (const n of this.quoteParams.publishedSlots)
                    t ||= n + this.quoteParams.maxDelay <= e;

            return t;
        }
        return !0;
    }
    update(e) {
        var t;

        const [n, o, i, a, s, r, u, c] = j(e, this.fixedAccounts);

        if (!(o && i && a && s && r && u && c))
            throw new Error("Missing account data");

        const m = M.wasm.OracleRegistry;

        this.pairLayout = M.PAIR_LAYOUT.decode(o.data);

        const { oracles: d, nOracle: l, maxDelay: p } = this.pairLayout,
            h = Number(l.toString()),
            g = new m();

        this.updateOracles();

        let A = [];

        for (const t of d.slice(0, h)) {
            const n = Number(t.n);

            for (const o of t.elements.slice(0, n)) {
                const t = e.get(o.address.toBase58());

                if (!t) return void (this.isQuoteInvalid = !0);

                g.add_oracle(o.address.toBuffer(), t.data),
                    A.push(BigInt(k.parsePriceData(t.data).aggregate.publishSlot));
            }
        }
        (this.slot = BigInt(lt(n.data))),
            this.isQuoteInvalid && (this.isQuoteInvalid = !1),
            null === (t = this.quoteParams) || void 0 === t || t.registry.free(),
            (this.quoteParams = {
                liabilityIn: BigInt(mt(s).toString()),
                liabilityOut: BigInt(mt(r).toString()),
                pairData: o.data,
                sslInData: i.data,
                sslOutData: a.data,
                swappedLiabilityIn: BigInt(mt(u).toString()),
                swappedLiabilityOut: BigInt(mt(c).toString()),
                registry: g,
                suspended: new M.SSL(i).isSuspended() || new M.SSL(a).isSuspended(),
                maxDelay: p,
                publishedSlots: A,
            });
    }
    getQuote({ sourceMint: e, amount: t }) {
        if (!this.quoteParams || this.isQuoteInvalid)
            throw new Error("Missing quote data");

        if (this.isSuspended(this.slot)) throw new Error("Quote suspended");

        const { quoteParams: n } = this,
            o = M.wasm.swap;

        let i;

        const a = e.equals(this.pairLayout.mints[0]);

        i = a
            ? o(
                    n.sslInData.slice(),
                    n.sslOutData.slice(),
                    n.pairData.slice(),
                    n.liabilityIn,
                    n.liabilityOut,
                    n.swappedLiabilityIn,
                    n.swappedLiabilityOut,
                    n.registry,
                    BigInt(t.toString())
                )
            : o(
                    n.sslOutData.slice(),
                    n.sslInData.slice(),
                    n.pairData.slice(),
                    n.liabilityOut,
                    n.liabilityIn,
                    n.swappedLiabilityOut,
                    n.swappedLiabilityIn,
                    n.registry,
                    BigInt(t.toString())
                );

        const s = this.pairLayout.feeRates[a ? 0 : 1],
            r = {
                notEnoughLiquidity: !1,
                inAmount: _.default.BigInt(i.amount_in.toString()),
                outAmount: _.default.BigInt(i.amount_out.toString()),
                feeAmount: _.default.BigInt(i.fee_paid.toString()),
                feeMint: e.toBase58(),
                feePct: s / 1e4,
                priceImpactPct: i.price_impact,
            };

        return i.free(), r;
    }
    getSwapLegAndAccounts(e) {
        var t;

        if (!this.quoteParams) throw new Error("Missing quote data");

        const n = e.sourceMint.equals(this.pairLayout.mints[0]),
            { gooseFxAccounts: o } = this,
            [i, a, s, r, c, d] = n
                ? [
                        o.sslIn,
                        o.liabilityVaultIn,
                        o.swappedLiabilityVaultIn,
                        o.sslOut,
                        o.liabilityVaultOut,
                        o.swappedLiabilityVaultOut,
                    ]
                : [
                        o.sslOut,
                        o.liabilityVaultOut,
                        o.swappedLiabilityVaultOut,
                        o.sslIn,
                        o.liabilityVaultIn,
                        o.swappedLiabilityVaultIn,
                    ];

        return (function ({
            additionalArgs: e,
            userSourceTokenAccount: t,
            userDestinationTokenAccount: n,
            userTransferAuthority: o,
        }) {
            const i = [];

            return (
                i.push(
                    e.referrer ? { pubkey: e.referrer, isSigner: !1, isWritable: !0 } : Ee
                ),
                e.oracles.forEach((e) => {
                    i.push({ pubkey: e, isSigner: !1, isWritable: !1 });
                }),
                i.push(Ee),
                [
                    Pe({ gooseFx: {} }),
                    m.JUPITER_PROGRAM.instruction.goosefxSwap({
                        accounts: {
                            swapProgram: m.GOOSE_FX_PROGRAM_ID,
                            controller: m.GOOSE_FX_CONTROLLER_ID,
                            pair: e.pair,
                            sslIn: e.sslIn,
                            sslOut: e.sslOut,
                            liabilityVaultIn: e.liabilityVaultIn,
                            swappedLiabilityVaultIn: e.swappedLiabilityVaultIn,
                            liabilityVaultOut: e.liabilityVaultOut,
                            swappedLiabilityVaultOut: e.swappedLiabilityVaultOut,
                            userInAta: t,
                            userOutAta: n,
                            feeCollectorAta: e.feeCollectorAta,
                            userWallet: o,
                            feeCollector: e.feeCollector,
                            tokenProgram: u.TOKEN_PROGRAM_ID,
                        },
                        remainingAccounts: i,
                    }).keys,
                ]
            );
        })({
            additionalArgs: {
                pair: this.gooseFxAccounts.pairAddress,
                sslIn: i,
                sslOut: r,
                liabilityVaultIn: a,
                swappedLiabilityVaultIn: s,
                liabilityVaultOut: c,
                swappedLiabilityVaultOut: d,
                feeCollectorAta: m.findAssociatedTokenAddress({
                    walletAddress: this.pairLayout.feeCollector,
                    tokenMintAddress: e.sourceMint,
                }),
                feeCollector: this.pairLayout.feeCollector,
                oracles: this.oracleAccounts,
                referrer:
                    null === (t = e.quoteMintToReferrer) || void 0 === t
                        ? void 0
                        : t.get(e.sourceMint.toBase58()),
            },
            ...e,
        });
    }
    get reserveTokenMints() {
        return this.pairLayout.mints;
    }
}
 

const gt = new p.Program(w.IDL, m.INVARIANT_PROGRAM_ID, be);



class At {
    static parsePoolStructure(e) { return gt.coder.accounts.decode("pool", e.data) } static parseTickmap(e) { return gt.coder.accounts.decode("tickmap", e.data) } static parseTick(e) { return { ...gt.coder.accounts.decode("tick", e.data) } } static getQuote(e, t, n, o, i, a) {
        const { currentTickIndex: s, fee: r, tickSpacing: u, tokenX: m, liquidity: d, sqrtPrice: l } = e, p = { currentTickIndex: s, tickSpacing: u, liquidity: d, fee: r, sqrtPrice: l }, h = { xToY: o.equals(m), byAmountIn: a === exports.SwapMode.ExactIn, swapAmount: new c.BN(i.toString()), priceLimit: o.equals(m) ? w.calculatePriceSqrt(w.MIN_TICK) : w.calculatePriceSqrt(w.MAX_TICK), slippage: w.toDecimal(0), ticks: t, tickmap: n, pool: p };

        return w.simulateSwap(h)
    } static getTickIndexToTickPubkeyHash(e, t, n) {
        if (!n) {
            const { tickAddress: n } = this.getTickAddress(e, t.currentTickIndex), o = new Map;

            return o.set(t.currentTickIndex, n), o
        } const o = w.findClosestTicks(n.bitmap, t.currentTickIndex, t.tickSpacing, w.TICK_CROSSES_PER_IX, Infinity, "down"), i = w.findClosestTicks(n.bitmap, t.currentTickIndex, t.tickSpacing, w.TICK_CROSSES_PER_IX, Infinity, "up");

        return o.concat([t.currentTickIndex]).concat(i).reduce(((t, n) => {
            const { tickAddress: o } = this.getTickAddress(e, n);

            return t.set(n, o), t
        }), new Map)
    } static getTickAddress(t, n) {
        const o = Buffer.alloc(4);

        o.writeInt32LE(n);

        const [i, a] = e.PublicKey.findProgramAddressSync([Buffer.from(p.utils.bytes.utf8.encode("tickv1")), t.toBuffer(), o], gt.programId);

        return { tickAddress: i, tickBump: a }
    }
} 


class InvariantAmm {
    constructor(e, t) { this.address = void 0, this.id = void 0, this.label = "Invariant", this.shouldPrefetch = !0, this.exactOutputSupported = !1, this.hasDynamicAccounts = !0, this.poolStructure = void 0, this.tickmap = void 0, this.tickPkToTickIndexHash = void 0, this.ticks = new Map, this.feePct = void 0, this.address = e, this.id = e.toBase58(), this.poolStructure = At.parsePoolStructure(t), this.tickPkToTickIndexHash = At.getTickIndexToTickPubkeyHash(this.address, this.poolStructure, this.tickmap), this.feePct = new C.default(this.poolStructure.fee.v.toString()).div(w.DENOMINATOR.toString()).toNumber() } getAccountsForUpdate() {
        const e = this.tickPkToTickIndexHash.values();

        return [this.address, this.poolStructure.tickmap, ...e]
    } update(e) {
        const t = e.get(this.address.toBase58());

        if (!t) throw new Error(`Missing invariant pool data ${this.address.toBase58()}`);

        this.poolStructure = At.parsePoolStructure(t);

        const n = e.get(this.poolStructure.tickmap.toBase58());

        n && (this.tickmap = At.parseTickmap(n)), this.tickPkToTickIndexHash = At.getTickIndexToTickPubkeyHash(this.address, this.poolStructure, this.tickmap), this.ticks.clear();

        for (const [t, n] of this.tickPkToTickIndexHash) {
            const o = e.get(n.toBase58());

            if (!o) continue;

            const i = At.parseTick(o);

            this.ticks.set(t, i)
        }
    } getQuote({ sourceMint: e, amount: t, swapMode: n }) {
        if (!this.tickmap) throw new Error("Missing tickmap");

        const o = At.getQuote(this.poolStructure, this.ticks, this.tickmap, e, t, n), i = new C.default(o.priceImpact.toString()).div(w.DENOMINATOR.toString()).toNumber();

        if (0 !== o.status) throw new Error(`Invariant simulation failed: ${this.address}`);

        const a = o.accumulatedAmountIn.add(o.accumulatedFee);

        return { notEnoughLiquidity: !1, inAmount: _.default.BigInt(a.toString()), outAmount: _.default.BigInt(o.accumulatedAmountOut.toString()), feeAmount: _.default.BigInt(o.accumulatedFee.toString()), feeMint: e.toBase58(), feePct: this.feePct, priceImpactPct: i }
    } getSwapLegAndAccounts(e) {
        var t;

        if (!this.tickmap) throw new Error("Missing tickmap");

        const n = At.getQuote(this.poolStructure, this.ticks, this.tickmap, e.sourceMint, e.amount, e.swapMode), o = {};

        this.tickPkToTickIndexHash.forEach(((e, t) => { o[t] = e }));

        const i = n.crossedTicks.concat(this.poolStructure.currentTickIndex).map((e => {
            const t = o[e];

            if (!t) throw new Error("Missing tick account.");

            return t
        })), a = e.sourceMint.equals(this.poolStructure.tokenX);

        return function ({ additionalArgs: e, userSourceTokenAccount: t, userDestinationTokenAccount: n, userTransferAuthority: o }) {
            const [i, a] = e.xToY ? [t, n] : [n, t], s = e.referrer ? [{ pubkey: e.referrer, isSigner: !1, isWritable: !0 }] : [];

            return e.crossedTickAddresses.forEach((e => { s.push({ pubkey: e, isSigner: !1, isWritable: !0 }) })), s.push(Ee), [Pe(ge(e.xToY)), m.JUPITER_PROGRAM.instruction.invariantSwap({ accounts: { swapProgram: m.INVARIANT_PROGRAM_ID, tokenProgram: u.TOKEN_PROGRAM_ID, owner: o, state: m.INVARIANT_STATE_ID, pool: e.pool, tickmap: e.tickmap, accountX: i, accountY: a, reserveX: e.reserveX, reserveY: e.reserveY, programAuthority: m.INVARIANT_PROGRAM_AUTHORITY_ID }, remainingAccounts: s }).keys]
        }({ ...e, additionalArgs: { xToY: a, pool: this.address, tickmap: this.poolStructure.tickmap, reserveX: this.poolStructure.tokenXReserve, reserveY: this.poolStructure.tokenYReserve, crossedTickAddresses: i, referrer: null === (t = e.quoteMintToReferrer) || void 0 === t ? void 0 : t.get(e.sourceMint.toBase58()) } })
    } get reserveTokenMints() { return [this.poolStructure.tokenX, this.poolStructure.tokenY] }
} 



class LifinityAmm {
    constructor(t, n) {
        var o;

        this.ammAccountInfo = void 0, this.id = void 0, this.label = "Lifinity", this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.swapState = void 0, this.poolInfo = void 0, this.ammData = void 0, this.slot = void 0, this.ammAccountInfo = n, this.id = t.toBase58(), this.swapState = ((t, n) => {
            const o = n.owner, i = P.LIFINITY_AMM_LAYOUT.decode(n.data), [a] = e.PublicKey.findProgramAddressSync([t.toBuffer()], o);

            return { programId: o, authority: a, amm: t, tokenAMint: i.tokenAMint, tokenBMint: i.tokenBMint, poolMint: i.poolMint, feeAccount: i.poolFeeAccount, pythAccount: i.pythAccount, pythPcAccount: i.pythPcAccount, configAccount: i.configAccount, poolCoinTokenAccount: i.tokenAAccount, poolCoinMint: i.tokenAMint, poolPcTokenAccount: i.tokenBAccount, poolPcMint: i.tokenBMint }
        })(t, n), this.poolInfo = { amm: (o = this.swapState).amm.toBase58(), configAccount: o.configAccount.toBase58(), feeAccount: o.feeAccount.toBase58(), pythAccount: o.pythAccount.toBase58(), pythPcAccount: o.pythPcAccount.toBase58(), poolCoinMint: o.poolCoinMint.toBase58(), poolCoinTokenAccount: o.poolCoinTokenAccount.toBase58(), poolMint: o.poolMint.toBase58(), poolPcTokenAccount: o.poolPcTokenAccount.toBase58(), poolPcMint: o.poolPcMint.toBase58(), poolCoinDecimal: 0, poolPcDecimal: 0, poolMintDecimal: 0, pythBaseDecimal: 0 }
    } getAccountsForUpdate() { return [this.swapState.poolCoinTokenAccount, this.swapState.poolPcTokenAccount, this.swapState.configAccount, this.swapState.pythAccount, this.swapState.pythPcAccount, e.SYSVAR_CLOCK_PUBKEY] } update(e) {
        const t = [];

        this.getAccountsForUpdate().forEach(((n, o) => {
            const i = e.get(n.toBase58());

            i && t.push({ publicKey: n, account: i })
        })), this.ammData = P.getParsedData([{ publicKey: this.swapState.amm, account: this.ammAccountInfo }, ...t], this.poolInfo), this.slot = lt(t[t.length - 1].account.data)
    } getQuote({ sourceMint: e, amount: t }) {
        if (!this.ammData || !this.slot) throw new Error("Accounts not loaded, missing ammData");

        if (this.isTradeFrozen) throw new Error("Trade is frozen");

        const n = this.swapState.poolCoinMint.equals(e) ? P.TradeDirection.AtoB : P.TradeDirection.BtoA;

        if (!this.ammData.pyth.status.equals(1) || this.ammData.pythPc && !this.ammData.pythPc.status.equals(1)) throw new Error("Pyth accounts are outdated");

        const o = new C.default(t.toString()), i = P.getCurveAmount(o, this.slot, this.ammData.amm, this.ammData.fees, this.ammData.coinBalance, this.ammData.pcBalance, this.ammData.config, this.ammData.pyth, this.ammData.pythPc, n);

        return { notEnoughLiquidity: !1, inAmount: t, outAmount: _.default.BigInt(i.amountSwapped.toString()), feeAmount: _.default.BigInt(i.fee.ceil().toString()), feeMint: e.toBase58(), feePct: i.feePercent.toNumber(), priceImpactPct: i.priceImpact.toNumber() }
    } getSwapLegAndAccounts(e) {
        return function ({ swapState: e, sourceMint: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i }) {
            const [a, s] = t.equals(e.tokenAMint) ? [e.poolCoinTokenAccount, e.poolPcTokenAccount] : [e.poolPcTokenAccount, e.poolCoinTokenAccount];

            return [Pe({ lifinity: {} }), m.JUPITER_PROGRAM.instruction.lifinitySwap({ accounts: { swapProgram: e.programId, authority: e.authority, amm: e.amm, userTransferAuthority: i, sourceInfo: n, destinationInfo: o, swapSource: a, swapDestination: s, poolMint: e.poolMint, feeAccount: e.feeAccount, tokenProgram: u.TOKEN_PROGRAM_ID, pythAccount: e.pythAccount, pythPcAccount: e.pythPcAccount, configAccount: e.configAccount } }).keys]
        }({ swapState: this.swapState, ...e })
    } get reserveTokenMints() { return [this.swapState.poolCoinMint, this.swapState.poolPcMint] } get isTradeFrozen() {
        var e;

        return 1 === (null === (e = this.ammData) || void 0 === e ? void 0 : e.amm.freezeTrade)
    }
} 


class LifinityV2Amm {
    constructor(e, t) {
        (this.address = void 0),
            (this.id = void 0),
            (this.label = "Lifinity V2"),
            (this.shouldPrefetch = !1),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !1),
            (this.ammState = void 0),
            (this.poolInfo = void 0),
            (this.ammData = void 0),
            (this.slot = void 0),
            (this.address = e);

        const n = new p.BorshAccountsCoder(T.IDL);

        var o;

        (this.id = e.toBase58()),
            (this.ammState = n.decode("amm", t.data)),
            (this.poolInfo = {
                amm: this.id,
                poolMint: (o = this.ammState).poolMint.toBase58(),
                feeAccount: o.feeAccount.toBase58(),
                oracleMainAccount: o.oracleMainAccount.toBase58(),
                oracleSubAccount: o.oracleSubAccount.toBase58(),
                oraclePcAccount: o.oraclePcAccount.toBase58(),
                poolCoinTokenAccount: o.tokenAAccount.toBase58(),
                poolCoinMint: o.tokenAMint.toBase58(),
                poolCoinDecimal: 0,
                poolPcTokenAccount: o.tokenBAccount.toBase58(),
                poolPcMint: o.tokenBMint.toBase58(),
                poolPcDecimal: 0,
                poolMintDecimal: 0,
                pythBaseDecimal: o.baseDecimals,
            });
    }
    getAccountsForUpdate() {
        return [
            this.address,
            this.ammState.tokenAAccount,
            this.ammState.tokenBAccount,
            this.ammState.oracleMainAccount,
            this.ammState.oracleSubAccount,
            this.ammState.oraclePcAccount,
            e.SYSVAR_CLOCK_PUBKEY,
        ];
    }
    update(e) {
        const t = this.getAccountsForUpdate().reduce((t, n) => {
            const o = e.get(n.toBase58());

            return o && t.push({ publicKey: n, account: o }), t;
        }, new Array());

        (this.ammData = T.getParsedData(t, this.poolInfo)),
            (this.slot = lt(t[t.length - 1].account.data));
    }
    getQuote({ sourceMint: e, amount: t }) {
        if (!this.ammData) throw new Error("Accounts not loaded, missing ammData");

        if (void 0 === this.slot) throw new Error("Slot not fetched");

        if (this.isTradeFrozen) throw new Error("Trade is frozen");

        const n = this.ammState.tokenAMint.equals(e)
            ? T.TradeDirection.AtoB
            : T.TradeDirection.BtoA;

        if (
            (this.ammData.oracleMain && !this.ammData.oracleMain.status.equals(1)) ||
            (this.ammData.oracleSub && !this.ammData.oracleSub.status.equals(1)) ||
            (this.ammData.oraclePc && !this.ammData.oraclePc.status.equals(1))
        )
            throw new Error("Pyth accounts are outdated");

        const o = new C.default(t.toString()),
            i = T.getCurveAmount(
                o,
                this.slot,
                this.ammData.amm,
                this.ammData.fees,
                this.ammData.coinBalance,
                this.ammData.pcBalance,
                this.ammData.config,
                this.ammData.oracleMain,
                this.ammData.oracleSub,
                this.ammData.oraclePc,
                n
            );

        return {
            notEnoughLiquidity: !1,
            inAmount: t,
            outAmount: _.default.BigInt(i.amountSwapped.toString()),
            feeAmount: _.default.BigInt(i.fee.ceil().toString()),
            feeMint: e.toBase58(),
            feePct: i.feePercent.toNumber(),
            priceImpactPct: i.priceImpact.toNumber(),
        };
    }
    getSwapLegAndAccounts(t) {
        return (function ({
            ammState: t,
            amm: n,
            sourceMint: o,
            userSourceTokenAccount: i,
            userDestinationTokenAccount: a,
            userTransferAuthority: s,
        }) {
            const [r, c] = o.equals(t.tokenAMint)
                ? [t.tokenAAccount, t.tokenBAccount]
                : [t.tokenBAccount, t.tokenAAccount];

            return [
                Pe({ lifinityV2: {} }),
                m.JUPITER_PROGRAM.instruction.lifinityV2Swap({
                    accounts: {
                        swapProgram: m.LIFINITY_V2_PROGRAM_ID,
                        authority: e.PublicKey.findProgramAddressSync(
                            [n.toBuffer()],
                            m.LIFINITY_V2_PROGRAM_ID
                        )[0],
                        amm: n,
                        userTransferAuthority: s,
                        sourceInfo: i,
                        destinationInfo: a,
                        swapSource: r,
                        swapDestination: c,
                        poolMint: t.poolMint,
                        feeAccount: t.feeAccount,
                        tokenProgram: u.TOKEN_PROGRAM_ID,
                        oracleMainAccount: t.oracleMainAccount,
                        oracleSubAccount: t.oracleSubAccount,
                        oraclePcAccount: t.oraclePcAccount,
                    },
                }).keys,
            ];
        })({ ammState: this.ammState, amm: this.address, ...t });
    }
    get reserveTokenMints() {
        return [this.ammState.tokenAMint, this.ammState.tokenBMint];
    }
    get isTradeFrozen() {
        return 1 === this.ammState.freezeTrade;
    }
}


var yt = "0.1.0", 
Mt = "marinade_finance", 
wt = [
    {
        name: "initialize",
        accounts: [
            { name: "creatorAuthority", isMut: !1, isSigner: !0 },
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "reservePda", isMut: !1, isSigner: !1 },
            { name: "stakeList", isMut: !0, isSigner: !1 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "msolMint", isMut: !1, isSigner: !1 },
            { name: "operationalSolAccount", isMut: !1, isSigner: !1 },
            {
                name: "liqPool",
                accounts: [
                    { name: "lpMint", isMut: !1, isSigner: !1 },
                    { name: "solLegPda", isMut: !1, isSigner: !1 },
                    { name: "msolLeg", isMut: !1, isSigner: !1 },
                ],
            },
            { name: "treasuryMsolAccount", isMut: !1, isSigner: !1 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "rent", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "data", type: { defined: "InitializeData" } }],
    },
    {
        name: "changeAuthority",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "adminAuthority", isMut: !1, isSigner: !0 },
        ],
        args: [{ name: "data", type: { defined: "ChangeAuthorityData" } }],
    },
    {
        name: "addValidator",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "managerAuthority", isMut: !1, isSigner: !0 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "validatorVote", isMut: !1, isSigner: !1 },
            { name: "duplicationFlag", isMut: !0, isSigner: !1 },
            { name: "rentPayer", isMut: !0, isSigner: !0 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "rent", isMut: !1, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "score", type: "u32" }],
    },
    {
        name: "removeValidator",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "managerAuthority", isMut: !1, isSigner: !0 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "duplicationFlag", isMut: !0, isSigner: !1 },
            { name: "operationalSolAccount", isMut: !0, isSigner: !1 },
        ],
        args: [
            { name: "index", type: "u32" },
            { name: "validatorVote", type: "publicKey" },
        ],
    },
    {
        name: "setValidatorScore",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "managerAuthority", isMut: !1, isSigner: !0 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
        ],
        args: [
            { name: "index", type: "u32" },
            { name: "validatorVote", type: "publicKey" },
            { name: "score", type: "u32" },
        ],
    },
    {
        name: "configValidatorSystem",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "managerAuthority", isMut: !1, isSigner: !0 },
        ],
        args: [{ name: "extraRuns", type: "u32" }],
    },
    {
        name: "deposit",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "msolMint", isMut: !0, isSigner: !1 },
            { name: "liqPoolSolLegPda", isMut: !0, isSigner: !1 },
            { name: "liqPoolMsolLeg", isMut: !0, isSigner: !1 },
            { name: "liqPoolMsolLegAuthority", isMut: !1, isSigner: !1 },
            { name: "reservePda", isMut: !0, isSigner: !1 },
            { name: "transferFrom", isMut: !0, isSigner: !0 },
            { name: "mintTo", isMut: !0, isSigner: !1 },
            { name: "msolMintAuthority", isMut: !1, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
            { name: "tokenProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "lamports", type: "u64" }],
    },
    {
        name: "depositStakeAccount",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "stakeList", isMut: !0, isSigner: !1 },
            { name: "stakeAccount", isMut: !0, isSigner: !1 },
            { name: "stakeAuthority", isMut: !1, isSigner: !0 },
            { name: "duplicationFlag", isMut: !0, isSigner: !1 },
            { name: "rentPayer", isMut: !0, isSigner: !0 },
            { name: "msolMint", isMut: !0, isSigner: !1 },
            { name: "mintTo", isMut: !0, isSigner: !1 },
            { name: "msolMintAuthority", isMut: !1, isSigner: !1 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "rent", isMut: !1, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
            { name: "tokenProgram", isMut: !1, isSigner: !1 },
            { name: "stakeProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "validatorIndex", type: "u32" }],
    },
    {
        name: "liquidUnstake",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "msolMint", isMut: !0, isSigner: !1 },
            { name: "liqPoolSolLegPda", isMut: !0, isSigner: !1 },
            { name: "liqPoolMsolLeg", isMut: !0, isSigner: !1 },
            { name: "treasuryMsolAccount", isMut: !0, isSigner: !1 },
            { name: "getMsolFrom", isMut: !0, isSigner: !1 },
            { name: "getMsolFromAuthority", isMut: !1, isSigner: !0 },
            { name: "transferSolTo", isMut: !0, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
            { name: "tokenProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "msolAmount", type: "u64" }],
    },
    {
        name: "addLiquidity",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "lpMint", isMut: !0, isSigner: !1 },
            { name: "lpMintAuthority", isMut: !1, isSigner: !1 },
            { name: "liqPoolMsolLeg", isMut: !1, isSigner: !1 },
            { name: "liqPoolSolLegPda", isMut: !0, isSigner: !1 },
            { name: "transferFrom", isMut: !0, isSigner: !0 },
            { name: "mintTo", isMut: !0, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
            { name: "tokenProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "lamports", type: "u64" }],
    },
    {
        name: "removeLiquidity",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "lpMint", isMut: !0, isSigner: !1 },
            { name: "burnFrom", isMut: !0, isSigner: !1 },
            { name: "burnFromAuthority", isMut: !1, isSigner: !0 },
            { name: "transferSolTo", isMut: !0, isSigner: !1 },
            { name: "transferMsolTo", isMut: !0, isSigner: !1 },
            { name: "liqPoolSolLegPda", isMut: !0, isSigner: !1 },
            { name: "liqPoolMsolLeg", isMut: !0, isSigner: !1 },
            { name: "liqPoolMsolLegAuthority", isMut: !1, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
            { name: "tokenProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "tokens", type: "u64" }],
    },
    {
        name: "configLp",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "adminAuthority", isMut: !1, isSigner: !0 },
        ],
        args: [{ name: "params", type: { defined: "ConfigLpParams" } }],
    },
    {
        name: "configMarinade",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "adminAuthority", isMut: !1, isSigner: !0 },
        ],
        args: [{ name: "params", type: { defined: "ConfigMarinadeParams" } }],
    },
    {
        name: "orderUnstake",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "msolMint", isMut: !0, isSigner: !1 },
            { name: "burnMsolFrom", isMut: !0, isSigner: !1 },
            { name: "burnMsolAuthority", isMut: !1, isSigner: !0 },
            { name: "newTicketAccount", isMut: !0, isSigner: !1 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "rent", isMut: !1, isSigner: !1 },
            { name: "tokenProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "msolAmount", type: "u64" }],
    },
    {
        name: "claim",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "reservePda", isMut: !0, isSigner: !1 },
            { name: "ticketAccount", isMut: !0, isSigner: !1 },
            { name: "transferSolTo", isMut: !0, isSigner: !1 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
        ],
        args: [],
    },
    {
        name: "stakeReserve",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "stakeList", isMut: !0, isSigner: !1 },
            { name: "validatorVote", isMut: !0, isSigner: !1 },
            { name: "reservePda", isMut: !0, isSigner: !1 },
            { name: "stakeAccount", isMut: !0, isSigner: !1 },
            { name: "stakeDepositAuthority", isMut: !1, isSigner: !1 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "epochSchedule", isMut: !1, isSigner: !1 },
            { name: "rent", isMut: !1, isSigner: !1 },
            { name: "stakeHistory", isMut: !1, isSigner: !1 },
            { name: "stakeConfig", isMut: !1, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
            { name: "stakeProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "validatorIndex", type: "u32" }],
    },
    {
        name: "updateActive",
        accounts: [
            {
                name: "common",
                accounts: [
                    { name: "state", isMut: !0, isSigner: !1 },
                    { name: "stakeList", isMut: !0, isSigner: !1 },
                    { name: "stakeAccount", isMut: !0, isSigner: !1 },
                    { name: "stakeWithdrawAuthority", isMut: !1, isSigner: !1 },
                    { name: "reservePda", isMut: !0, isSigner: !1 },
                    { name: "msolMint", isMut: !0, isSigner: !1 },
                    { name: "msolMintAuthority", isMut: !1, isSigner: !1 },
                    { name: "treasuryMsolAccount", isMut: !0, isSigner: !1 },
                    { name: "clock", isMut: !1, isSigner: !1 },
                    { name: "stakeHistory", isMut: !1, isSigner: !1 },
                    { name: "stakeProgram", isMut: !1, isSigner: !1 },
                    { name: "tokenProgram", isMut: !1, isSigner: !1 },
                ],
            },
            { name: "validatorList", isMut: !0, isSigner: !1 },
        ],
        args: [
            { name: "stakeIndex", type: "u32" },
            { name: "validatorIndex", type: "u32" },
        ],
    },
    {
        name: "updateDeactivated",
        accounts: [
            {
                name: "common",
                accounts: [
                    { name: "state", isMut: !0, isSigner: !1 },
                    { name: "stakeList", isMut: !0, isSigner: !1 },
                    { name: "stakeAccount", isMut: !0, isSigner: !1 },
                    { name: "stakeWithdrawAuthority", isMut: !1, isSigner: !1 },
                    { name: "reservePda", isMut: !0, isSigner: !1 },
                    { name: "msolMint", isMut: !0, isSigner: !1 },
                    { name: "msolMintAuthority", isMut: !1, isSigner: !1 },
                    { name: "treasuryMsolAccount", isMut: !0, isSigner: !1 },
                    { name: "clock", isMut: !1, isSigner: !1 },
                    { name: "stakeHistory", isMut: !1, isSigner: !1 },
                    { name: "stakeProgram", isMut: !1, isSigner: !1 },
                    { name: "tokenProgram", isMut: !1, isSigner: !1 },
                ],
            },
            { name: "operationalSolAccount", isMut: !0, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
        ],
        args: [{ name: "stakeIndex", type: "u32" }],
    },
    {
        name: "deactivateStake",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "reservePda", isMut: !1, isSigner: !1 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "stakeList", isMut: !0, isSigner: !1 },
            { name: "stakeAccount", isMut: !0, isSigner: !1 },
            { name: "stakeDepositAuthority", isMut: !1, isSigner: !1 },
            { name: "splitStakeAccount", isMut: !0, isSigner: !0 },
            { name: "splitStakeRentPayer", isMut: !0, isSigner: !0 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "rent", isMut: !1, isSigner: !1 },
            { name: "epochSchedule", isMut: !1, isSigner: !1 },
            { name: "stakeHistory", isMut: !1, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
            { name: "stakeProgram", isMut: !1, isSigner: !1 },
        ],
        args: [
            { name: "stakeIndex", type: "u32" },
            { name: "validatorIndex", type: "u32" },
        ],
    },
    {
        name: "emergencyUnstake",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "validatorManagerAuthority", isMut: !1, isSigner: !0 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "stakeList", isMut: !0, isSigner: !1 },
            { name: "stakeAccount", isMut: !0, isSigner: !1 },
            { name: "stakeDepositAuthority", isMut: !1, isSigner: !1 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "stakeProgram", isMut: !1, isSigner: !1 },
        ],
        args: [
            { name: "stakeIndex", type: "u32" },
            { name: "validatorIndex", type: "u32" },
        ],
    },
    {
        name: "partialUnstake",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "validatorManagerAuthority", isMut: !1, isSigner: !0 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "stakeList", isMut: !0, isSigner: !1 },
            { name: "stakeAccount", isMut: !0, isSigner: !1 },
            { name: "stakeDepositAuthority", isMut: !1, isSigner: !1 },
            { name: "reservePda", isMut: !1, isSigner: !1 },
            { name: "splitStakeAccount", isMut: !0, isSigner: !0 },
            { name: "splitStakeRentPayer", isMut: !0, isSigner: !0 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "rent", isMut: !1, isSigner: !1 },
            { name: "stakeHistory", isMut: !1, isSigner: !1 },
            { name: "systemProgram", isMut: !1, isSigner: !1 },
            { name: "stakeProgram", isMut: !1, isSigner: !1 },
        ],
        args: [
            { name: "stakeIndex", type: "u32" },
            { name: "validatorIndex", type: "u32" },
            { name: "desiredUnstakeAmount", type: "u64" },
        ],
    },
    {
        name: "mergeStakes",
        accounts: [
            { name: "state", isMut: !0, isSigner: !1 },
            { name: "stakeList", isMut: !0, isSigner: !1 },
            { name: "validatorList", isMut: !0, isSigner: !1 },
            { name: "destinationStake", isMut: !0, isSigner: !1 },
            { name: "sourceStake", isMut: !0, isSigner: !1 },
            { name: "stakeDepositAuthority", isMut: !1, isSigner: !1 },
            { name: "stakeWithdrawAuthority", isMut: !1, isSigner: !1 },
            { name: "operationalSolAccount", isMut: !0, isSigner: !1 },
            { name: "clock", isMut: !1, isSigner: !1 },
            { name: "stakeHistory", isMut: !1, isSigner: !1 },
            { name: "stakeProgram", isMut: !1, isSigner: !1 },
        ],
        args: [
            { name: "destinationStakeIndex", type: "u32" },
            { name: "sourceStakeIndex", type: "u32" },
            { name: "validatorIndex", type: "u32" },
        ],
    },
],

Pt = [
    {
        name: "State",
        type: {
            kind: "struct",
            fields: [
                { name: "msolMint", type: "publicKey" },
                { name: "adminAuthority", type: "publicKey" },
                { name: "operationalSolAccount", type: "publicKey" },
                { name: "treasuryMsolAccount", type: "publicKey" },
                { name: "reserveBumpSeed", type: "u8" },
                { name: "msolMintAuthorityBumpSeed", type: "u8" },
                { name: "rentExemptForTokenAcc", type: "u64" },
                { name: "rewardFee", type: { defined: "Fee" } },
                { name: "stakeSystem", type: { defined: "StakeSystem" } },
                { name: "validatorSystem", type: { defined: "ValidatorSystem" } },
                { name: "liqPool", type: { defined: "LiqPool" } },
                { name: "availableReserveBalance", type: "u64" },
                { name: "msolSupply", type: "u64" },
                { name: "msolPrice", type: "u64" },
                {
                    name: "circulatingTicketCount",
                    docs: ["count tickets for delayed-unstake"],
                    type: "u64",
                },
                {
                    name: "circulatingTicketBalance",
                    docs: [
                        "total lamports amount of generated and not claimed yet tickets",
                    ],
                    type: "u64",
                },
                { name: "lentFromReserve", type: "u64" },
                { name: "minDeposit", type: "u64" },
                { name: "minWithdraw", type: "u64" },
                { name: "stakingSolCap", type: "u64" },
                { name: "emergencyCoolingDown", type: "u64" },
            ],
        },
    },
    {
        name: "TicketAccountData",
        type: {
            kind: "struct",
            fields: [
                { name: "stateAddress", type: "publicKey" },
                { name: "beneficiary", type: "publicKey" },
                { name: "lamportsAmount", type: "u64" },
                { name: "createdEpoch", type: "u64" },
            ],
        },
    },
],
Tt = [
    {
        name: "LiqPool",
        type: {
            kind: "struct",
            fields: [
                { name: "lpMint", type: "publicKey" },
                { name: "lpMintAuthorityBumpSeed", type: "u8" },
                { name: "solLegBumpSeed", type: "u8" },
                { name: "msolLegAuthorityBumpSeed", type: "u8" },
                { name: "msolLeg", type: "publicKey" },
                {
                    name: "lpLiquidityTarget",
                    docs: [
                        "Liquidity target. If the Liquidity reach this amount, the fee reaches lp_min_discount_fee",
                    ],
                    type: "u64",
                },
                {
                    name: "lpMaxFee",
                    docs: ["Liquidity pool max fee"],
                    type: { defined: "Fee" },
                },
                {
                    name: "lpMinFee",
                    docs: ["SOL/mSOL Liquidity pool min fee"],
                    type: { defined: "Fee" },
                },
                {
                    name: "treasuryCut",
                    docs: ["Treasury cut"],
                    type: { defined: "Fee" },
                },
                { name: "lpSupply", type: "u64" },
                { name: "lentFromSolLeg", type: "u64" },
                { name: "liquiditySolCap", type: "u64" },
            ],
        },
    },
    {
        name: "List",
        type: {
            kind: "struct",
            fields: [
                { name: "account", type: "publicKey" },
                { name: "itemSize", type: "u32" },
                { name: "count", type: "u32" },
                { name: "newAccount", type: "publicKey" },
                { name: "copiedCount", type: "u32" },
            ],
        },
    },
    {
        name: "StakeRecord",
        type: {
            kind: "struct",
            fields: [
                { name: "stakeAccount", type: "publicKey" },
                { name: "lastUpdateDelegatedLamports", type: "u64" },
                { name: "lastUpdateEpoch", type: "u64" },
                { name: "isEmergencyUnstaking", type: "u8" },
            ],
        },
    },
    {
        name: "StakeSystem",
        type: {
            kind: "struct",
            fields: [
                { name: "stakeList", type: { defined: "List" } },
                { name: "delayedUnstakeCoolingDown", type: "u64" },
                { name: "stakeDepositBumpSeed", type: "u8" },
                { name: "stakeWithdrawBumpSeed", type: "u8" },
                {
                    name: "slotsForStakeDelta",
                    docs: [
                        "set by admin, how much slots before the end of the epoch, stake-delta can start",
                    ],
                    type: "u64",
                },
                {
                    name: "lastStakeDeltaEpoch",
                    docs: [
                        "Marks the start of stake-delta operations, meaning that if somebody starts a delayed-unstake ticket",
                        "after this var is set with epoch_num the ticket will have epoch_created = current_epoch+1",
                        "(the user must wait one more epoch, because their unstake-delta will be execute in this epoch)",
                    ],
                    type: "u64",
                },
                { name: "minStake", type: "u64" },
                {
                    name: "extraStakeDeltaRuns",
                    docs: [
                        "can be set by validator-manager-auth to allow a second run of stake-delta to stake late stakers in the last minute of the epoch",
                        "so we maximize user's rewards",
                    ],
                    type: "u32",
                },
            ],
        },
    },
    {
        name: "ValidatorRecord",
        type: {
            kind: "struct",
            fields: [
                {
                    name: "validatorAccount",
                    docs: ["Validator vote pubkey"],
                    type: "publicKey",
                },
                {
                    name: "activeBalance",
                    docs: ["Validator total balance in lamports"],
                    type: "u64",
                },
                { name: "score", type: "u32" },
                { name: "lastStakeDeltaEpoch", type: "u64" },
                { name: "duplicationFlagBumpSeed", type: "u8" },
            ],
        },
    },
    {
        name: "ValidatorSystem",
        type: {
            kind: "struct",
            fields: [
                { name: "validatorList", type: { defined: "List" } },
                { name: "managerAuthority", type: "publicKey" },
                { name: "totalValidatorScore", type: "u32" },
                {
                    name: "totalActiveBalance",
                    docs: ["sum of all active lamports staked"],
                    type: "u64",
                },
                {
                    name: "autoAddValidatorEnabled",
                    docs: [
                        "allow & auto-add validator when a user deposits a stake-account of a non-listed validator",
                    ],
                    type: "u8",
                },
            ],
        },
    },
    {
        name: "Fee",
        type: { kind: "struct", fields: [{ name: "basisPoints", type: "u32" }] },
    },
    {
        name: "InitializeData",
        type: {
            kind: "struct",
            fields: [
                { name: "adminAuthority", type: "publicKey" },
                { name: "validatorManagerAuthority", type: "publicKey" },
                { name: "minStake", type: "u64" },
                { name: "rewardFee", type: { defined: "Fee" } },
                { name: "liqPool", type: { defined: "LiqPoolInitializeData" } },
                { name: "additionalStakeRecordSpace", type: "u32" },
                { name: "additionalValidatorRecordSpace", type: "u32" },
                { name: "slotsForStakeDelta", type: "u64" },
            ],
        },
    },
    {
        name: "LiqPoolInitializeData",
        type: {
            kind: "struct",
            fields: [
                { name: "lpLiquidityTarget", type: "u64" },
                { name: "lpMaxFee", type: { defined: "Fee" } },
                { name: "lpMinFee", type: { defined: "Fee" } },
                { name: "lpTreasuryCut", type: { defined: "Fee" } },
            ],
        },
    },
    {
        name: "ChangeAuthorityData",
        type: {
            kind: "struct",
            fields: [
                { name: "admin", type: { option: "publicKey" } },
                { name: "validatorManager", type: { option: "publicKey" } },
                { name: "operationalSolAccount", type: { option: "publicKey" } },
                { name: "treasuryMsolAccount", type: { option: "publicKey" } },
            ],
        },
    },
    {
        name: "ConfigLpParams",
        type: {
            kind: "struct",
            fields: [
                { name: "minFee", type: { option: { defined: "Fee" } } },
                { name: "maxFee", type: { option: { defined: "Fee" } } },
                { name: "liquidityTarget", type: { option: "u64" } },
                { name: "treasuryCut", type: { option: { defined: "Fee" } } },
            ],
        },
    },
    {
        name: "ConfigMarinadeParams",
        type: {
            kind: "struct",
            fields: [
                { name: "rewardsFee", type: { option: { defined: "Fee" } } },
                { name: "slotsForStakeDelta", type: { option: "u64" } },
                { name: "minStake", type: { option: "u64" } },
                { name: "minDeposit", type: { option: "u64" } },
                { name: "minWithdraw", type: { option: "u64" } },
                { name: "stakingSolCap", type: { option: "u64" } },
                { name: "liquiditySolCap", type: { option: "u64" } },
                { name: "autoAddValidatorEnabled", type: { option: "bool" } },
            ],
        },
    },
    {
        name: "CommonError",
        type: {
            kind: "enum",
            variants: [
                { name: "WrongReserveOwner" },
                { name: "NonEmptyReserveData" },
                { name: "InvalidInitialReserveLamports" },
                { name: "ZeroValidatorChunkSize" },
                { name: "TooBigValidatorChunkSize" },
                { name: "ZeroCreditChunkSize" },
                { name: "TooBigCreditChunkSize" },
                { name: "TooLowCreditFee" },
                { name: "InvalidMintAuthority" },
                { name: "MintHasInitialSupply" },
                { name: "InvalidOwnerFeeState" },
                { name: "InvalidProgramId" },
                { name: "UnexpectedAccount" },
                { name: "CalculationFailure" },
                { name: "AccountWithLockup" },
                { name: "NumberTooLow" },
                { name: "NumberTooHigh" },
                { name: "FeeTooHigh" },
                { name: "FeesWrongWayRound" },
                { name: "LiquidityTargetTooLow" },
                { name: "TicketNotDue" },
                { name: "TicketNotReady" },
                { name: "WrongBeneficiary" },
                { name: "StakeAccountNotUpdatedYet" },
                { name: "StakeNotDelegated" },
                { name: "StakeAccountIsEmergencyUnstaking" },
                { name: "InsufficientLiquidity" },
                { name: "InvalidValidator" },
            ],
        },
    },
],
It = {
    __proto__: null,
    version: yt,
    name: Mt,
    instructions: wt,
    accounts: Pt,
    types: Tt,
    default: {
        version: yt,
        name: Mt,
        instructions: wt,
        accounts: Pt,
        types: Tt,
    },
};




function bt(e, t, n) { return n.isZero() ? e : e.mul(t).div(n) } 




class MarinadeAmm {
    constructor(e, t) { this.address = void 0, this.id = void 0, this.label = "Marinade", this.shouldPrefetch = !0, this.exactOutputSupported = !1, this.hasDynamicAccounts = !0, this.marinadeFinanceProgram = void 0, this.marinadeStateResponse = void 0, this.liqPoolSolLegPdaAddress = void 0, this.marinadeState = void 0, this.id = e.toBase58(), this.marinadeFinanceProgram = new p.Program(It, m.MARINADE_PROGRAM_ID, {}), this.marinadeStateResponse = this.marinadeFinanceProgram.coder.accounts.decode("State", t.data), this.address = e, this.liqPoolSolLegPdaAddress = this.findProgramDerivedAddress("liq_sol") } getAccountsForUpdate() { return [this.address, this.liqPoolSolLegPdaAddress, this.marinadeStateResponse.liqPool.msolLeg] } update(e) {
        const [t, n, o] = j(e, this.getAccountsForUpdate());

        this.marinadeStateResponse = this.marinadeFinanceProgram.coder.accounts.decode("State", t.data);

        const i = r.deserializeAccount(o.data);

        if (!i) throw new Error(`liqPoolMSOLLeg token account cannot be deserialized ${this.marinadeStateResponse.liqPool.msolLeg.toBase58()}`);

        this.marinadeState = new Rt(this.marinadeStateResponse, new x.default(n.lamports), i.amount)
    } getQuote({ sourceMint: e, amount: t }) {
        if (!this.marinadeState) throw new Error("Update was not run to create a complete marinadeState");

        const n = new x.default(t.toString()), o = e.equals(u.NATIVE_MINT) ? this.marinadeState.depositQuote(n) : this.marinadeState.liquidUnstakeQuote(n);

        return { notEnoughLiquidity: !1, inAmount: t, outAmount: _.default.BigInt(o.outAmount.toString()), feeAmount: _.default.BigInt(o.feeAmount.toString()), feeMint: this.marinadeStateResponse.msolMint.toBase58(), feePct: o.feePct, priceImpactPct: 0 }
    } getSwapLegAndAccounts(t) {
        return t.sourceMint.equals(u.NATIVE_MINT) ? function ({ additionalArgs: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i }) {
            const a = e.PublicKey.findProgramAddressSync([Buffer.from("temp-wsol-token-account"), i.toBuffer()], m.JUPITER_PROGRAM_ID)[0], s = e.PublicKey.findProgramAddressSync([Buffer.from("temp-sol-pda"), i.toBuffer()], m.JUPITER_PROGRAM_ID)[0];

            return [Pe({ marinadeDeposit: {} }), m.JUPITER_PROGRAM.instruction.marinadeDeposit({ accounts: { marinadeFinanceProgram: m.MARINADE_PROGRAM_ID, state: t.address, msolMint: t.marinadeStateResponse.msolMint, liqPoolSolLegPda: t.liqPoolSolLegPda, liqPoolMsolLeg: t.marinadeStateResponse.liqPool.msolLeg, liqPoolMsolLegAuthority: t.liqPoolMsolLegAuthority, reservePda: t.reservePda, transferFrom: s, mintTo: o, msolMintAuthority: t.msolMintAuthority, systemProgram: e.SystemProgram.programId, tokenProgram: u.TOKEN_PROGRAM_ID, userWsolTokenAccount: n, tempWsolTokenAccount: a, userTransferAuthority: i, wsolMint: u.NATIVE_MINT, rent: e.SYSVAR_RENT_PUBKEY } }).keys]
        }({ additionalArgs: { address: this.address, marinadeStateResponse: this.marinadeStateResponse, liqPoolSolLegPda: this.liqPoolSolLegPdaAddress, liqPoolMsolLegAuthority: this.findProgramDerivedAddress("liq_st_sol_authority"), reservePda: this.findProgramDerivedAddress("reserve"), msolMintAuthority: this.findProgramDerivedAddress("st_mint") }, ...t }) : function ({ additionalArgs: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i }) {
            const a = e.PublicKey.findProgramAddressSync([Buffer.from("temp-sol-pda"), i.toBuffer()], m.JUPITER_PROGRAM_ID)[0];

            return [Pe({ marinadeUnstake: {} }), m.JUPITER_PROGRAM.instruction.marinadeUnstake({ accounts: { marinadeFinanceProgram: m.MARINADE_PROGRAM_ID, state: t.address, msolMint: t.marinadeStateResponse.msolMint, liqPoolSolLegPda: t.liqPoolSolLegPda, liqPoolMsolLeg: t.marinadeStateResponse.liqPool.msolLeg, treasuryMsolAccount: t.marinadeStateResponse.treasuryMsolAccount, getMsolFrom: n, getMsolFromAuthority: i, transferSolTo: a, systemProgram: e.SystemProgram.programId, tokenProgram: u.TOKEN_PROGRAM_ID, userWsolTokenAccount: o } }).keys]
        }({ additionalArgs: { address: this.address, marinadeStateResponse: this.marinadeStateResponse, liqPoolSolLegPda: this.liqPoolSolLegPdaAddress }, ...t })
    } get reserveTokenMints() { return [u.NATIVE_MINT, this.marinadeStateResponse.msolMint] } findProgramDerivedAddress(t, n = []) {
        const o = [this.address.toBuffer(), Buffer.from(t), ...n], [i] = e.PublicKey.findProgramAddressSync(o, this.marinadeFinanceProgram.programId);

        return i
    }
} 


class Rt {
    constructor(e, t, n) { this.state = void 0, this.liqPoolSolLegPdaLamports = void 0, this.liqPoolMSOLLegAmount = void 0, this.state = e, this.liqPoolSolLegPdaLamports = t, this.liqPoolMSOLLegAmount = n } depositQuote(e) {
        let t = e;

        const n = this.calcMSOLFromLamports(t), o = x.default.min(n, this.liqPoolMSOLLegAmount);

        let i = new x.default(0);

        if (t = (() => {
            if (o.gt(new x.default(0))) {
                const e = n.eq(o) ? t : this.calcLamportsFromMSOLAmount(o);

                return i = i.add(o), Bt(t, e)
            } return t
        })(), t.gt(new x.default(0))) {
            this.checkStakingCap(t);

            const e = this.calcMSOLFromLamports(t);

            i = i.add(e)
        } return { outAmount: i, feeAmount: 0, feePct: 0, priceImpactPct: 0 }
    } checkStakingCap(e) { if (this.totalLamportsUnderControl().add(e).gt(this.state.stakingSolCap)) throw new Error("Staking cap reached") } calcMSOLFromLamports(e) {
        return t = e, n = this.totalVirtualStakedLamports(), (o = this.state.msolSupply).eq(new x.default(0)) ? t : bt(t, o, n);

        var t, n, o
    } calcLamportsFromMSOLAmount(e) { return bt(e, this.totalVirtualStakedLamports(), this.state.msolSupply) } totalVirtualStakedLamports() { return Bt(this.totalLamportsUnderControl(), this.state.circulatingTicketBalance) } totalLamportsUnderControl() { return this.state.validatorSystem.totalActiveBalance.add(this.totalCoolingDown()).add(this.state.availableReserveBalance) } totalCoolingDown() { return this.state.stakeSystem.delayedUnstakeCoolingDown.add(this.state.emergencyCoolingDown) } liquidUnstakeQuote(e) {
        const t = Bt(this.liqPoolSolLegPdaLamports, this.state.rentExemptForTokenAcc), n = this.calcLamportsFromMSOLAmount(e), o = function (e, t, n, o, i) {
            if (i.gte(o)) return t;

            const a = o.sub(i);

            return a.gte(n) ? e : t - bt(new x.default(t - e), a, n).toNumber()
        }(this.state.liqPool.lpMinFee.basisPoints, this.state.liqPool.lpMaxFee.basisPoints, this.state.liqPool.lpLiquidityTarget, t, n), i = e.mul(new x.default(o)).div(new x.default(1e4)), a = this.calcLamportsFromMSOLAmount(e.sub(i));

        if (a.add(this.state.rentExemptForTokenAcc).gt(this.liqPoolSolLegPdaLamports)) throw new Error("Insufficient liquidity");

        return { outAmount: a, feeAmount: i, feePct: o / 1e4, priceImpactPct: 0 }
    }
} 


function Bt(e, t) { return e.gt(t) ? e.sub(t) : new x.default(0) } const Ot = Math.pow(10, 10), Dt = d.struct([d.u8("version"), d.u8("isInitialized"), d.u8("nonce"), te("amplificationCoefficient"), te("feeNumerator"), te("adminFeeNumerator"), d.u32("tokenAccountsLength"), te("precisionFactor"), te("precisionMultiplierA"), te("precisionMultiplierB"), te("precisionMultiplierC"), te("precisionMultiplierD"), H("tokenAccountA"), H("tokenAccountB"), H("tokenAccountC"), H("tokenAccountD")]), Et = (e, t) => {
    const n = t.owner, o = Dt.decode(t.data), i = o.tokenAccountsLength, a = ie([e.toBuffer(), Buffer.from([o.nonce])], n), s = [o.precisionMultiplierA.toNumber(), o.precisionMultiplierB.toNumber(), o.precisionMultiplierC.toNumber(), o.precisionMultiplierD.toNumber()].slice(0, i), r = [o.tokenAccountA, o.tokenAccountB, o.tokenAccountC, o.tokenAccountD].slice(0, i);

    return { programId: n, authority: a, isInitialized: Boolean(o.isInitialized), nonce: o.nonce, ammId: e, amplificationCoefficient: o.amplificationCoefficient.toNumber(), feeNumerator: o.feeNumerator.toNumber(), tokenAccountsLength: i, precisionFactor: o.precisionFactor.toNumber(), precisionMultipliers: s, tokenAccounts: r }
};


class MercurialAmm {
    constructor(t, n, o) {
        (this.address = void 0),
            (this.params = void 0),
            (this.id = void 0),
            (this.label = "Mercurial"),
            (this.shouldPrefetch = !1),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !1),
            (this.swapLayout = void 0),
            (this.tokenMints = void 0),
            (this.tokenReserveAmounts = void 0),
            (this.calculator = void 0),
            (this.address = t),
            (this.params = o),
            (this.id = t.toBase58()),
            (this.swapLayout = Et(t, n)),
            (this.calculator = MercurialAmm.calculatorFromSwapState(this.swapLayout)),
            (this.tokenMints = o.tokenMints.map((t) => new e.PublicKey(t)));
    }
    getAccountsForUpdate() {
        return [this.address, ...this.swapLayout.tokenAccounts];
    }
    static calculatorFromSwapState(e) {
        return new i.Stable(
            _.default.BigInt(e.tokenAccountsLength),
            _.default.BigInt(e.amplificationCoefficient),
            e.precisionMultipliers.map((e) => _.default.BigInt(e)),
            new i.Fraction(_.default.BigInt(e.feeNumerator), _.default.BigInt(Ot))
        );
    }
    update(e) {
        const [t, ...n] = j(e, this.getAccountsForUpdate());

        (this.swapLayout = MercurialAmm.decodeSwapLayout(this.address, t)),
            (this.calculator = MercurialAmm.calculatorFromSwapState(this.swapLayout)),
            (this.tokenReserveAmounts = Q(n));
    }
    getQuote({ sourceMint: e, destinationMint: t, amount: n }) {
        if (!this.tokenReserveAmounts) throw new Error(J);

        const o = this.tokenReserveAmounts.findIndex((t, n) =>
                this.tokenMints[n].equals(e)
            ),
            i = this.tokenReserveAmounts.findIndex((e, n) =>
                this.tokenMints[n].equals(t)
            ),
            a = this.calculator.exchange(this.tokenReserveAmounts, n, o, i),
            s = this.swapLayout.feeNumerator / Ot;

        return {
            notEnoughLiquidity: !1,
            inAmount: n,
            outAmount: a.expectedOutputAmount,
            feeAmount: a.fees,
            feeMint: t.toBase58(),
            feePct: s,
            priceImpactPct: a.priceImpact.toNumber(),
        };
    }
    getSwapLegAndAccounts(e) {
        return (function ({
            swapLayout: e,
            userSourceTokenAccount: t,
            userDestinationTokenAccount: n,
            userTransferAuthority: o,
        }) {
            const i = [];

            for (const t of e.tokenAccounts)
                i.push({ pubkey: t, isSigner: !1, isWritable: !0 });

            return [
                Pe({ mercurial: {} }),
                m.JUPITER_PROGRAM.instruction.mercurialSwap({
                    accounts: Le(e, t, n, o),
                    remainingAccounts: i,
                }).keys,
            ];
        })({ swapLayout: this.swapLayout, ...e });
    }
    get reserveTokenMints() {
        return this.params.tokenMints.map((t) => new e.PublicKey(t));
    }
}


MercurialAmm.decodeSwapLayout = Et;



const Lt = new p.Program(I.AmmIdl, I.PROGRAM_ID, be), _t = new p.Program(I.VaultIdl, I.PROGRAM_ID, be), qt = e => Lt.coder.accounts.decode("pool", e.data), xt = e => _t.coder.accounts.decode("vault", e.data);



class MeteoraAmm {
    constructor(t, n, o) {
        var i, a;

        this.address = void 0, this.id = void 0, this.label = "Meteora", this.shouldPrefetch = !0, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.poolState = void 0, this.data = void 0, this.depegAccount = void 0, this.depegAccounts = new Map, this.vaultLpMint = void 0, this.vaultToken = void 0, this.feePct = void 0, this.address = t, this.id = t.toBase58(), this.poolState = qt(n), this.vaultLpMint = { a: new e.PublicKey(o.vaultLpMint.a), b: new e.PublicKey(o.vaultLpMint.b) }, this.vaultToken = { a: new e.PublicKey(o.vaultToken.a), b: new e.PublicKey(o.vaultToken.b) };

        const s = this.poolState.curveType, r = Object.keys((null == s || null === (i = s.stable) || void 0 === i || null === (a = i.depeg) || void 0 === a ? void 0 : a.depegType) || {})[0];

        if (r && "none" !== r) if ("lido" === r || "marinade" === r) this.depegAccount = { pubkey: I.CURVE_TYPE_ACCOUNTS[r] };

        else {
            if ("splStake" !== r) throw new Error("depegType not supported");

            this.depegAccount = { pubkey: this.poolState.stake }
        } const { ownerTradeFeeDenominator: u, ownerTradeFeeNumerator: c, tradeFeeDenominator: m, tradeFeeNumerator: d } = this.poolState.fees;

        this.feePct = new C.default(c.toString()).div(u.toString()).add(new C.default(d.toString()).div(m.toString())).toNumber()
    } getAccountsForUpdate() {
        var t;

        const n = [this.poolState.aVault, this.poolState.bVault, this.poolState.aVaultLp, this.poolState.bVaultLp, this.poolState.lpMint, this.vaultLpMint.a, this.vaultLpMint.b, this.vaultToken.a, this.vaultToken.b, e.SYSVAR_CLOCK_PUBKEY];

        return null !== (t = this.depegAccount) && void 0 !== t && t.pubkey && n.push(this.depegAccount.pubkey), n
    } update(e) {
        const [t, n, o, i, a, s, r, u, c, m, d] = j(e, this.getAccountsForUpdate());

        d && this.depegAccount && this.depegAccounts.set(this.depegAccount.pubkey.toBase58(), d), this.data = { vaultA: xt(t), vaultB: xt(n), poolAVaultLpAmount: mt(o), poolBVaultLpAmount: mt(i), poolLpTotalSupply: dt(a), vaultALpTotalSupply: dt(s), vaultBLpTotalSupply: dt(r), vaultAReserve: mt(u), vaultBReserve: mt(c), currentTime: pt(m.data) }
    } getQuote({ sourceMint: e, destinationMint: t, amount: n }) {
        if (void 0 === this.data || this.depegAccount && 0 === this.depegAccounts.size) throw new Error("Missing initial fetch");

        const o = new c.BN(n.toString()), i = I.calculateSwapQuote(e, o, { currentTime: this.data.currentTime, depegAccounts: this.depegAccounts, poolState: this.poolState, poolVaultALp: this.data.poolAVaultLpAmount, poolVaultBLp: this.data.poolBVaultLpAmount, vaultA: this.data.vaultA, vaultALpSupply: this.data.vaultALpTotalSupply, vaultB: this.data.vaultB, vaultBLpSupply: this.data.vaultBLpTotalSupply, vaultAReserve: this.data.vaultAReserve, vaultBReserve: this.data.vaultBReserve });

        return { notEnoughLiquidity: !1, inAmount: n, outAmount: _.default.BigInt(i.amountOut.toString()), feeAmount: _.default.BigInt(i.fee.toString()), feeMint: t.toBase58(), feePct: this.feePct, priceImpactPct: i.priceImpact.toNumber() }
    } getSwapLegAndAccounts(e) {
        var t, n;

        if (void 0 === this.data) throw new Error("Unable to fetch accounts.");

        const o = e.sourceMint.equals(this.poolState.tokenAMint) ? this.poolState.adminTokenAFee : this.poolState.adminTokenBFee;

        return function ({ additionalArgs: e, userSourceTokenAccount: t, userDestinationTokenAccount: n, userTransferAuthority: o }) {
            const i = [];

            return i.push(e.referrer ? { pubkey: e.referrer, isSigner: !1, isWritable: !0 } : Ee), i.push(e.depeg ? { pubkey: e.depeg, isSigner: !1, isWritable: !1 } : Ee), [Pe({ meteora: {} }), m.JUPITER_PROGRAM.instruction.meteoraSwap({ accounts: { swapProgram: m.METEORA_PROGRAM_ID, pool: e.pool, userSourceToken: t, userDestinationToken: n, aVault: e.aVault, bVault: e.bVault, aTokenVault: e.aTokenVault, bTokenVault: e.bTokenVault, aVaultLpMint: e.aVaultLpMint, bVaultLpMint: e.bVaultLpMint, aVaultLp: e.aVaultLp, bVaultLp: e.bVaultLp, adminTokenFee: e.adminTokenFee, user: o, vaultProgram: m.METEORA_VAULT_PROGRAM_ID, tokenProgram: u.TOKEN_PROGRAM_ID }, remainingAccounts: i }).keys]
        }({ additionalArgs: { pool: this.address, aVault: this.poolState.aVault, bVault: this.poolState.bVault, aTokenVault: this.vaultToken.a, bTokenVault: this.vaultToken.b, aVaultLpMint: this.vaultLpMint.a, bVaultLpMint: this.vaultLpMint.b, aVaultLp: this.poolState.aVaultLp, bVaultLp: this.poolState.bVaultLp, adminTokenFee: o, referrer: null === (t = e.quoteMintToReferrer) || void 0 === t ? void 0 : t.get(e.sourceMint.toBase58()), depeg: null === (n = this.depegAccount) || void 0 === n ? void 0 : n.pubkey }, ...e })
    } get currentTime() {
        var e;

        if (void 0 === this.data) throw new Error("Missing initial fetch");

        return null === (e = this.data) || void 0 === e ? void 0 : e.currentTime
    } get poolVaults() {
        if (void 0 === this.data) throw new Error("Missing initial fetch");

        return [this.data.vaultA, this.data.vaultB]
    } get poolVaultLPShares() {
        if (void 0 === this.data) throw new Error("Missing initial fetch");

        return [this.data.poolAVaultLpAmount, this.data.poolBVaultLpAmount]
    } get poolVaultLPTotalSupplies() {
        if (void 0 === this.data) throw new Error("Missing initial fetch");

        return [this.data.vaultALpTotalSupply, this.data.vaultBLpTotalSupply]
    } get reserveTokenMints() { return [this.poolState.tokenAMint, this.poolState.tokenBMint] }
} 

MeteoraAmm.accountInfoToMeteoraSwapLayout = qt, 

MeteoraAmm.accountInfoToVaultLayout = xt;



const Nt = d.struct([
    d.nu64("status"),
    d.nu64("nonce"),
    d.nu64("orderNum"),
    d.nu64("depth"),
    d.nu64("coinDecimals"),
    d.nu64("pcDecimals"),
    d.nu64("state"),
    d.nu64("resetFlag"),
    d.nu64("minSize"),
    d.nu64("volMaxCutRatio"),
    d.nu64("amountWaveRatio"),
    d.nu64("coinLotSize"),
    d.nu64("pcLotSize"),
    d.nu64("minPriceMultiplier"),
    d.nu64("maxPriceMultiplier"),
    d.nu64("systemDecimalsValue"),
    d.nu64("minSeparateNumerator"),
    d.nu64("minSeparateDenominator"),
    d.nu64("tradeFeeNumerator"),
    d.nu64("tradeFeeDenominator"),
    d.nu64("pnlNumerator"),
    d.nu64("pnlDenominator"),
    d.nu64("swapFeeNumerator"),
    d.nu64("swapFeeDenominator"),
    d.nu64("needTakePnlCoin"),
    d.nu64("needTakePnlPc"),
    d.nu64("totalPnlPc"),
    d.nu64("totalPnlCoin"),
    ne("poolTotalDepositPc"),
    ne("poolTotalDepositCoin"),
    ne("swapCoinInAmount"),
    ne("swapPcOutAmount"),
    d.nu64("swapCoin2PcFee"),
    ne("swapPcInAmount"),
    ne("swapCoinOutAmount"),
    d.nu64("swapPc2CoinFee"),
    H("poolCoinTokenAccount"),
    H("poolPcTokenAccount"),
    H("coinMintAddress"),
    H("pcMintAddress"),
    H("lpMintAddress"),
    H("ammOpenOrders"),
    H("serumMarket"),
    H("serumProgramId"),
    H("ammTargetOrders"),
    H("poolWithdrawQueue"),
    H("poolTempLpTokenAccount"),
    H("ammOwner"),
    H("pnlOwner"),
]);



class RaydiumAmm {
    constructor(t, n, o) {
        (this.ammId = void 0),
            (this.id = void 0),
            (this.label = "Raydium"),
            (this.shouldPrefetch = !1),
            (this.exactOutputSupported = !0),
            (this.hasDynamicAccounts = !1),
            (this.coinMint = void 0),
            (this.pcMint = void 0),
            (this.status = void 0),
            (this.serumProgramId = void 0),
            (this.serumMarket = void 0),
            (this.ammOpenOrders = void 0),
            (this.ammTargetOrders = void 0),
            (this.poolCoinTokenAccount = void 0),
            (this.poolPcTokenAccount = void 0),
            (this.serumMarketKeys = void 0),
            (this.coinReserve = void 0),
            (this.pcReserve = void 0),
            (this.feePct = void 0),
            (this.calculator = void 0),
            (this.ammId = t),
            (this.id = t.toBase58());

        const a = Nt.decode(n.data);

        (this.status = a.status),
            (this.coinMint = new e.PublicKey(a.coinMintAddress)),
            (this.pcMint = new e.PublicKey(a.pcMintAddress)),
            (this.poolCoinTokenAccount = new e.PublicKey(a.poolCoinTokenAccount)),
            (this.poolPcTokenAccount = new e.PublicKey(a.poolPcTokenAccount)),
            (this.serumProgramId = new e.PublicKey(a.serumProgramId)),
            (this.serumMarket = new e.PublicKey(a.serumMarket)),
            (this.ammOpenOrders = new e.PublicKey(a.ammOpenOrders)),
            (this.ammTargetOrders = new e.PublicKey(a.ammTargetOrders)),
            (this.serumMarketKeys = Object.keys(o).reduce((t, n) => {
                if (!o[n]) throw new Error(`Could not find ${n} in params`);

                return (t[n] = new e.PublicKey(o[n])), t;
            }, {}));

        const s = a.swapFeeNumerator,
            r = a.swapFeeDenominator;

        (this.feePct = new C.default(s.toString()).div(r.toString())),
            (this.calculator = new i.TokenSwapConstantProduct(
                new i.Fraction(_.default.BigInt(s), _.default.BigInt(r)),
                i.ZERO_FRACTION
            ));
    }
    static decodeSerumMarketKeysString(e, t, o, i) {
        if (!t.equals(m.OPENBOOK_PROGRAM_ID))
            return {
                serumBids: e.toBase58(),
                serumAsks: e.toBase58(),
                serumEventQueue: e.toBase58(),
                serumCoinVaultAccount: e.toBase58(),
                serumPcVaultAccount: e.toBase58(),
                serumVaultSigner: e.toBase58(),
            };

        const a = n.Market.getLayout(t).decode(i.data),
            s = ie(
                [o.toBuffer(), a.vaultSignerNonce.toArrayLike(Buffer, "le", 8)],
                t
            );

        return {
            serumBids: a.bids.toBase58(),
            serumAsks: a.asks.toBase58(),
            serumEventQueue: a.eventQueue.toBase58(),
            serumCoinVaultAccount: a.baseVault.toBase58(),
            serumPcVaultAccount: a.quoteVault.toBase58(),
            serumVaultSigner: s.toBase58(),
        };
    }
    getAccountsForUpdate() {
        return [
            this.ammId,
            this.poolCoinTokenAccount,
            this.poolPcTokenAccount,
            this.ammOpenOrders,
        ];
    }
    update(e) {
        const [t, o, i, a] = j(e, this.getAccountsForUpdate()),
            [s, r] = [mt(o), mt(i)],
            c = n.OpenOrders.fromAccountInfo(this.ammOpenOrders, a, a.owner),
            m = Nt.decode(t.data);

        (this.coinReserve = _.default.BigInt(
            s.add(c.baseTokenTotal).sub(new u.u64(String(m.needTakePnlCoin)))
        )),
            (this.pcReserve = _.default.BigInt(
                r.add(c.quoteTokenTotal).sub(new u.u64(String(m.needTakePnlPc)))
            ));
    }
    getQuoteInternal({
        amount: e,
        sourceMint: t,
        coinReserve: n,
        pcReserve: o,
        swapMode: i,
    }) {
        const a = this.coinMint.equals(t) ? 1 : 0;

        if (i == exports.SwapMode.ExactIn) {
            const t = this.calculator.exchange([n, o], e, a);

            return {
                inAmount: e,
                outAmount: t.expectedOutputAmount,
                feeAmount: t.fees,
                priceImpactPct: t.priceImpact.toNumber(),
            };
        }
        {
            const t = this.calculator.exchangeForExactOutput([n, o], e, a);

            return {
                inAmount: t.expectedInputAmount,
                outAmount: e,
                feeAmount: t.fees,
                priceImpactPct: t.priceImpact.toNumber(),
            };
        }
    }
    getQuote({ sourceMint: e, amount: t, swapMode: n }) {
        const { coinReserve: o, pcReserve: i } = this;

        if (!this.isTradable) throw new Error("Pool is not tradable");

        if (!o || !i)
            throw new Error("Pool token accounts balances not refreshed or empty");

        return {
            ...this.getQuoteInternal({
                amount: t,
                sourceMint: e,
                coinReserve: o,
                pcReserve: i,
                swapMode: n,
            }),
            notEnoughLiquidity: !1,
            feeMint: e.toBase58(),
            feePct: this.feePct.toNumber(),
        };
    }
    getSwapLegAndAccounts(e) {
        return (function ({
            raydiumAmm: e,
            userSourceTokenAccount: t,
            userDestinationTokenAccount: n,
            userTransferAuthority: o,
        }) {
            return [
                Pe({ raydium: {} }),
                m.JUPITER_PROGRAM.instruction.raydiumSwap({ accounts: qe(e, t, n, o) })
                    .keys,
            ];
        })({ raydiumAmm: this, ...e });
    }
    createExactOutSwapInstruction(e) {
        return (function ({
            raydiumAmm: e,
            userSourceTokenAccount: t,
            userDestinationTokenAccount: n,
            userTransferAuthority: o,
            outAmount: i,
            inAmount: a,
            slippageBps: s,
            platformFee: r,
            overflowFeeAccount: u,
        }) {
            var c;

            return m.JUPITER_PROGRAM.instruction.raydiumSwapExactOutput(
                i,
                { amount: a, slippageBps: s },
                null !== (c = null == r ? void 0 : r.feeBps) && void 0 !== c ? c : 0,
                {
                    accounts: qe(e, t, n, o),
                    remainingAccounts: Ne(null == r ? void 0 : r.feeAccount, u),
                }
            );
        })({
            raydiumAmm: this,
            ...e,
            outAmount: new x.default(e.amount.toString()),
            inAmount: new x.default(e.inAmount.toString()),
        });
    }
    get reserveTokenMints() {
        return [this.coinMint, this.pcMint];
    }
    get isTradable() {
        return 1 === this.status || 6 === this.status;
    }
}


const Ut = new p.Program({ version: "0.0.1", name: "add_decimals", instructions: [], accounts: [{ name: "wrappedToken", type: { kind: "struct", fields: [{ name: "decimals", type: "u8" }, { name: "multiplier", type: "u64" }, { name: "wrappedUnderlyingMint", type: "publicKey" }, { name: "wrappedUnderlyingTokens", type: "publicKey" }, { name: "wrapperMint", type: "publicKey" }, { name: "nonce", type: "u8" }] } }], errors: [] }, m.SABER_ADD_DECIMALS_PROGRAM_ID, be);



class Vt {
    constructor(e, t) { this.address = void 0, this.accountInfo = void 0, this.id = void 0, this.label = "Saber (Decimals)", this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.wrappedToken = void 0, this.multiplierJsbi = void 0, this.address = e, this.accountInfo = t, this.id = e.toBase58(), this.wrappedToken = Ut.coder.accounts.decode("wrappedToken", t.data), this.multiplierJsbi = _.default.BigInt(this.wrappedToken.multiplier) } getAccountsForUpdate() { return new Array } update(e) { } toWrappedAmount(e) { return _.default.multiply(this.multiplierJsbi, e) } toUnderlyingAmount(e) { return _.default.divide(e, this.multiplierJsbi) } getAmounts(e, t) {
        if (t) return [e, this.toWrappedAmount(e)];

        {
            const t = this.toUnderlyingAmount(e);

            return [this.toWrappedAmount(t), t]
        }
    } getQuote({ sourceMint: e, amount: t }) {
        const n = this.wrappedToken.wrappedUnderlyingMint.equals(e), [o, a] = this.getAmounts(t, n);

        return { notEnoughLiquidity: !1, inAmount: o, outAmount: a, feeAmount: i.ZERO, feeMint: e.toBase58(), feePct: 0, priceImpactPct: 0 }
    } getSwapLegAndAccounts(e) { return function ({ wrapper: e, wrappedToken: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i, deposit: a }) { return [Pe(a ? { saberAddDecimalsDeposit: {} } : { saberAddDecimalsWithdraw: {} }), m.JUPITER_PROGRAM.instruction.saberAddDecimals({ accounts: { addDecimalsProgram: m.SABER_ADD_DECIMALS_PROGRAM_ID, wrapper: e, wrapperMint: t.wrapperMint, wrapperUnderlyingTokens: t.wrappedUnderlyingTokens, owner: i, userUnderlyingTokens: a ? n : o, userWrappedTokens: a ? o : n, tokenProgram: u.TOKEN_PROGRAM_ID } }).keys] }({ wrapper: this.address, wrappedToken: this.wrappedToken, ...e, deposit: this.wrappedToken.wrappedUnderlyingMint.equals(e.sourceMint) }) } get reserveTokenMints() { return [this.wrappedToken.wrappedUnderlyingMint, this.wrappedToken.wrapperMint] } get wrapperMint() { return this.wrappedToken.wrapperMint }
} 



class Gt {
    constructor(e) { this.stableSwap = void 0, this.id = void 0, this.label = "Saber", this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.tokenReserveAmounts = void 0, this.stableSwapState = void 0, this.calculator = void 0, this.stableSwap = e, this.id = e.config.swapAccount.toBase58(), this.stableSwapState = e.state, this.calculator = new i.Stable(i.TWO, o.calculateAmpFactor(this.stableSwap.state), [i.ONE, i.ONE], new i.Fraction(this.stableSwap.state.fees.trade.numerator, this.stableSwap.state.fees.trade.denominator)) } getAccountsForUpdate() { return [this.stableSwap.config.swapAccount, e.SYSVAR_CLOCK_PUBKEY, this.stableSwap.state.tokenA.reserve, this.stableSwap.state.tokenB.reserve] } update(e) {
        const [t, n, ...a] = j(e, this.getAccountsForUpdate());

        this.stableSwapState = o.decodeSwap(t.data);

        const s = pt(n.data);

        this.calculator.setAmp(o.calculateAmpFactor(this.stableSwapState, s)), this.calculator.setTraderFee(new i.Fraction(this.stableSwapState.fees.trade.numerator, this.stableSwapState.fees.trade.denominator)), this.tokenReserveAmounts = Q(a)
    } getQuote({ sourceMint: e, destinationMint: t, amount: n }) {
        if (this.stableSwap.state.isPaused) throw new Error("Saber pool is paused");

        if (!this.tokenReserveAmounts) throw new Error(J);

        const [o, i] = this.stableSwap.state.tokenA.mint.equals(e) ? [0, 1] : [1, 0], a = this.calculator.exchange(this.tokenReserveAmounts, n, o, i), s = new C.default(this.stableSwap.state.fees.trade.asFraction.toFixed(4));

        return { notEnoughLiquidity: !1, inAmount: n, outAmount: a.expectedOutputAmount, feeAmount: a.fees, feeMint: t.toBase58(), feePct: s.toNumber(), priceImpactPct: a.priceImpact.toNumber() }
    } getSwapLegAndAccounts(e) { return function ({ stableSwap: e, sourceMint: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i }) { return [Pe({ saber: {} }), m.JUPITER_PROGRAM.instruction.saberSwap({ accounts: Ce(e, t, n, o, i) }).keys] }({ stableSwap: this.stableSwap, ...e }) } get reserveTokenMints() { return [this.stableSwap.state.tokenA.mint, this.stableSwap.state.tokenB.mint] }
} 


const Yt = d.struct([d.blob(8, "discriminator"), H("factory"), d.u8("bump"), te("index"), H("admin"), H("token0Reserves"), H("token0Mint"), H("token0Fees"), H("token1Reserves"), H("token1Mint"), H("token1Fees"), d.u8("isPaused"), H("poolMint"), te("tradeFeeKbps"), te("withdrawFeeKbps"), te("adminTradeFeeKbps"), te("adminWithdrawFeeKbps")]);



class Wt {
    constructor(e, t) {
        this.id = void 0, this.label = "Sencha", this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.poolState = void 0, this.calculator = void 0, this.tokenReserveAmounts = void 0, this.id = e.toBase58(), this.poolState = ((e, t) => {
            const n = t.owner, o = Yt.decode(t.data);

            return { programId: n, isPaused: Boolean(o.isPaused), bump: o.bump, ammId: e, token0Reserves: o.token0Reserves, token1Reserves: o.token1Reserves, token0Mint: o.token0Mint, token1Mint: o.token1Mint, token0Fees: o.token0Fees, token1Fees: o.token1Fees, poolMint: o.poolMint, tradeFeeKbps: o.tradeFeeKbps.toNumber() }
        })(e, t), this.calculator = new i.TokenSwapConstantProduct(new i.Fraction(_.default.BigInt(this.poolState.tradeFeeKbps), _.default.BigInt(1e7)), new i.Fraction(i.ZERO, i.ZERO), !1)
    } get isPaused() { return this.poolState.isPaused } getAccountsForUpdate() { return [this.poolState.token0Reserves, this.poolState.token1Reserves] } update(e) {
        const t = j(e, this.getAccountsForUpdate());

        this.tokenReserveAmounts = Q(t)
    } getQuote({ sourceMint: e, amount: t }) {
        if (this.isPaused) throw new Error("Sencha pool is paused");

        if (!this.tokenReserveAmounts) throw new Error(J);

        const n = this.poolState.token0Mint.equals(e) ? 1 : 0;

        let o = this.calculator.exchange(this.tokenReserveAmounts, t, n), i = this.poolState.tradeFeeKbps / 1e7;

        return { notEnoughLiquidity: !1, inAmount: t, outAmount: o.expectedOutputAmount, feeAmount: o.fees, feeMint: e.toBase58(), feePct: i, priceImpactPct: o.priceImpact.toNumber() }
    } getSwapLegAndAccounts(e) {
        return function ({ poolState: e, sourceMint: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i }) {
            const [a, s] = t.equals(e.token0Mint) ? [e.token0Reserves, e.token1Reserves] : [e.token1Reserves, e.token0Reserves], [r, c] = t.equals(e.token0Mint) ? [e.token0Fees, e.token1Fees] : [e.token1Fees, e.token0Fees];

            return [Pe({ sencha: {} }), m.JUPITER_PROGRAM.instruction.senchaSwap({ accounts: { swapProgram: e.programId, tokenProgram: u.TOKEN_PROGRAM_ID, swap: e.ammId, userAuthority: i, inputUserAccount: n, inputTokenAccount: a, inputFeesAccount: r, outputUserAccount: o, outputTokenAccount: s, outputFeesAccount: c } }).keys]
        }({ poolState: this.poolState, ...e })
    } get reserveTokenMints() { return [this.poolState.token0Mint, this.poolState.token1Mint] }
} 


const zt = 4e-4, Xt = 1e-4, jt = ["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS", "5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z", "EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ", "8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m", "2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"], Qt = ["B2na8Awyd7cpC59iEU43FagJAPLigr3AP3s38KM982bu"];



function* Jt(e) {
    const t = e.isBids;

    for (const { key: n, quantity: o } of e.slab.items(t)) {
        const e = _.default.BigInt(n.ushrn(64).toString());

        yield [e, _.default.BigInt(o.toString())]
    }
} 

function $t(e, t) {
    const n = e._decoded.baseLotSize;

    return n.isZero() ? new C.default(0) : function (e, t) {
        const n = new C.default(e.div(t).toString()), o = e.umod(t), i = o.gcd(t);

        return n.add(new C.default(o.div(i).toString()).div(new C.default(t.div(i).toString())))
    }(t.mul(e._decoded.quoteLotSize).mul(e._baseSplTokenMultiplier), n.mul(e._quoteSplTokenMultiplier))
} 


class Zt {
    constructor(e) { this.market = void 0, this.id = void 0, this.label = void 0, this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this._orderbooks = void 0, this.isOpenbook = void 0, this.market = e, this.id = e.address.toBase58(), this.isOpenbook = e.programId.equals(m.OPENBOOK_PROGRAM_ID), this.label = this.isOpenbook ? "Openbook" : "Serum" } get orderbooks() { return this._orderbooks } getAccountsForUpdate() { return [this.market.asksAddress, this.market.bidsAddress] } update(e) {
        const [t, o] = j(e, this.getAccountsForUpdate()), i = n.Orderbook.decode(this.market, t.data), a = n.Orderbook.decode(this.market, o.data);

        this._orderbooks = { asks: i, bids: a }
    } getQuote({ sourceMint: e, destinationMint: t, amount: n }) {
        if (!this.orderbooks) throw new Error("Failed to find orderbooks");

        const o = function ({ market: e, asks: t, bids: n, fromAmount: o, fromMint: a, toMint: s, isOpenbook: r }) {
            const u = r ? Qt.includes(e.address.toBase58()) ? Xt : zt : jt.includes(e.address.toBase58()) ? Xt : zt;

            return a.equals(e.quoteMintAddress) && s.equals(e.baseMintAddress) ? function (e, t, n, o) {
                let a = i.ZERO, s = i.ZERO, r = i.ZERO, u = i.ZERO, c = i.ZERO;

                const m = e.quoteSizeLotsToNumber(new x.default(1));

                let d = m ? _.default.BigInt(new C.default(n.toString()).div(1 + o).div(m).floor()) : i.ZERO;

                const l = _.default.BigInt(e.baseSizeLotsToNumber(new x.default(1)).toString());

                for (let [e, n] of Jt(t)) {
                    _.default.equal(s, i.ZERO) && (s = e), r = e;

                    const t = _.default.multiply(n, l), o = _.default.multiply(n, e);

                    if (c = _.default.add(c, t), _.default.greaterThanOrEqual(o, d)) {
                        const t = _.default.divide(d, e);

                        u = _.default.add(u, _.default.multiply(e, t)), a = _.default.add(a, _.default.multiply(l, t)), d = i.ZERO;

                        break
                    } u = _.default.add(u, _.default.multiply(e, n)), a = _.default.add(a, t), d = _.default.subtract(d, o)
                } let p = 0;

                if (_.default.notEqual(s, i.ZERO)) {
                    const e = new C.default(s.toString());

                    p = new C.default(r.toString()).sub(e).div(e).toNumber()
                } const h = $t(e, new x.default(s.toString())), g = $t(e, new x.default(u.toString())), A = g.mul(l.toString()).ceil(), f = g.mul(l.toString()).mul(o).ceil();

                return { side: "buy", notEnoughLiquidity: _.default.lessThanOrEqual(c, a), minimum: { in: _.default.BigInt(h.mul(l.toString()).mul(1 + o).ceil()), out: l }, inAmount: _.default.BigInt(A.add(f)), outAmount: a, feeAmount: _.default.BigInt(f), priceImpactPct: p, feePct: o }
            }(e, t, o, u) : function (e, t, n, o) {
                let a = _.default.BigInt(0), s = _.default.BigInt(0), r = _.default.BigInt(0), u = _.default.BigInt(0), c = n, m = _.default.BigInt(0);

                const d = _.default.BigInt(e.baseSizeLotsToNumber(new x.default(1))), l = _.default.BigInt(e.quoteSizeLotsToNumber(new x.default(1)));

                for (const [e, n] of Jt(t)) {
                    _.default.equal(s, i.ZERO) && (s = e), r = e;

                    const t = _.default.multiply(d, n), o = _.default.multiply(n, _.default.multiply(e, l));

                    if (u = _.default.add(u, t), _.default.greaterThanOrEqual(t, c)) {
                        const t = _.default.divide(c, d), n = _.default.multiply(t, e);

                        a = _.default.add(a, _.default.multiply(n, l)), c = _.default.subtract(c, n), m = _.default.add(m, _.default.multiply(t, d));

                        break
                    } a = _.default.add(a, o), c = _.default.subtract(c, t), m = _.default.add(m, t)
                } let p = new C.default(a.toString()).mul(1 - o).floor(), h = 0;

                const g = $t(e, new x.default(s.toString()));

                if (_.default.notEqual(s, i.ZERO)) {
                    const t = $t(e, new x.default(r.toString()));

                    h = g.minus(t).div(g).toNumber()
                } return { side: "sell", notEnoughLiquidity: _.default.greaterThan(_.default.BigInt(n), u), minimum: { in: d, out: _.default.BigInt(g.mul(_.default.toNumber(d)).mul(1 - o).floor().toString()) }, inAmount: m, outAmount: _.default.BigInt(p), feeAmount: _.default.BigInt(new C.default(a.toString()).mul(o).round()), priceImpactPct: h, feePct: o }
            }(e, n, o, u)
        }({ market: this.market, asks: this.orderbooks.asks, bids: this.orderbooks.bids, fromMint: e, toMint: t, fromAmount: n, isOpenbook: this.isOpenbook });

        return { notEnoughLiquidity: o.notEnoughLiquidity, minInAmount: o.minimum.in, minOutAmount: o.minimum.out, inAmount: o.inAmount, outAmount: o.outAmount, feeAmount: o.feeAmount, feeMint: this.market.quoteMintAddress.toBase58(), feePct: o.feePct, priceImpactPct: o.priceImpactPct }
    } getSwapLegAndAccounts(e) {
        var t;

        if (!e.openOrdersAddress) throw new Error("Missing open orders");

        return function ({ market: e, sourceMint: t, openOrdersAddress: n, userSourceTokenAccount: o, userDestinationTokenAccount: i, userTransferAuthority: a, referrer: s, isOpenbook: r }) {
            const { side: u, coinWallet: c, pcWallet: d } = t.equals(e.baseMintAddress) ? { side: ce.Ask, coinWallet: o, pcWallet: i } : { side: ce.Bid, coinWallet: i, pcWallet: o };

            return [Pe(r ? Se(u) : me(u)), m.JUPITER_PROGRAM.instruction.serumSwap({ accounts: xe(e, n, o, c, d, a), remainingAccounts: s ? [{ pubkey: s, isSigner: !1, isWritable: !0 }] : [Ee] }).keys]
        }({ market: this.market, openOrdersAddress: e.openOrdersAddress, referrer: null == e || null === (t = e.quoteMintToReferrer) || void 0 === t ? void 0 : t.get(this.market.quoteMintAddress.toBase58()), isOpenbook: this.isOpenbook, ...e })
    } get reserveTokenMints() { return [this.market.baseMintAddress, this.market.quoteMintAddress] }
} 

Zt.getL2 = Jt;



const Ht = d.struct([d.u8("version"), d.u8("isInitialized"), d.u8("bumpSeed"), H("tokenProgramId"), H("tokenAccountA"), H("tokenAccountB"), H("tokenPool"), H("mintA"), H("mintB"), H("feeAccount"), te("tradeFeeNumerator"), te("tradeFeeDenominator"), te("ownerTradeFeeNumerator"), te("ownerTradeFeeDenominator"), te("ownerWithdrawFeeNumerator"), te("ownerWithdrawFeeDenominator"), te("hostFeeNumerator"), te("hostFeeDenominator"), d.u8("curveType"), d.blob(32, "curveParameters")]), en = d.struct([d.u8("version"), d.u8("isInitialized"), d.u8("bumpSeed"), H("tokenProgramId"), H("tokenAccountA"), H("tokenAccountB"), H("tokenPool"), H("mintA"), H("mintB"), H("feeAccount"), te("tradeFeeNumerator"), te("tradeFeeDenominator"), te("ownerTradeFeeNumerator"), te("ownerTradeFeeDenominator"), te("ownerWithdrawFeeNumerator"), te("ownerWithdrawFeeDenominator"), d.u8("curveType"), d.blob(32, "curveParameters"), d.u8("poolNonce")]);

var tn;

!function (e) { e[e.ConstantProduct = 0] = "ConstantProduct", e[e.Stable = 2] = "Stable" }(tn || (tn = {}));



class nn {
    constructor(t, n, o) {
        if (this.label = void 0, this.id = void 0, this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.tokenSwapState = void 0, this.curveType = void 0, this.feePct = void 0, this.tokenReserveAmounts = void 0, this.calculator = void 0, this.label = o, this.id = t.toBase58(), this.tokenSwapState = function (t, n) {
            const o = n.owner, i = o.equals(m.STEP_TOKEN_SWAP_PROGRAM_ID) ? en.decode(n.data) : Ht.decode(n.data);

            if (!i.isInitialized) throw new Error("Invalid token swap state");

            const a = ie([t.toBuffer(), Buffer.from([i.bumpSeed])], o), s = new e.PublicKey(i.tokenPool), r = new e.PublicKey(i.feeAccount), u = new e.PublicKey(i.tokenAccountA), c = new e.PublicKey(i.tokenAccountB), d = new e.PublicKey(i.mintA), l = new e.PublicKey(i.mintB);

            return { address: t, programId: o, tokenProgramId: new e.PublicKey(i.tokenProgramId), poolToken: s, feeAccount: r, authority: a, tokenAccountA: u, tokenAccountB: c, mintA: d, mintB: l, tradeFeeNumerator: i.tradeFeeNumerator, tradeFeeDenominator: i.tradeFeeDenominator, ownerTradeFeeNumerator: i.ownerTradeFeeNumerator, ownerTradeFeeDenominator: i.ownerTradeFeeDenominator, ownerWithdrawFeeNumerator: i.ownerWithdrawFeeNumerator, ownerWithdrawFeeDenominator: i.ownerWithdrawFeeDenominator, curveType: i.curveType, curveParameters: i.curveParameters, poolNonce: "poolNonce" in i ? i.poolNonce : void 0 }
        }(t, n), this.curveType = this.tokenSwapState.curveType, !(this.curveType in tn)) throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);

        const a = nn.getFeeFraction(this.tokenSwapState.tradeFeeNumerator, this.tokenSwapState.tradeFeeDenominator), s = nn.getFeeFraction(this.tokenSwapState.ownerTradeFeeNumerator, this.tokenSwapState.ownerTradeFeeDenominator);

        this.calculator = this.tokenSwapState.curveType === tn.ConstantProduct ? new i.TokenSwapConstantProduct(a, s) : new i.TokenSwapStable(_.default.BigInt(this.tokenSwapState.curveParameters[0]), a, s), this.feePct = nn.getFeeDecimal(this.tokenSwapState.tradeFeeNumerator, this.tokenSwapState.tradeFeeDenominator).add(nn.getFeeDecimal(this.tokenSwapState.ownerTradeFeeNumerator, this.tokenSwapState.ownerTradeFeeDenominator)).toNumber()
    } static getFeeFraction(e, t) { return new i.Fraction(_.default.BigInt(e.toString()), _.default.BigInt(t.toString())) } static getFeeDecimal(e, t) { return e.eq(new u.u64(0)) ? new C.default(0) : new C.default(e.toString()).div(t.toString()) } getAccountsForUpdate() { return [this.tokenSwapState.tokenAccountA, this.tokenSwapState.tokenAccountB] } update(e) {
        const t = j(e, this.getAccountsForUpdate());

        this.tokenReserveAmounts = Q(t)
    } getQuote({ sourceMint: e, amount: t }) {
        if (!this.tokenReserveAmounts) throw new Error(J);

        const n = this.reserveTokenMints[0].equals(e) ? 1 : 0, o = this.calculator.exchange(this.tokenReserveAmounts, t, n);

        return { notEnoughLiquidity: !1, inAmount: t, outAmount: o.expectedOutputAmount, feeAmount: o.fees, feeMint: e.toBase58(), feePct: this.feePct, priceImpactPct: o.priceImpact.toNumber() }
    } getSwapLegAndAccounts(e) {
        return function ({ tokenSwapState: e, sourceMint: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i, isStep: a }) {
            const [s, r] = t.equals(e.mintA) ? [e.tokenAccountA, e.tokenAccountB] : [e.tokenAccountB, e.tokenAccountA];

            return [Pe(a ? { step: {} } : { tokenSwap: {} }), (a ? m.JUPITER_PROGRAM.instruction.stepSwap : m.JUPITER_PROGRAM.instruction.tokenSwap)({ accounts: { tokenSwapProgram: e.programId, tokenProgram: u.TOKEN_PROGRAM_ID, swap: e.address, authority: e.authority, userTransferAuthority: i, source: n, swapSource: s, swapDestination: r, destination: o, poolMint: e.poolToken, poolFee: e.feeAccount } }).keys]
        }({ tokenSwapState: this.tokenSwapState, ...e, isStep: this.tokenSwapState.programId.equals(m.STEP_TOKEN_SWAP_PROGRAM_ID) })
    } get reserveTokenMints() { return [this.tokenSwapState.mintA, this.tokenSwapState.mintB] }
} 


function on(e) { return e.reduce(((t, n) => (e.forEach((e => { n !== e && t.push([n, e]) })), t)), new Array) } const an = _.default.BigInt(100);



class sn {
    constructor(e, t, n) { this.firstAmm = void 0, this.secondAmm = void 0, this.reserveTokenMints = void 0, this.market = void 0, this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.portion1 = 0, this.portion2 = 0, this.firstAmm = e, this.secondAmm = t, this.reserveTokenMints = n, this.market = e instanceof Zt ? e.market : t instanceof Zt ? t.market : null } static getAmmIdsFromSplitTradeAmmId(e) {
        const t = e.split("-");

        return t.length > 1 ? t : []
    } static create(e, t) {
        if (!function (e, t) { return !Y(K, e.label, t.label) }(e, t)) return;

        const n = on(e.reserveTokenMints), o = on(t.reserveTokenMints);

        for (const i of n) for (const n of o) if (i.every(((e, t) => e.equals(n[t])))) return new sn(e, t, i)
    } setPortions(e, t) {
        if (e + t !== 100) throw new Error("Split trade portions must sum to 100");

        this.portion1 = e, this.portion2 = t
    } get id() { return `${this.firstAmm.id}-${this.secondAmm.id}` } get label() { return [{ label: this.firstAmm.label, portion: this.portion1 }, { label: this.secondAmm.label, portion: this.portion2 }].sort(((e, t) => t.portion - e.portion)).map((({ label: e, portion: t }) => `${e} (${t}%)`)).join(" + ") } getAccountsForUpdate() { return [] } update(e) { } getQuote(e) {
        const t = e.sourceMint.toBase58(), n = e.amount;

        let o = { outAmount: i.ZERO, portion: 0, firstQuote: void 0, secondQuote: void 0 };

        for (let t = 100;

            t -= 5;

            t > 0) {
                const i = _.default.divide(_.default.multiply(n, _.default.BigInt(t)), an), a = _.default.subtract(n, i), s = this.firstAmm.getQuote({ ...e, amount: i }), r = this.secondAmm.getQuote({ ...e, amount: a }), u = _.default.add(s.outAmount, r.outAmount);

            if (_.default.lessThan(u, o.outAmount)) break;

            o = { outAmount: u, portion: t, firstQuote: s, secondQuote: r }
        } if (!o.firstQuote || !o.secondQuote) throw new Error("Unreachable: There was no better solution than getting 0 outAmount");

        const { outAmount: a, portion: s, firstQuote: r, secondQuote: u } = o, c = s, m = 100 - c;

        this.portion1 = c, this.portion2 = m;

        let d = { amount: r.feeAmount, mint: r.feeMint }, l = { amount: u.feeAmount, mint: u.feeMint };

        d.mint !== l.mint && (d.mint !== t && (d = { amount: _.default.divide(_.default.divide(_.default.multiply(d.amount, _.default.multiply(n, _.default.BigInt(c))), an), o.outAmount), mint: t }), l.mint !== t && (l = { amount: _.default.divide(_.default.divide(_.default.multiply(_.default.multiply(l.amount, n), _.default.BigInt(m)), an), o.outAmount), mint: t }));

        const p = (c * r.feePct + m * u.feePct) / 100, h = (c * r.priceImpactPct + m * u.priceImpactPct) / 100;

        return { notEnoughLiquidity: !1, inAmount: e.amount, outAmount: a, feeAmount: _.default.add(d.amount, l.amount), feeMint: d.mint, feePct: p, priceImpactPct: h }
    } getSwapLegAndAccounts(e) {
        let [t, n] = this.firstAmm.getSwapLegAndAccounts(e), [o, i] = this.secondAmm.getSwapLegAndAccounts(e), a = [Te(this.portion1, t), Te(this.portion2, o)], s = [...n, ...i];

        return [we(a), s]
    }
} 

function rn(e, t) {
    const n = b.ParsableWhirlpool.parse(t);

    if (!n) throw new Error(`Failed to parse whirlpool ${e.toBase58()}`);

    return n
} 

function un(e, t) {
    const n = b.ParsableTickArray.parse(t);

    if (!n) throw new Error(`Failed to parse tick array ${e.toBase58()}`);

    return n
} 


class cn {
    constructor(t, n) { this.address = void 0, this.id = void 0, this.label = "Orca (Whirlpools)", this.shouldPrefetch = !0, this.exactOutputSupported = !0, this.hasDynamicAccounts = !0, this.whirlpoolData = void 0, this.tickArrays = { aToB: [], bToA: [] }, this.tickPks = void 0, this.oracle = void 0, this.feePct = void 0, this.address = t, this.id = t.toBase58(), this.whirlpoolData = rn(t, n.data), this.oracle = e.PublicKey.findProgramAddressSync([Buffer.from("oracle"), t.toBuffer()], m.WHIRLPOOL_PROGRAM_ID)[0], this.feePct = new C.default(this.whirlpoolData.feeRate).div(1e6), this.tickPks = this.getTickArrayPks() } getTickArrayPks() {
        const e = { aToB: [], bToA: [] };

        return [!0, !1].forEach((t => { e[t ? "aToB" : "bToA"].push(...b.SwapUtils.getTickArrayPublicKeys(this.whirlpoolData.tickCurrentIndex, this.whirlpoolData.tickSpacing, t, m.WHIRLPOOL_PROGRAM_ID, this.address)) })), e
    } getAccountsForUpdate() { return [this.address, ...this.tickPks.aToB, ...this.tickPks.bToA] } update(e) {
        const t = e.get(this.address.toBase58());

        if (!t) throw new Error(`Missing ${this.address.toBase58()}`);

        this.whirlpoolData = rn(this.address, t.data), this.tickPks = this.getTickArrayPks();

        const n = { aToB: [], bToA: [] };
        [!0, !1].forEach((t => {
            const o = t ? "aToB" : "bToA";

            for (const t of this.tickPks[o]) {
                const i = t.toBase58(), a = e.get(i);

                if (!a) continue;

                const s = un(t, a.data);

                n[o].push({ address: t, data: s })
            }
        })), this.tickArrays = n
    } getQuote({ sourceMint: e, amount: t, swapMode: n }) {
        const o = !!e.equals(this.whirlpoolData.tokenMintA), i = n === exports.SwapMode.ExactIn, a = b.swapQuoteWithParams({ amountSpecifiedIsInput: i, aToB: o, otherAmountThreshold: b.SwapUtils.getDefaultOtherAmountThreshold(i), sqrtPriceLimit: b.SwapUtils.getDefaultSqrtPriceLimit(o), tickArrays: this.tickArrays[o ? "aToB" : "bToA"], tokenAmount: new x.default(t.toString()), whirlpoolData: this.whirlpoolData }), s = _.default.BigInt(a.estimatedAmountIn.toString()), r = _.default.BigInt(a.estimatedAmountOut.toString()), u = _.default.BigInt(a.estimatedFeeAmount.toString()), c = a.aToB ? new C.default(a.estimatedAmountOut.toString()).div(a.estimatedAmountIn.toString()) : new C.default(a.estimatedAmountIn.toString()).div(a.estimatedAmountOut.toString()), m = (d = this.whirlpoolData.sqrtPrice, new C.default(d.toString()).mul(C.default.pow(2, -64))).pow(2);

        var d;

        const l = m.minus(c).div(m).abs().toNumber();

        return { notEnoughLiquidity: !1, inAmount: s, outAmount: r, feeAmount: u, feeMint: e.toBase58(), feePct: this.feePct.toNumber(), priceImpactPct: Number(l) }
    } getSwapLegAndAccounts(e) {
        const t = e.sourceMint.equals(this.whirlpoolData.tokenMintA), n = e.swapMode === exports.SwapMode.ExactIn, { tickArray0: o, tickArray1: i, tickArray2: a } = b.swapQuoteWithParams({ amountSpecifiedIsInput: n, aToB: t, otherAmountThreshold: b.SwapUtils.getDefaultOtherAmountThreshold(n), sqrtPriceLimit: b.SwapUtils.getDefaultSqrtPriceLimit(t), tickArrays: this.tickArrays[t ? "aToB" : "bToA"], tokenAmount: new x.default(e.amount.toString()), whirlpoolData: this.whirlpoolData });

        return function ({ additionalArgs: e, userSourceTokenAccount: t, userDestinationTokenAccount: n, userTransferAuthority: o }) {
            const [i, a] = e.aToB ? [t, n] : [n, t];

            return [Pe(he(e.aToB)), m.JUPITER_PROGRAM.instruction.whirlpoolSwap({ accounts: { swapProgram: m.WHIRLPOOL_PROGRAM_ID, tokenProgram: u.TOKEN_PROGRAM_ID, tokenAuthority: o, whirlpool: e.whirlpool, tokenOwnerAccountA: i, tokenVaultA: e.tokenVaultA, tokenOwnerAccountB: a, tokenVaultB: e.tokenVaultB, tickArray0: e.tickArray0, tickArray1: e.tickArray1, tickArray2: e.tickArray2, oracle: e.oracle } }).keys]
        }({ additionalArgs: { aToB: t, whirlpool: this.address, tickArray0: o, tickArray1: i, tickArray2: a, oracle: this.oracle, ...this.whirlpoolData }, ...e })
    } createExactOutSwapInstruction(e) {
        const t = e.sourceMint.equals(this.whirlpoolData.tokenMintA), n = e.swapMode === exports.SwapMode.ExactIn, { tickArray0: o, tickArray1: i, tickArray2: a } = b.swapQuoteWithParams({ amountSpecifiedIsInput: n, aToB: t, otherAmountThreshold: b.SwapUtils.getDefaultOtherAmountThreshold(n), sqrtPriceLimit: b.SwapUtils.getDefaultSqrtPriceLimit(t), tickArrays: this.tickArrays[t ? "aToB" : "bToA"], tokenAmount: new x.default(e.amount.toString()), whirlpoolData: this.whirlpoolData });

        return function ({ additionalArgs: e, userSourceTokenAccount: t, userDestinationTokenAccount: n, userTransferAuthority: o, outAmount: i, inAmount: a, slippageBps: s, platformFee: r, overflowFeeAccount: c }) {
            var d;

            const [l, p] = e.aToB ? [t, n] : [n, t];

            return m.JUPITER_PROGRAM.instruction.whirlpoolSwapExactOutput(i, { amount: a, slippageBps: s }, e.aToB, null !== (d = null == r ? void 0 : r.feeBps) && void 0 !== d ? d : 0, { accounts: { swapProgram: m.WHIRLPOOL_PROGRAM_ID, tokenProgram: u.TOKEN_PROGRAM_ID, tokenAuthority: o, whirlpool: e.whirlpool, tokenOwnerAccountA: l, tokenVaultA: e.tokenVaultA, tokenOwnerAccountB: p, tokenVaultB: e.tokenVaultB, tickArray0: e.tickArray0, tickArray1: e.tickArray1, tickArray2: e.tickArray2, oracle: e.oracle }, remainingAccounts: Ne(null == r ? void 0 : r.feeAccount, c) })
        }({ additionalArgs: { aToB: t, whirlpool: this.address, tickArray0: o, tickArray1: i, tickArray2: a, oracle: this.oracle, ...this.whirlpoolData }, ...e, outAmount: new x.default(e.amount.toString()), inAmount: new x.default(e.inAmount.toString()) })
    } get reserveTokenMints() { return [this.whirlpoolData.tokenMintA, this.whirlpoolData.tokenMintB] }
} 


class mn {
    constructor(t, n, o) { this.address = void 0, this.id = void 0, this.label = "Dradex", this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.state = void 0, this.orderBookState = void 0, this.quoteCalculator = void 0, this.marketUser = void 0, this.address = t, this.id = t.toBase58(), this.state = v.dexCoder.accounts.decode("market", n.data), this.marketUser = new e.PublicKey(o.marketUser) } getAccountsForUpdate() { return [this.address, ...this.reserveTokenMints, this.state.orderBook.bids, this.state.orderBook.asks] } update(e) {
        const t = e.get(this.id), n = e.get(this.state.orderBook.bids.toString()), o = e.get(this.state.orderBook.asks.toString()), i = this.reserveTokenMints.map((t => e.get(t.toString())));

        if (!t || !n || !o || i.find((e => !e))) throw new Error(`One of the required accounts is missing: ${this.address.toBase58()}`);

        if (i.length !== this.reserveTokenMints.length) throw new Error(`Missing mint info: ${this.address.toBase58()}`);

        this.state = v.dexCoder.accounts.decode("market", t.data);

        const a = this.reserveTokenMints.map(((e, t) => r.deserializeMint(i[t].data, e)));

        this.orderBookState = { bids: R.OrderBook.decode(n.data).items, asks: R.OrderBook.decode(o.data).items }, this.quoteCalculator = new v.QuoteCalculator(this.state, this.orderBookState, a)
    } getQuote(e) {
        if (!this.quoteCalculator) throw new Error(`Quote calculator is not initialized: ${this.address.toBase58()}`);

        const t = this.quoteCalculator.getQuote(e);

        return { ...t, priceImpactPct: t.priceImpactPct / 100 }
    } getSwapLegAndAccounts(t) {
        var n;

        return function ({ additionalArgs: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i, sourceMint: a }) {
            const { side: s, t0User: r, t1User: c } = a.equals(t.t0) ? { side: ce.Ask, t0User: n, t1User: o } : { side: ce.Bid, t0User: o, t1User: n };

            return [Pe(Ae(s)), m.JUPITER_PROGRAM.instruction.dradexSwap({ accounts: { swapProgram: m.DRADEX_PROGRAM_ID, pair: t.pair, market: t.market, eventQueue: t.eventQueue, dexUser: m.DRADEX_DEX_USER, marketUser: t.marketUser, bids: t.bids, asks: t.asks, t0Vault: t.t0Vault, t1Vault: t.t1Vault, t0User: r, t1User: c, master: m.DRADEX_MASTER_ID, signer: i, systemProgram: e.SystemProgram.programId, tokenProgram: u.TOKEN_PROGRAM_ID, logger: m.DRADEX_LOGGER_PROGRAM_ID }, remainingAccounts: t.referrer ? [{ pubkey: t.referrer, isSigner: !1, isWritable: !0 }] : [Ee] }).keys]
        }({ additionalArgs: { pair: this.state.pair, market: this.address, eventQueue: this.state.eventQueue, marketUser: this.marketUser, bids: this.state.orderBook.bids, asks: this.state.orderBook.asks, t0: this.state.t0, t1: this.state.t1, t0Vault: this.state.t0Vault, t1Vault: this.state.t1Vault, referrer: null === (n = t.quoteMintToReferrer) || void 0 === n ? void 0 : n.get(t.destinationMint.toBase58()) }, ...t })
    } get reserveTokenMints() { return [this.state.t0, this.state.t1] }
} 


class dn {
    constructor(e, t) { this.address = void 0, this.label = "Raydium CLMM", this.id = void 0, this.reserveTokenMints = void 0, this.hasDynamicAccounts = !0, this.shouldPrefetch = !0, this.exactOutputSupported = !0, this.programId = void 0, this.poolState = void 0, this.coder = void 0, this.tickArrayPks = void 0, this.tickArrayCache = {}, this.ammV3PoolInfo = void 0, this.address = e, this.id = e.toBase58(), this.address = e, this.coder = new p.BorshAccountsCoder(B.IDL), this.poolState = this.coder.decode("poolState", t.data), this.reserveTokenMints = [this.poolState.tokenMint0, this.poolState.tokenMint1], this.programId = m.RAYDIUM_CLMM_PROGRAM_ID, this.tickArrayPks = B.Amm.getTickArrayPks(this.address, this.poolState, this.programId) } getAccountsForUpdate() { return [this.address, this.poolState.ammConfig, ...this.tickArrayPks] } update(e) {
        const t = e.get(this.id);

        if (!t) throw new Error("Missing poolStateAccountInfo");

        const n = e.get(this.poolState.ammConfig.toBase58());

        if (!n) throw new Error("Missing ammConfigAccoutnInfo");

        this.poolState = this.coder.decode("poolState", t.data);

        const o = this.coder.decode("ammConfig", n.data);

        this.tickArrayPks = B.Amm.getTickArrayPks(this.address, this.poolState, this.programId);

        const i = {};

        for (const t of this.tickArrayPks) {
            const n = e.get(t.toBase58());

            if (!n) continue;

            const o = this.coder.decode("tickArrayState", n.data);

            i[o.startTickIndex] = { ...o, address: t }
        } this.tickArrayCache = i, this.ammV3PoolInfo = B.Amm.formatPoolInfo({ address: this.address, poolState: this.poolState, ammConfig: o, programId: this.programId })
    } getQuote(e) {
        if (0 !== this.poolState.status) throw new Error("Pool is not swapable");

        if (!this.ammV3PoolInfo) throw new Error("Missing ammV3PoolInfo");

        if (e.swapMode === exports.SwapMode.ExactIn) {
            const { amountOut: t, fee: n, priceImpact: o } = B.Amm.computeAmountOut({ poolInfo: this.ammV3PoolInfo, tickArrayCache: this.tickArrayCache, baseMint: e.sourceMint, amountIn: new x.default(e.amount.toString()), slippage: 0 });

            return { notEnoughLiquidity: !1, inAmount: e.amount, outAmount: _.default.BigInt(t.toString()), feeAmount: _.default.BigInt(n.toString()), feeMint: e.sourceMint.toString(), feePct: this.ammV3PoolInfo.ammConfig.tradeFeeRate / 10 ** 6, priceImpactPct: o }
        } {
            const { amountIn: t, fee: n, priceImpact: o } = B.Amm.computeAmountIn({ poolInfo: this.ammV3PoolInfo, tickArrayCache: this.tickArrayCache, baseMint: e.destinationMint, amountOut: new x.default(e.amount.toString()), slippage: 0 });

            return { notEnoughLiquidity: !1, inAmount: _.default.BigInt(t.toString()), outAmount: e.amount, feeAmount: _.default.BigInt(n.toString()), feeMint: e.sourceMint.toString(), feePct: this.ammV3PoolInfo.ammConfig.tradeFeeRate / 10 ** 6, priceImpactPct: o }
        }
    } getSwapLegAndAccounts(e) {
        if (!this.ammV3PoolInfo) throw new Error("Missing ammV3PoolInfo");

        const { remainingAccounts: t } = B.Amm.computeAmountOut({ poolInfo: this.ammV3PoolInfo, tickArrayCache: this.tickArrayCache, baseMint: e.sourceMint, amountIn: new x.default(e.amount.toString()), slippage: 0 }), [n, o] = e.sourceMint.equals(this.poolState.tokenMint0) ? [this.poolState.tokenVault0, this.poolState.tokenVault1] : [this.poolState.tokenVault1, this.poolState.tokenVault0], i = t.shift();

        if (!i) throw new Error("Missing at least one tick array");

        return function ({ additionalArgs: e, userSourceTokenAccount: t, userDestinationTokenAccount: n, userTransferAuthority: o }) {
            const i = e.remainingAccounts.map((e => ({ pubkey: e, isWritable: !0, isSigner: !1 })));

            return i.push(Ee), [Pe({ raydiumClmm: {} }), m.JUPITER_PROGRAM.instruction.raydiumClmmSwap({ accounts: { swapProgram: m.RAYDIUM_CLMM_PROGRAM_ID, payer: o, ammConfig: e.ammConfig, poolState: e.poolState, inputTokenAccount: t, outputTokenAccount: n, inputVault: e.inputVault, outputVault: e.outputVault, observationState: e.observationState, tokenProgram: u.TOKEN_PROGRAM_ID, tickArray: e.tickArray }, remainingAccounts: i }).keys]
        }({ additionalArgs: { poolState: this.address, inputVault: n, outputVault: o, observationState: this.poolState.observationKey, tickArray: i, remainingAccounts: t, ...this.poolState }, ...e })
    } createExactOutSwapInstruction(e) {
        if (!this.ammV3PoolInfo) throw new Error("Missing ammV3PoolInfo");

        const { remainingAccounts: t } = B.Amm.computeAmountIn({ poolInfo: this.ammV3PoolInfo, tickArrayCache: this.tickArrayCache, baseMint: e.destinationMint, amountOut: new x.default(e.amount.toString()), slippage: 0 }), [n, o] = e.sourceMint.equals(this.poolState.tokenMint0) ? [this.poolState.tokenVault0, this.poolState.tokenVault1] : [this.poolState.tokenVault1, this.poolState.tokenVault0], i = t.shift();

        if (!i) throw new Error("Missing at least one tick array");

        return function ({ additionalArgs: e, userSourceTokenAccount: t, userDestinationTokenAccount: n, userTransferAuthority: o, outAmount: i, inAmount: a, slippageBps: s, platformFee: r, overflowFeeAccount: c }) {
            var d;

            const l = e.remainingAccounts.map((e => ({ pubkey: e, isWritable: !0, isSigner: !1 })));

            return l.push(Ee), l.push(...Ne(null == r ? void 0 : r.feeAccount, c)), m.JUPITER_PROGRAM.instruction.raydiumClmmSwapExactOutput(i, { amount: a, slippageBps: s }, null !== (d = null == r ? void 0 : r.feeBps) && void 0 !== d ? d : 0, { accounts: { swapProgram: m.RAYDIUM_CLMM_PROGRAM_ID, payer: o, ammConfig: e.ammConfig, poolState: e.poolState, inputTokenAccount: t, outputTokenAccount: n, inputVault: e.inputVault, outputVault: e.outputVault, observationState: e.observationState, tokenProgram: u.TOKEN_PROGRAM_ID, tickArray: e.tickArray }, remainingAccounts: l })
        }({ additionalArgs: { poolState: this.address, inputVault: n, outputVault: o, observationState: this.poolState.observationKey, tickArray: i, remainingAccounts: t, ...this.poolState }, ...e, outAmount: new x.default(e.amount.toString()), inAmount: new x.default(e.inAmount.toString()) })
    }
} 



const ln = new p.Program({ version: "0.1.1", name: "marcopolo", instructions: [{ name: "createPool", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !0 }, { name: "poolYAccount", isMut: !0, isSigner: !0 }, { name: "adminXAccount", isMut: !0, isSigner: !1 }, { name: "adminYAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "projectOwner", isMut: !1, isSigner: !1 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [{ name: "lpFee", type: { defined: "FixedPoint" } }, { name: "buybackFee", type: { defined: "FixedPoint" } }, { name: "projectFee", type: { defined: "FixedPoint" } }, { name: "mercantiFee", type: { defined: "FixedPoint" } }, { name: "initialTokenX", type: { defined: "Token" } }, { name: "initialTokenY", type: { defined: "Token" } }, { name: "bump", type: "u8" }] }, { name: "createProvider", accounts: [{ name: "pool", isMut: !0, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "provider", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "ownerXAccount", isMut: !0, isSigner: !1 }, { name: "ownerYAccount", isMut: !0, isSigner: !1 }, { name: "owner", isMut: !0, isSigner: !0 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [{ name: "tokenXAmount", type: { defined: "Token" } }, { name: "tokenYAmount", type: { defined: "Token" } }, { name: "bump", type: "u8" }] }, { name: "createState", accounts: [{ name: "state", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }], args: [{ name: "nonce", type: "u8" }] }, { name: "addTokens", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "provider", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarco", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirst", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecond", isMut: !0, isSigner: !1 }, { name: "ownerXAccount", isMut: !0, isSigner: !1 }, { name: "ownerYAccount", isMut: !0, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "ownerMarcoAccount", isMut: !0, isSigner: !1 }, { name: "ownerProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "ownerProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "owner", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "associatedTokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [{ name: "deltaX", type: { defined: "Token" } }, { name: "deltaY", type: { defined: "Token" } }] }, { name: "withdrawBuyback", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "buybackXAccount", isMut: !0, isSigner: !1 }, { name: "buybackYAccount", isMut: !0, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "associatedTokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [] }, { name: "swap", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "swapperXAccount", isMut: !0, isSigner: !1 }, { name: "swapperYAccount", isMut: !0, isSigner: !1 }, { name: "swapper", isMut: !0, isSigner: !0 }, { name: "referrerXAccount", isMut: !0, isSigner: !1 }, { name: "referrerYAccount", isMut: !0, isSigner: !1 }, { name: "referrer", isMut: !0, isSigner: !1 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "associatedTokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [{ name: "deltaIn", type: { defined: "Token" } }, { name: "priceLimit", type: { defined: "FixedPoint" } }, { name: "xToY", type: "bool" }] }, { name: "withdrawShares", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "provider", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarco", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirst", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecond", isMut: !0, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "ownerXAccount", isMut: !0, isSigner: !1 }, { name: "ownerYAccount", isMut: !0, isSigner: !1 }, { name: "ownerMarcoAccount", isMut: !0, isSigner: !1 }, { name: "ownerProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "ownerProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "owner", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "associatedTokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [{ name: "shares", type: { defined: "Token" } }] }, { name: "withdrawLpFee", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !1, isSigner: !1 }, { name: "provider", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "ownerXAccount", isMut: !0, isSigner: !1 }, { name: "ownerYAccount", isMut: !0, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "owner", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "associatedTokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [] }, { name: "withdrawProjectFee", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "projectOwnerXAccount", isMut: !0, isSigner: !1 }, { name: "projectOwnerYAccount", isMut: !0, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "projectOwner", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "associatedTokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [] }, { name: "createFarm", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !1, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarco", isMut: !1, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !0 }, { name: "adminMarcoAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [{ name: "supply", type: { defined: "Token" } }, { name: "duration", type: "u64" }, { name: "bump", type: "u8" }] }, { name: "createDualFarm", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !1, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarco", isMut: !1, isSigner: !1 }, { name: "tokenProjectFirst", isMut: !1, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !0 }, { name: "tokenProjectFirstAccount", isMut: !0, isSigner: !0 }, { name: "adminMarcoAccount", isMut: !0, isSigner: !1 }, { name: "adminProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [{ name: "supplyMarco", type: { defined: "Token" } }, { name: "supplyProjectFirst", type: { defined: "Token" } }, { name: "duration", type: "u64" }, { name: "bump", type: "u8" }] }, { name: "createTripleFarm", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !1, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarco", isMut: !1, isSigner: !1 }, { name: "tokenProjectFirst", isMut: !1, isSigner: !1 }, { name: "tokenProjectSecond", isMut: !1, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !0 }, { name: "tokenProjectFirstAccount", isMut: !0, isSigner: !0 }, { name: "tokenProjectSecondAccount", isMut: !0, isSigner: !0 }, { name: "adminMarcoAccount", isMut: !0, isSigner: !1 }, { name: "adminProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "adminProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [{ name: "supplyMarco", type: { defined: "Token" } }, { name: "supplyProjectFirst", type: { defined: "Token" } }, { name: "supplyProjectSecond", type: { defined: "Token" } }, { name: "duration", type: "u64" }, { name: "bump", type: "u8" }] }, { name: "withdrawRewards", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !1, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "provider", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarco", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirst", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecond", isMut: !0, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "ownerMarcoAccount", isMut: !0, isSigner: !1 }, { name: "ownerProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "ownerProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "owner", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "associatedTokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [] }, { name: "closePool", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "buybackXAccount", isMut: !0, isSigner: !1 }, { name: "buybackYAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }], args: [] }, { name: "withdrawMercantiFee", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "mercantiXAccount", isMut: !0, isSigner: !1 }, { name: "mercantiYAccount", isMut: !0, isSigner: !1 }, { name: "poolXAccount", isMut: !0, isSigner: !1 }, { name: "poolYAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }], args: [] }, { name: "addSupply", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "adminMarcoAccount", isMut: !0, isSigner: !1 }, { name: "adminProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "adminProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !1, isSigner: !0 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }], args: [{ name: "supplyMarco", type: { defined: "Token" } }, { name: "supplyProjectFirst", type: { defined: "Token" } }, { name: "supplyProjectSecond", type: { defined: "Token" } }, { name: "duration", type: "u64" }] }, { name: "updateFees", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }], args: [{ name: "newBuybackFee", type: { defined: "FixedPoint" } }, { name: "newProjectFee", type: { defined: "FixedPoint" } }, { name: "newProviderFee", type: { defined: "FixedPoint" } }, { name: "newMercantiFee", type: { defined: "FixedPoint" } }] }, { name: "resetFarm", accounts: [{ name: "state", isMut: !1, isSigner: !1 }, { name: "pool", isMut: !1, isSigner: !1 }, { name: "farm", isMut: !0, isSigner: !1 }, { name: "tokenX", isMut: !1, isSigner: !1 }, { name: "tokenY", isMut: !1, isSigner: !1 }, { name: "tokenMarco", isMut: !1, isSigner: !1 }, { name: "tokenMarcoAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "tokenProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "adminMarcoAccount", isMut: !0, isSigner: !1 }, { name: "adminProjectFirstAccount", isMut: !0, isSigner: !1 }, { name: "adminProjectSecondAccount", isMut: !0, isSigner: !1 }, { name: "admin", isMut: !0, isSigner: !0 }, { name: "programAuthority", isMut: !1, isSigner: !1 }, { name: "systemProgram", isMut: !1, isSigner: !1 }, { name: "tokenProgram", isMut: !1, isSigner: !1 }, { name: "rent", isMut: !1, isSigner: !1 }], args: [] }], accounts: [{ name: "farm", type: { kind: "struct", fields: [{ name: "pool", type: "publicKey" }, { name: "tokens", type: { array: ["publicKey", 3] } }, { name: "tokenAccounts", type: { array: ["publicKey", 3] } }, { name: "supply", type: { array: [{ defined: "Token" }, 3] } }, { name: "supplyLeft", type: { array: [{ defined: "Token" }, 3] } }, { name: "accumulatedSecondsPerShare", type: { defined: "FixedPoint" } }, { name: "offsetSecondsPerShare", type: { defined: "FixedPoint" } }, { name: "startTime", type: "u64" }, { name: "endTime", type: "u64" }, { name: "lastUpdate", type: "u64" }, { name: "bump", type: "u8" }, { name: "farmType", type: { defined: "FarmType" } }] } }, { name: "pool", type: { kind: "struct", fields: [{ name: "tokenX", type: "publicKey" }, { name: "tokenY", type: "publicKey" }, { name: "poolXAccount", type: "publicKey" }, { name: "poolYAccount", type: "publicKey" }, { name: "admin", type: "publicKey" }, { name: "projectOwner", type: "publicKey" }, { name: "tokenXReserve", type: { defined: "Token" } }, { name: "tokenYReserve", type: { defined: "Token" } }, { name: "selfShares", type: { defined: "Token" } }, { name: "allShares", type: { defined: "Token" } }, { name: "buybackAmountX", type: { defined: "Token" } }, { name: "buybackAmountY", type: { defined: "Token" } }, { name: "projectAmountX", type: { defined: "Token" } }, { name: "projectAmountY", type: { defined: "Token" } }, { name: "mercantiAmountX", type: { defined: "Token" } }, { name: "mercantiAmountY", type: { defined: "Token" } }, { name: "lpAccumulatorX", type: { defined: "FixedPoint" } }, { name: "lpAccumulatorY", type: { defined: "FixedPoint" } }, { name: "constK", type: { defined: "Product" } }, { name: "price", type: { defined: "FixedPoint" } }, { name: "lpFee", type: { defined: "FixedPoint" } }, { name: "buybackFee", type: { defined: "FixedPoint" } }, { name: "projectFee", type: { defined: "FixedPoint" } }, { name: "mercantiFee", type: { defined: "FixedPoint" } }, { name: "farmCount", type: "u64" }, { name: "bump", type: "u8" }] } }, { name: "provider", type: { kind: "struct", fields: [{ name: "tokenX", type: "publicKey" }, { name: "tokenY", type: "publicKey" }, { name: "owner", type: "publicKey" }, { name: "shares", type: { defined: "Token" } }, { name: "lastFeeAccumulatorX", type: { defined: "FixedPoint" } }, { name: "lastFeeAccumulatorY", type: { defined: "FixedPoint" } }, { name: "lastSecondsPerShare", type: { defined: "FixedPoint" } }, { name: "lastWithdrawTime", type: "u64" }, { name: "tokensOwedX", type: { defined: "Token" } }, { name: "tokensOwedY", type: { defined: "Token" } }, { name: "currentFarmCount", type: "u64" }, { name: "bump", type: "u8" }] } }, { name: "state", type: { kind: "struct", fields: [{ name: "admin", type: "publicKey" }, { name: "programAuthority", type: "publicKey" }, { name: "bump", type: "u8" }, { name: "nonce", type: "u8" }] } }], types: [{ name: "FixedPoint", type: { kind: "struct", fields: [{ name: "v", type: "u128" }] } }, { name: "Token", type: { kind: "struct", fields: [{ name: "v", type: "u64" }] } }, { name: "Product", type: { kind: "struct", fields: [{ name: "v", type: "u128" }] } }, { name: "FarmType", type: { kind: "enum", variants: [{ name: "Single" }, { name: "Dual" }, { name: "Triple" }] } }], errors: [{ code: 6e3, name: "DeltaTooBig", msg: "Delta greater than provider's tokens" }, { code: 6001, name: "TokenUnderflow", msg: "Token amount underflow" }, { code: 6002, name: "WrongRatio", msg: "Wrong tokens ratio" }, { code: 6003, name: "TooMuchShares", msg: "Too much shares provided" }, { code: 6004, name: "SwapToBig", msg: "Swap too big" }, { code: 6005, name: "FeeExceeded", msg: "Fee exceeded 100%" }, { code: 6007, name: "ScalesNotEqual", msg: "Scales have to be equal" }, { code: 6008, name: "FeeExceededDeltaOut", msg: "Fees exceeded delta_out" }, { code: 6009, name: "PriceLimitExceeded", msg: "Price limit exceeded" }, { code: 6010, name: "MintMismatch", msg: "Mint mismatch" }, { code: 6011, name: "TokensAreTheSame", msg: "Tokens are the same" }, { code: 6012, name: "WrongFarm", msg: "Cannot add supply to wrong farm" }, { code: 6013, name: "RewardsExceedingSupply", msg: "Cannot withdraw rewards exceeding supply left" }, { code: 6014, name: "FarmNotEnded", msg: "Farm has not ended, cannot add additional rewards" }, { code: 6015, name: "ZeroAmount", msg: "Must provide a nonzero amount" }, { code: 6016, name: "InvariantChanged", msg: "Invariant has changed" }], metadata: { address: "9tKE7Mbmj4mxDjWatikzGAtkoWosiiZX9y6J4Hfm2R8H" } }, m.MARCO_POLO_PROGRAM_ID, be), pn = new C.default(10).pow(12);



class MarcoPoloAmm {
    constructor(e, t) {
        this.address = void 0, this.id = void 0, this.label = void 0, this.shouldPrefetch = !1, this.exactOutputSupported = !1, this.hasDynamicAccounts = !1, this.isBonkSwap = void 0, this.pool = void 0, this.calculator = void 0, this.feePct = void 0, this.tokenReserveAmounts = void 0, this.address = e, this.id = e.toBase58(), this.pool = this.decodePoolState(t), this.isBonkSwap = t.owner.equals(m.BONK_SWAP_PROGRAM_ID), this.label = this.isBonkSwap ? "BonkSwap" : "Oasis";

        const n = this.pool.lpFee.v.add(this.pool.buybackFee.v).add(this.pool.mercantiFee.v).add(this.pool.projectFee.v);

        this.feePct = new C.default(n.toString()).div(pn), this.calculator = new i.TokenSwapConstantProduct(new i.Fraction(_.default.BigInt(n), _.default.BigInt(pn)), i.ZERO_FRACTION, !1)
    } decodePoolState(e) { return ln.coder.accounts.decode("pool", e.data) } getAccountsForUpdate() { return [this.address] } update(e) {
        const t = e.get(this.id);

        if (!t) throw new Error(`Pool account info is not found: ${this.id}`);

        const n = this.decodePoolState(t);

        this.pool = n, this.tokenReserveAmounts = [_.default.BigInt(n.tokenXReserve.v), _.default.BigInt(n.tokenYReserve.v)]
    } getQuote({ destinationMint: e, amount: t }) {
        const { tokenX: n } = this.pool;

        if (!this.tokenReserveAmounts) throw new Error(J);

        const o = e.equals(n) ? 0 : 1, i = this.calculator.exchange(this.tokenReserveAmounts, t, o);

        return { notEnoughLiquidity: !1, inAmount: t, outAmount: i.expectedOutputAmount, feeAmount: i.fees, feeMint: e.toBase58(), feePct: this.feePct.toNumber(), priceImpactPct: i.priceImpact.toNumber() }
    } getSwapLegAndAccounts(t) {
        const n = m.JUPITER_FEE_OWNER;

        return function ({ additionalArgs: t, userSourceTokenAccount: n, userDestinationTokenAccount: o, userTransferAuthority: i, sourceMint: a }) {
            const s = a.equals(t.tokenX), { swapperXAccount: r, swapperYAccount: c } = s ? { swapperXAccount: n, swapperYAccount: o } : { swapperXAccount: o, swapperYAccount: n };

            let [d, l, p] = t.isBonkSwap ? [m.BONK_SWAP_PROGRAM_ID, m.BONK_SWAP_STATE_ID, m.BONK_SWAP_PROGRAM_AUTHORITY] : [m.MARCO_POLO_PROGRAM_ID, m.MARCO_POLO_STATE_ID, m.MARCO_POLO_PROGRAM_AUTHORITY];

            return [Pe(fe(s)), m.JUPITER_PROGRAM.instruction.marcoPoloSwap({ accounts: { swapProgram: d, state: l, pool: t.pool, tokenX: t.tokenX, tokenY: t.tokenY, poolXAccount: t.poolXAccount, poolYAccount: t.poolYAccount, swapperXAccount: r, swapperYAccount: c, swapper: i, referrerXAccount: t.referrerXAccount, referrerYAccount: t.referrerYAccount, referrer: t.referrer, programAuthority: p, systemProgram: e.SystemProgram.programId, tokenProgram: u.TOKEN_PROGRAM_ID, associatedTokenProgram: u.ASSOCIATED_TOKEN_PROGRAM_ID, rent: e.SYSVAR_RENT_PUBKEY } }).keys]
        }({ additionalArgs: { pool: this.address, tokenX: this.pool.tokenX, tokenY: this.pool.tokenY, poolXAccount: this.pool.poolXAccount, poolYAccount: this.pool.poolYAccount, referrer: n, referrerXAccount: m.findAssociatedTokenAddress({ walletAddress: n, tokenMintAddress: this.pool.tokenX }), referrerYAccount: m.findAssociatedTokenAddress({ walletAddress: n, tokenMintAddress: this.pool.tokenY }), isBonkSwap: this.isBonkSwap }, ...t })
    } get reserveTokenMints() { return [this.pool.tokenX, this.pool.tokenY] }
} 

hn.getProgram = () => ln;

const gn = _.default.BigInt(1e4);


class PhoenixAmm {
    constructor(e, t) {
        (this.address = void 0),
            (this.id = void 0),
            (this.label = "Phoenix"),
            (this.shouldPrefetch = !1),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !1),
            (this.marketData = void 0),
            (this.ladder = void 0),
            (this.outAmountWithoutFeesMultiplier = void 0),
            (this.baseLotsPerBaseUnit = void 0),
            (this.baseLotSize = void 0),
            (this.quoteLotSize = void 0),
            (this.tickSizeInQuoteLotsPerBaseUnitPerTick = void 0),
            (this.address = e),
            (this.id = e.toBase58()),
            (this.marketData = O.deserializeMarketData(t.data)),
            (this.outAmountWithoutFeesMultiplier = _.default.BigInt(
                1e4 - this.marketData.takerFeeBps
            )),
            (this.baseLotsPerBaseUnit = _.default.BigInt(
                this.marketData.baseLotsPerBaseUnit
            ));

        const n = this.marketData.header;

        (this.baseLotSize = _.default.BigInt(n.baseLotSize.toString())),
            (this.quoteLotSize = _.default.BigInt(n.quoteLotSize.toString())),
            (this.tickSizeInQuoteLotsPerBaseUnitPerTick = _.default.divide(
                _.default.BigInt(n.tickSizeInQuoteAtomsPerBaseUnit.toString()),
                this.quoteLotSize
            ));
    }
    getAccountsForUpdate() {
        return [this.address, e.SYSVAR_CLOCK_PUBKEY];
    }
    update(e) {
        const [t, n] = j(e, this.getAccountsForUpdate());

        if (!t)
            throw new Error(`Missing market accountInfo ${this.address.toBase58()}`);

        const o = O.Market.load({
            address: this.address,
            buffer: t.data,
            tokenList: [],
        });

        this.marketData = o.data;

        const i = lt(n.data),
            a = pt(n.data);

        this.ladder = O.getMarketLadder(o, -1, i, a);
    }
    JSBImin(e, t) {
        return _.default.lessThan(e, t) ? e : t;
    }
    computeQuote({ sourceMint: e, amount: t }) {
        if (!this.ladder)
            throw new Error(`Missing ladder for Phoenix: ${this.address.toBase58()}`);

        let n,
            o = _.default.BigInt(0),
            a = i.ZERO,
            s = !1;

        if (e.equals(this.marketData.header.baseParams.mintKey)) {
            let e = _.default.divide(t, this.baseLotSize);

            const r = _.default.BigInt(e);

            for (const { priceInTicks: t, sizeInBaseLots: a } of this.ladder.bids) {
                if (_.default.lessThanOrEqual(e, i.ZERO)) break;

                const s = _.default.BigInt(t.toString()),
                    r = _.default.BigInt(a.toString()),
                    u = this.JSBImin(r, e),
                    c = _.default.divide(
                        _.default.multiply(
                            _.default.multiply(
                                _.default.multiply(s, u),
                                this.tickSizeInQuoteLotsPerBaseUnitPerTick
                            ),
                            this.quoteLotSize
                        ),
                        this.baseLotsPerBaseUnit
                    );

                if (!n) {
                    const e = _.default.multiply(u, this.baseLotSize);

                    n = new C.default(c.toString()).div(e.toString());
                }
                (o = _.default.add(o, c)), (e = _.default.subtract(e, u));
            }
            (a = _.default.multiply(_.default.subtract(r, e), this.baseLotSize)),
                _.default.greaterThan(e, i.ZERO) && (s = !0);
        } else {
            let e = _.default.divide(t, this.quoteLotSize);

            const r = _.default.BigInt(e);

            for (const { priceInTicks: t, sizeInBaseLots: a } of this.ladder.asks) {
                if (_.default.lessThanOrEqual(e, i.ZERO)) break;

                const s = _.default.BigInt(t.toString()),
                    r = _.default.BigInt(a.toString()),
                    u = _.default.divide(
                        _.default.divide(
                            _.default.multiply(e, this.baseLotsPerBaseUnit),
                            this.tickSizeInQuoteLotsPerBaseUnitPerTick
                        ),
                        s
                    );

                let c, m;

                _.default.greaterThan(r, u)
                    ? ((c = u), (m = e))
                    : ((c = r),
                        (m = _.default.divide(
                            _.default.multiply(
                                _.default.multiply(s, c),
                                this.tickSizeInQuoteLotsPerBaseUnitPerTick
                            ),
                            this.baseLotsPerBaseUnit
                        )));

                const d = _.default.multiply(c, this.baseLotSize);

                if (!n) {
                    const e = _.default.multiply(m, this.quoteLotSize);

                    n = new C.default(d.toString()).div(e.toString());
                }
                (o = _.default.add(o, d)), (e = _.default.subtract(e, m));
            }
            (a = _.default.multiply(_.default.subtract(r, e), this.quoteLotSize)),
                _.default.greaterThan(e, i.ZERO) && (s = !0);
        }
        const r = this.computAmountAfterFees(o),
            u = _.default.subtract(o, r),
            c = new C.default(o.toString()).div(t.toString());

        if (!n) throw new Error("No best price");

        return {
            notEnoughLiquidity: s,
            inAmount: a,
            outAmount: r,
            feeAmount: u,
            priceImpactPct: n.sub(c).div(n).toNumber(),
        };
    }
    computAmountAfterFees(e) {
        return _.default.divide(
            _.default.multiply(e, this.outAmountWithoutFeesMultiplier),
            gn
        );
    }
    getQuote({ sourceMint: e, amount: t }) {
        const {
            notEnoughLiquidity: n,
            inAmount: o,
            outAmount: i,
            feeAmount: a,
            priceImpactPct: s,
        } = this.computeQuote({ sourceMint: e, amount: t });

        return {
            notEnoughLiquidity: n,
            inAmount: o,
            outAmount: i,
            feeAmount: a,
            feeMint: e.toBase58(),
            feePct: this.marketData.takerFeeBps / 1e4,
            priceImpactPct: s,
        };
    }
    getSwapLegAndAccounts(t) {
        return (function ({
            additionalArgs: e,
            sourceMint: t,
            userSourceTokenAccount: n,
            userDestinationTokenAccount: o,
            userTransferAuthority: i,
        }) {
            const {
                side: a,
                baseAccount: s,
                quoteAccount: r,
            } = t.equals(e.baseMint)
                ? { side: ce.Ask, baseAccount: n, quoteAccount: o }
                : { side: ce.Bid, baseAccount: o, quoteAccount: n };

            return [
                Pe(ke(a)),
                m.JUPITER_PROGRAM.instruction.phoenixSwap({
                    accounts: {
                        swapProgram: m.PHOENIX_PROGRAM_ID,
                        logAuthority: e.logAuthority,
                        market: e.market,
                        trader: i,
                        baseAccount: s,
                        quoteAccount: r,
                        baseVault: e.baseVault,
                        quoteVault: e.quoteVault,
                        tokenProgram: u.TOKEN_PROGRAM_ID,
                    },
                }).keys,
            ];
        })({
            ...t,
            additionalArgs: {
                logAuthority: e.PublicKey.findProgramAddressSync(
                    [Buffer.from("log")],
                    m.PHOENIX_PROGRAM_ID
                )[0],
                market: this.address,
                baseVault: this.marketData.header.baseParams.vaultKey,
                quoteVault: this.marketData.header.quoteParams.vaultKey,
                baseMint: this.marketData.header.baseParams.mintKey,
            },
        });
    }
    get reserveTokenMints() {
        return [
            this.marketData.header.baseParams.mintKey,
            this.marketData.header.quoteParams.mintKey,
        ];
    }
}


function fn(e, t, n) { return Math.floor(e * t / n) } function Sn(e, t) {
    let n = e.coder.accounts.decode("tokenInfo", t), o = n.numTokens.toNumber(), i = [];

    for (let e = 0;

        e < o;

        e++)i.push({ id: e, mint: n.tokenMint[e].toBase58(), pdaAccount: n.pdaTokenAccount[e].toBase58(), pyth: n.pyth[e].toBase58(), decimals: n.decimals[e] });

    return i
} 



class kn {
    constructor(e, t, n) {
        (this.address = void 0),
            (this.id = void 0),
            (this.label = "Symmetry"),
            (this.shouldPrefetch = !0),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !0),
            (this.fundState = void 0),
            (this.tokenInfos = void 0),
            (this.curveData = void 0),
            (this.pythPrices = []),
            (this.address = e),
            (this.id = e.toBase58()),
            (this.fundState = ve.coder.accounts.decode("fundState", t.data)),
            (this.tokenInfos = Sn(ve, Buffer.from(n.tokenInfoData, "base64")));

        for (let e = 0; e < this.tokenInfos.length; e++)
            this.pythPrices.push({ aggregate: { price: 0 } });
    }
    getAccountsForUpdate() {
        let t = [this.address, Re, Be];

        for (let n = 0; n < this.fundState.numOfTokens.toNumber(); n++)
            t.push(
                new e.PublicKey(
                    this.tokenInfos[this.fundState.currentCompToken[n].toNumber()].pyth
                )
            );

        return t;
    }
    update(e) {
        const [t, n, o] = j(e, this.getAccountsForUpdate());

        (this.tokenInfos = Sn(ve, n.data)),
            (this.curveData = ve.coder.accounts.decode("prismData", o.data));

        let i = this.pythPrices;

        for (let t = 0; t < this.fundState.numOfTokens.toNumber(); t++) {
            const n = this.fundState.currentCompToken[t].toNumber(),
                o = this.tokenInfos[n].pyth,
                a = e.get(o);

            if (!a) throw new Error(`Account info ${o} missing`);

            let s = k.parsePriceData(a.data);

            i[n] = s;
        }
        (this.fundState = ve.coder.accounts.decode("fundState", t.data)),
            (this.pythPrices = i);
    }
    getQuote({ sourceMint: e, destinationMint: t, amount: n }) {
        if (!this.curveData)
            throw new Error("Can't calculate quote without curve data");

        const o = (function (e, t, n, o, i, a, s) {
            let r = s,
                u = 0,
                c = n.numOfTokens.toNumber(),
                m = e.findIndex((e) => e.mint === i.toBase58()),
                d = e.findIndex((e) => e.mint === a.toBase58()),
                l = -1,
                p = -1;

            for (let t = 0; t < c; t++) {
                let i = n.currentCompToken[t].toNumber(),
                    a = n.currentCompAmount[t].toNumber();

                (u += o[i].aggregate.price * (a / 10 ** e[i].decimals)),
                    i == m && (l = t),
                    i == d && (p = t);
            }
            if (-1 == l || -1 == p || 0 == u) return;

            let h = n.weightSum.toNumber(),
                g = 10 ** e[m].decimals,
                A = o[m].aggregate.price,
                f = 0.99999 * A - o[m].confidence / 2,
                S = 10 ** e[d].decimals,
                k = o[d].aggregate.price,
                y = 1.00001 * k + o[d].confidence / 2,
                M = (s * f) / g,
                w =
                    (((n.targetWeight[l].toNumber() * u) / n.weightSum.toNumber()) * g) /
                    A,
                P =
                    (((n.targetWeight[p].toNumber() * u) / n.weightSum.toNumber()) * S) /
                    k,
                T = M;

            0 != m &&
                (T =
                    (function (e, t, n, o, i, a) {
                        let s = 0;

                        s = e > t ? t : e;

                        let r = 0,
                            u = o,
                            c = 10 ** a,
                            m = n,
                            d = m,
                            l = 0;

                        for (let t = 0; t < 10; t++) {
                            let n = Math.floor((9 * i.price[t].toNumber() + m) / 10);

                            if ((n < d && (d = n), (l += i.amount[t].toNumber()), l <= e - s))
                                continue;

                            let o = Math.min(l - (e - s), i.amount[t].toNumber()),
                                a = fn(o, d, c);

                            if (o > u) return fn(u, d, c) + r;

                            (r += a), (u -= o);
                        }
                        return (r += fn(u, d, c)), r;
                    })(
                        n.currentCompAmount[l].toNumber(),
                        Math.floor(w),
                        Math.floor(1e6 * f),
                        s,
                        t.sell[m],
                        e[m].decimals
                    ) / 1e6);

            let I = (T * S) / y;

            0 != d &&
                (I = (function (e, t, n, o, i, a) {
                    let s = 0;

                    s = e < t ? t : e;

                    let r = o,
                        u = 0,
                        c = 10 ** a,
                        m = n,
                        d = m,
                        l = 0;

                    for (let t = 0; t < 10; t++) {
                        let n = Math.floor((9 * i.price[t].toNumber() + m) / 10);

                        if ((n > d && (d = n), (l += i.amount[t].toNumber()), l <= s - e))
                            continue;

                        let o = Math.min(l - (s - e), i.amount[t].toNumber()),
                            a = fn(o, d, c);

                        if (a > r) return fn(r, c, d) + u;

                        (u += o), (r -= a);
                    }
                    return (u += fn(r, c, d)), u;
                })(
                    n.currentCompAmount[p].toNumber(),
                    Math.floor(P),
                    Math.floor(1e6 * y),
                    Math.floor(1e6 * T),
                    t.buy[d],
                    e[d].decimals
                ));

            let b = (M * S) / y,
                v = 0;

            b > n.currentCompAmount[p].toNumber() &&
                ((v = b - n.currentCompAmount[p].toNumber()),
                (b = n.currentCompAmount[p].toNumber())),
                I > b && (I = b);

            let R = b - I,
                B =
                    R -
                    Math.floor((5 * R) / 100) -
                    Math.floor((20 * R) / 100) -
                    Math.floor((20 * R) / 100);

            u = u + M - ((b - B) * k) / S;

            let O = n.targetWeight[l].toNumber() / h,
                D = n.currentCompAmount[l].toNumber(),
                E = n.targetWeight[p].toNumber() / h,
                F = (n.currentCompAmount[p].toNumber() - (b - B)) / S,
                L =
                    (n.rebalanceThreshold.toNumber() / 1e4) *
                    (n.lpOffsetThreshold.toNumber() / 1e4);

            if ((F * k) / u < E * (1 - L) && E * (1 - L) > 0) return;

            let _ = (D + s) / g,
                q =
                    (n.rebalanceThreshold.toNumber() / 1e4) *
                    (n.lpOffsetThreshold.toNumber() / 1e4);

            if ((_ * A) / u > O * (1 + q) && 0 != m && O * (1 + q) < 1) return;

            let x = R + v,
                C = b - B + x;

            return {
                inAmount: r,
                outAmount: Math.floor(I),
                feeMint: a,
                feeAmount: Math.ceil(x),
                priceImpact: x / C,
                feePct: x / C,
            };
        })(
            this.tokenInfos,
            this.curveData,
            this.fundState,
            this.pythPrices,
            e,
            t,
            _.default.toNumber(n)
        );

        if (!o) throw new Error("Can't calculate quote");

        return {
            notEnoughLiquidity: !1,
            inAmount: _.default.BigInt(o.inAmount),
            outAmount: _.default.BigInt(o.outAmount),
            feeAmount: _.default.BigInt(o.feeAmount),
            feeMint: o.feeMint.toBase58(),
            feePct: o.feePct,
            priceImpactPct: o.priceImpact,
        };
    }
    getSwapLegAndAccounts(t) {
        return (function ({
            additionalArgs: t,
            sourceMint: n,
            destinationMint: o,
            userSourceTokenAccount: i,
            userDestinationTokenAccount: a,
            userTransferAuthority: s,
        }) {
            let r = t.tokenInfos.findIndex((e) => e.mint === n.toBase58()),
                c = t.tokenInfos.findIndex((e) => e.mint === o.toBase58()),
                d = m.findAssociatedTokenAddress({
                    walletAddress: Oe,
                    tokenMintAddress: o,
                }),
                l = m.findAssociatedTokenAddress({
                    walletAddress: t.fundState.hostPubkey,
                    tokenMintAddress: o,
                }),
                p = m.findAssociatedTokenAddress({
                    walletAddress: t.fundState.manager,
                    tokenMintAddress: o,
                }),
                h = [];

            for (let n = 0; n < t.fundState.numOfTokens.toNumber(); n++) {
                let o = t.fundState.currentCompToken[n].toNumber();

                h.push({
                    pubkey: new e.PublicKey(t.tokenInfos[o].pyth),
                    isWritable: !1,
                    isSigner: !1,
                });
            }
            return [
                Pe(ye(new x.default(r), new x.default(c))),
                m.JUPITER_PROGRAM.instruction.symmetrySwap({
                    accounts: {
                        swapProgram: m.SYMMETRY_PROGRAM_ID,
                        buyer: s,
                        fundState: t.fundAddress,
                        pdaAccount: De,
                        pdaFromTokenAccount: t.tokenInfos[r].pdaAccount,
                        buyerFromTokenAccount: i,
                        pdaToTokenAccount: t.tokenInfos[c].pdaAccount,
                        buyerToTokenAccount: a,
                        swapFeeAccount: d,
                        hostFeeAccount: l,
                        managerFeeAccount: p,
                        tokenInfo: Re,
                        prismData: Be,
                        tokenProgram: u.TOKEN_PROGRAM_ID,
                    },
                    remainingAccounts: [...h, Ee],
                }).keys,
            ];
        })({
            additionalArgs: {
                fundAddress: this.address,
                tokenInfos: this.tokenInfos,
                fundState: this.fundState,
            },
            ...t,
        });
    }
    get reserveTokenMints() {
        let t = [];

        for (let n = 0; n < this.fundState.numOfTokens.toNumber(); n++) {
            let o =
                this.tokenInfos[this.fundState.currentCompToken[n].toNumber()].mint;

            t.push(new e.PublicKey(o));
        }
        return t;
    }
}
 


const yn = ({ amms: e, asLegacyTransaction: t, isSplit: n }) => {
    if (t) {
        if (e.length > 2) return !1;

        const [t, o] = e;

        return n ? !Y(U, t.label, o.label) : !Y(V, t.label, o.label)
    } return !0
}, 


Mn = new Map([
    [m.ORCA_V1_PROGRAM_ID.toString(), "Orca"],
    [m.ORCA_V2_PROGRAM_ID.toString(), "Orca"],
    [m.STEP_TOKEN_SWAP_PROGRAM_ID.toString(), "Step"],
    [m.PENGUIN_PROGRAM_ID.toString(), "Penguin"],
    [m.SAROS_PROGRAM_ID.toString(), "Saros"],
    [m.STEPN_PROGRAM_ID.toString(), "Stepn"],
]);


function wn(t, i, a) {
    const s = new e.PublicKey(i.owner);

    if (
        s.equals(m.MAINNET_SERUM_DEX_PROGRAM) ||
        s.equals(m.DEVNET_SERUM_DEX_PROGRAM) ||
        s.equals(m.OPENBOOK_PROGRAM_ID)
    ) {
        const e = n.Market.getLayout(s).decode(i.data);

        if (!e.accountFlags.initialized || !e.accountFlags.market)
            throw new Error("Invalid market");

        const t = new n.Market(e, 0, 0, {}, s);

        return new Zt(t);
    }
    if (s.equals(m.RAYDIUM_AMM_V4_PROGRAM_ID)) return new RaydiumAmm(t, i, a);

    if (s.equals(m.MERCURIAL_SWAP_PROGRAM_ID)) return new MercurialAmm(t, i, a);

    if (s.equals(o.SWAP_PROGRAM_ID)) {
        const e = i.data.slice(2, 3),
            n = o.StableSwap.loadWithData(
                t,
                i.data,
                ie([t.toBuffer(), e], o.SWAP_PROGRAM_ID)
            );

        if (!n.state.isInitialized) return;

        return new Gt(n);
    }
    if (s.equals(m.SABER_ADD_DECIMALS_PROGRAM_ID)) return new Vt(t, i);

    if (s.equals(m.CREMA_PROGRAM_ID)) return new CremaAmm(t, i, a);

    if (
        s.equals(m.ALDRIN_SWAP_PROGRAM_ID) ||
        s.equals(m.ALDRIN_SWAP_V2_PROGRAM_ID)
    )
        return new AldrinAmm(t, i, a);

    if ([...Mn.keys()].includes(s.toBase58())) {
        var r;

        const e =
            null !== (r = Mn.get(i.owner.toBase58())) && void 0 !== r ? r : "Unknown";

        return new nn(t, i, e);
    }
    return s.equals(m.CROPPER_PROGRAM_ID)
        ? new CropperAmm(t, i, a)
        : s.equals(m.SENCHA_PROGRAM_ID)
        ? new Wt(t, i)
        : s.equals(m.LIFINITY_PROGRAM_ID)
        ? new LifinityAmm(t, i)
        : s.equals(m.LIFINITY_V2_PROGRAM_ID)
        ? new LifinityV2Amm(t, i)
        : s.equals(m.WHIRLPOOL_PROGRAM_ID)
        ? new cn(t, i)
        : s.equals(m.CYKURA_PROGRAM_ID)
        ? new CykuraAmm(t, i)
        : s.equals(m.MARINADE_PROGRAM_ID)
        ? new MarinadeAmm(t, i)
        : s.equals(m.METEORA_PROGRAM_ID)
        ? new MeteoraAmm(t, i, a)
        : s.equals(m.GOOSE_FX_PROGRAM_ID)
        ? new ht(t, i)
        : s.equals(m.INVARIANT_PROGRAM_ID)
        ? new InvariantAmm(t, i)
        : s.equals(m.DRADEX_PROGRAM_ID)
        ? new mn(t, i, a)
        : s.equals(m.BALANSOL_PROGRAM_ID)
        ? new BalansolAmm(t, i)
        : s.equals(m.RAYDIUM_CLMM_PROGRAM_ID)
        ? new dn(t, i)
        : s.equals(m.MARCO_POLO_PROGRAM_ID)
        ? new MarcoPoloAmm(t, i)
        : s.equals(m.PHOENIX_PROGRAM_ID)
        ? new PhoenixAmm(t, i)
        : s.equals(m.SYMMETRY_PROGRAM_ID)
        ? new kn(t, i, a)
        : void 0;
}



class Pn {
    constructor(e, t) {
        (this.connection = void 0),
            (this.ammIdToAddressLookupTable = void 0),
            (this.ammIdToAddressLookupTableAccount = new Map()),
            (this.connection = e),
            (this.ammIdToAddressLookupTable = t);
    }
    async getAdressLookupTableAccounts(t) {
        const n = new Map(),
            o = [
                ...t.reduce((e, t) => {
                    const o = this.ammIdToAddressLookupTableAccount.get(t);

                    if (o) {
                        const e = o.key.toBase58();

                        n.has(e) || n.set(e, t);
                    } else {
                        const o = this.ammIdToAddressLookupTable.get(t);

                        o && (e.add(o), n.set(t, o));
                    }
                    return e;
                }, new Set()),
            ];

        return (await z(this.connection, o)).reduce((t, i, a) => {
            const s = o[a];

            if (i) {
                const o = new e.AddressLookupTableAccount({
                    key: new e.PublicKey(s),
                    state: e.AddressLookupTableAccount.deserialize(i.data),
                });

                t.push(o);

                const a = n.get(s);

                a && this.ammIdToAddressLookupTableAccount.set(a, o);
            }
            return t;
        }, new Array());
    }
}


class Tn {
    constructor(e) {
        (this.ammIdToAddressLookupTableAccount = void 0),
            (this.ammIdToAddressLookupTableAccount = e);
    }
    static async load(t, n) {
        const o = [...n.entries()],
            i = await z(
                t,
                o.map(([e, t]) => t)
            ),
            a = new Map();

        for (const [t, n] of i.entries()) {
            const [i, s] = o[t];

            n &&
                a.set(
                    i,
                    new e.AddressLookupTableAccount({
                        key: new e.PublicKey(s),
                        state: e.AddressLookupTableAccount.deserialize(n.data),
                    })
                );
        }
        return new Tn(a);
    }
    getAdressLookupTableAccounts(e) {
        const t = new Set(),
            n = e.reduce((e, n) => {
                const o = this.ammIdToAddressLookupTableAccount.get(n);

                if (o) {
                    const n = o.key.toBase58();

                    t.has(n) || (e.push(o), t.add(n));
                }
                return e;
            }, new Array());

        return Promise.resolve(n);
    }
}


async function In(e, t, n) {
    const o = t.reduce((e, t) => {
        var n;

        const o =
            null == t || null === (n = t.params) || void 0 === n
                ? void 0
                : n.addressLookupTableAddress;

        return o && e.set(t.pubkey, o), e;
    }, new Map());

    return n ? await Tn.load(e, o) : new Pn(e, o);
}


const bn = {};


// function vn(e) {
//     const t = e._bn.toString(), n = bn[t];

//     if (n) return n;

//     {
//         const n = e.toBase58();

//         return bn[t] = n, n
//     }
// } 

// function Rn(e) {
//     const t = new Map();

//     return (
//         e.forEach((e) => {
//             on(e.reserveTokenMints).forEach(([n, o]) => {
//                 !(function (e, t, n, o) {
//                     let i = o.get(e);

//                     i || ((i = new Map([[t, []]])), o.set(e, i));

//                     let a = i.get(t);

//                     a || ((a = []), i.set(t, a)), a.push(n);
//                 })(vn(n), vn(o), e, t);
//             });
//         }),
//         t
//     );
// }


// Function to normalize a token mint by converting it to a base58 string and caching the result
function normalizeTokenMint(mint) {
    const mintString = mint._bn.toString();  // Convert the internal BN representation to a string
    const cachedMint = bn[mintString];       // Check if the base58 representation is already cached

    // If the mint is cached, return the cached value
    if (cachedMint) return cachedMint;

    // Otherwise, convert the mint to base58, cache it, and return the base58 representation
    const base58Mint = mint.toBase58();
    bn[mintString] = base58Mint;

    return base58Mint;
}

// Function to build a map of token route segments based on AMMs and their reserve token mints
function buildTokenRouteSegments(amms) {                       // amms: List of AMMs (Automated Market Makers)
    const tokenRouteSegments = new Map();                      // tokenRouteSegments: Map to store token routes

    // Iterate over each AMM
    amms.forEach((amm) => {
        // Get pairs of input and output token mints from the AMM's reserve token mints
        getTokenMintPairs(amm.reserveTokenMints).forEach(([inputMint, outputMint]) => {

            // Build the route segment between the inputMint and outputMint
            (function addRouteSegment(inputMint, outputMint, amm, routeMap) {
                let outputMintMap = routeMap.get(inputMint);    // Try to get the outputMint map for inputMint from routeMap

                // If no outputMint map exists for the inputMint, create one
                if (!outputMintMap) {
                    outputMintMap = new Map([[outputMint, []]]);  // Create a new map for the outputMint with an empty array
                    routeMap.set(inputMint, outputMintMap);       // Add this outputMint map to the routeMap for inputMint
                }

                let ammsForTokenPair = outputMintMap.get(outputMint);  // Try to get the AMMs list for this token pair

                // If no AMMs list exists for the token pair, create an empty list
                if (!ammsForTokenPair) {
                    ammsForTokenPair = [];
                    outputMintMap.set(outputMint, ammsForTokenPair);   // Set the AMMs list in the map for outputMint
                }

                ammsForTokenPair.push(amm);  // Add the current AMM to the list for this token pair
            })(normalizeTokenMint(inputMint), normalizeTokenMint(outputMint), amm, tokenRouteSegments);
        });
    });

    return tokenRouteSegments;  // Return the fully constructed map of token route segments
}


// function Bn(e, t, n) {
//     return Boolean(e && t > 100 && !e.has(n));
// }

// Function to determine if a mint should be excluded from the route
function shouldExcludeIntermediateToken(intermediateTokens, routeSize, currentMint) {
    return Boolean(intermediateTokens && routeSize > 100 && !intermediateTokens.has(currentMint));
}


async function On(t, n, o, i) {
    const a = m.getEmptyInstruction(),
        s = o.address.toString();

    if (i) {
        let e = i.get(s);

        if (e) {
            let n = null;

            if (((n = await t.getAccountInfo(e, "confirmed")), n))
                return { ...a, address: e };
        }
    }
    const [r, u] = (function (t, n, o) {
        const [i] = e.PublicKey.findProgramAddressSync(
            [Buffer.from("open_orders"), t.toBuffer(), o.toBuffer()],
            m.JUPITER_PROGRAM_ID
        );

        return [
            i,
            m.JUPITER_PROGRAM.instruction.createOpenOrders({
                accounts: {
                    openOrders: i,
                    payer: o,
                    dexProgram: n,
                    systemProgram: e.SystemProgram.programId,
                    rent: e.SYSVAR_RENT_PUBKEY,
                    market: t,
                },
            }),
        ];
    })(o.address, o.programId, n);

    return (
        (await t.getAccountInfo(r)) || (a.setupInstructions = [u]),
        null == i || i.set(o.address.toString(), r),
        { ...a, address: r }
    );
}


const Dn = { feeBps: 0, feeAccounts: new Map };



async function En(e, t) {
    return (
        await e.getTokenAccountsByOwner(t, { programId: u.TOKEN_PROGRAM_ID })
    ).value.reduce((e, t) => {
        const n = r.deserializeAccount(t.account.data);

        return n && e.set(n.mint.toBase58(), t.pubkey), e;
    }, new Map());
}



const Fn = function (e) {
    if (!Array.isArray(e))
        throw new TypeError(`Argument must be an array: ${e}`);
},
Ln = function (e, t) {
    return e * t.length;
},
_n = {},
qn = function (e, t) {
    return String(t);
};



function xn(e) { return null != e } 

const Cn = _.default.BigInt(1e4);


function Nn({ inputMint: e, outputMint: t }) { return `${e}-${t}` } 

function Kn({ ammId: e, amount: t }) { return `${e}-${t.toString()}` } 


function compareQuotes(e, t, swapMode) {
    return {
        ExactIn: _.default.greaterThanOrEqual(t.outAmount, e.outAmount) ? 1 : -1,
        ExactOut: _.default.lessThanOrEqual(t.inAmount, e.inAmount) ? 1 : -1,
    }[swapMode];
}




async function findBestRoute({
    inputRouteSegment: t,
    inputMint: n,
    outputMint: o,
    amount: a,
    getDepositAndFeeForRoute: s,
    platformFeeBps: r,
    slippageBps: u,
    filterTopNResult: c = 1,
    onlyDirectRoutes: m,
    swapMode: d,
    asLegacyTransaction: l,
}) {
    const p = n.toBase58(),
        h = o.toBase58();

    if (!t.get(p))
        throw new Error("No routes found for the input and output mints");

    const g = m || d === exports.SwapMode.ExactOut ? 1 : l ? 2 : 3,
        A = new Map(),
        f = [],
        S = new Map();

    return (
        (function a({ startMint: s, amount: r, level: u = 1, walked: p = [s] }) {
            const k = t.get(s);

            k &&
                k.forEach((y, M) => {
                    const w = Nn({ inputMint: s, outputMint: M }),
                        P = (function ({
                            amms: t,
                            inputMint: n,
                            outputMint: o,
                            amount: i,
                            swapMode: a,
                        }) {
                            return t
                                .map((t) => {
                                    try {
                                        return {
                                            quote: t.getQuote({
                                                amount: i,
                                                sourceMint: new e.PublicKey(n),
                                                destinationMint: new e.PublicKey(o),
                                                swapMode: a,
                                            }),
                                            amm: t,
                                        };
                                    } catch (e) {
                                        return;
                                    }
                                })
                                .filter(xn)
                                .sort((e, t) => compareQuotes(e.quote, t.quote, a));
                        })({
                            amms: y,
                            inputMint: s,
                            outputMint: M,
                            amount: r,
                            swapMode: d,
                        }),
                        { filteredAmms: T, quoteMap: I } = P.reduce(
                            (e, t) => (
                                e.filteredAmms.length < c && e.filteredAmms.push(t.amm),
                                e.quoteMap.set(Kn({ ammId: t.amm.id, amount: r }), t.quote),
                                e
                            ),
                            { filteredAmms: [], quoteMap: new Map() }
                        );

                    if (
                        (1 !== u ||
                            M !== h ||
                            m ||
                            d !== exports.SwapMode.ExactIn ||
                            (function (e, t) {
                                for (let n = 0; n < e.length; n++)
                                    for (let o = n + 1; o < e.length; o++)
                                        e[n].label !== e[o].label && t(e[n], e[o]);
                            })(
                                P.slice(0, Math.max(l ? 3 : 2, c)).map(({ amm: e }) => e),
                                (e, t) => {
                                    const i = (() => {
                                        if (
                                            yn({ amms: [e, t], asLegacyTransaction: l, isSplit: !0 })
                                        )
                                            return sn.create(e, t);
                                    })();

                                    i && f.push({ amms: [i], mints: [n, o] });
                                }
                            ),
                        k.set(M, T),
                        A.set(w, I),
                        M !== h && I.size && !p.includes(M) && u < g)
                    ) {
                        var b;

                        const e = I.values().next().value.outAmount,
                            t = null !== (b = S.get(M)) && void 0 !== b ? b : i.ZERO;

                        _.default.greaterThan(e, t) &&
                            (S.set(M, e),
                            a({
                                startMint: M,
                                amount: e,
                                level: u + 1,
                                walked: p.concat(M),
                            }));
                    } else if (M === h) {
                        1 === u && k.set(M, y);

                        const n = p.concat(M),
                            o = n.map((t) => new e.PublicKey(t)),
                            i = n.reduce((e, o, i) => {
                                var a;

                                return (
                                    i < n.length - 1 &&
                                        e.push(
                                            null === (a = t.get(n[i])) || void 0 === a
                                                ? void 0
                                                : a.get(n[i + 1])
                                        ),
                                    e
                                );
                            }, []),
                            a = (function (e) {
                                if (
                                    ((function (e) {
                                        if (!Array.isArray(e))
                                            throw new TypeError(
                                                "Argument must be an array of arrays"
                                            );

                                        e.forEach(Fn),
                                            (function ({ length: e }) {
                                                if (e >= 100)
                                                    throw new TypeError(
                                                        `Too many arrays (${e}): please use the 'big-cartesian' library instead of 'fast-cartesian'`
                                                    );
                                            })(e),
                                            (function (e) {
                                                const t = e.reduce(Ln, 1);

                                                if (t >= 4294967296) {
                                                    const e = Number.isFinite(t)
                                                        ? ` (${t.toExponential(0)})`
                                                        : "";

                                                    throw new TypeError(
                                                        `Too many combinations${e}: please use the 'big-cartesian' library instead of 'fast-cartesian'`
                                                    );
                                                }
                                            })(e);
                                    })(e),
                                    0 === e.length)
                                )
                                    return [];

                                const t = [];

                                return (
                                    (function (e) {
                                        const t = _n[e];

                                        if (void 0 !== t) return t;

                                        const n = (function (e) {
                                            const t = Array.from({ length: e }, qn),
                                                n = t
                                                    .map((e) => `for (const value${e} of arrays[${e}]) {`)
                                                    .join("\n"),
                                                o = t.map((e) => `value${e}`).join(", "),
                                                i = "}\n".repeat(e);

                                            return new Function(
                                                "arrays",
                                                "result",
                                                `${n}\nresult.push([${o}])\n${i}`
                                            );
                                        })(e);

                                        return (_n[e] = n), n;
                                    })(e.length)(e, t),
                                    t
                                );
                            })(i);

                        for (let e of a)
                            (1 === e.length || yn({ amms: e, asLegacyTransaction: l })) &&
                                f.push({ amms: e, mints: o });
                    }
                });
        })({ startMint: p, amount: a }),
        f
            .map((e) => {
                const { amms: t, mints: n } = e;

                let o = [],
                    c = a,
                    m = i.ZERO;

                const l = n,
                    p = t.length;

                for (const [e, n] of t.entries())
                    try {
                        var h;

                        const t = l[e],
                            s = l[e + 1],
                            g = Nn({ inputMint: t.toBase58(), outputMint: s.toBase58() }),
                            f =
                                null === (h = A.get(g)) || void 0 === h
                                    ? void 0
                                    : h.get(Kn({ ammId: n.id, amount: c }));

                        if (_.default.equal(c, i.ZERO)) return;

                        const S =
                                f ||
                                n.getQuote({
                                    sourceMint: t,
                                    destinationMint: s,
                                    amount: c,
                                    swapMode: d,
                                }),
                            k = calculatePlatformFee({
                                quote: S,
                                sourceMint: t,
                                destinationMint: s,
                                swapMode: d,
                                legIndex: e,
                                isLastLeg: p - 1 === e,
                                platformFeeBps: r,
                            }),
                            y = d === exports.SwapMode.ExactIn ? S.outAmount : S.inAmount;

                        let M =
                            d === exports.SwapMode.ExactIn
                                ? _.default.subtract(y, k.amount)
                                : _.default.add(y, k.amount);

                        _.default.lessThan(M, i.ZERO) && (M = i.ZERO);

                        const w = _.default.BigInt(
                                d === exports.SwapMode.ExactIn
                                    ? new C.default(M.toString())
                                            .mul(1 - u / _.default.toNumber(Cn))
                                            .ceil()
                                    : new C.default(M.toString())
                                            .mul(1 + u / _.default.toNumber(Cn))
                                            .floor()
                            ),
                            [P, T] =
                                d === exports.SwapMode.ExactIn ? [S.inAmount, M] : [M, c];

                        o.push({
                            amm: n,
                            inputMint: t,
                            outputMint: s,
                            notEnoughLiquidity: S.notEnoughLiquidity,
                            minInAmount: S.minInAmount,
                            minOutAmount: S.minOutAmount,
                            inAmount: P,
                            outAmount: T,
                            priceImpactPct: S.priceImpactPct,
                            lpFee: { amount: S.feeAmount, mint: S.feeMint, pct: S.feePct },
                            platformFee: k,
                        }),
                            (c = d === exports.SwapMode.ExactIn ? M : a),
                            (m = w);
                    } catch (e) {
                        return;
                    }
                return {
                    marketInfos: o,
                    getDepositAndFee: () => s({ marketInfos: o }),
                    inAmount: o[0].inAmount,
                    outAmount: c,
                    amount: a,
                    otherAmountThreshold: m,
                    swapMode: d,
                    slippageBps: u,
                    priceImpactPct: 1 - o.reduce((e, t) => e * (1 - t.priceImpactPct), 1),
                };
            })
            .filter(xn)
            .sort((e, t) => compareQuotes(e, t, d))
    );
}
 



// function calculatePlatformFee({
//     quote: e,
//     sourceMint: t,
//     destinationMint: n,
//     swapMode: o,
//     legIndex: a,
//     isLastLeg: s,
//     platformFeeBps: r,
// }) {
//     return s && o === exports.SwapMode.ExactIn
//         ? {
//                 amount: _.default.divide(
//                     _.default.multiply(e.outAmount, _.default.BigInt(r)),
//                     Cn
//                 ),
//                 mint: n.toBase58(),
//                 pct: r / 100,
//             }
//         : 0 === a && o === exports.SwapMode.ExactOut
//         ? {
//                 amount: _.default.divide(
//                     _.default.multiply(e.inAmount, _.default.BigInt(r)),
//                     Cn
//                 ),
//                 mint: t.toBase58(),
//                 pct: r / 100,
//             }
//         : { amount: i.ZERO, mint: n.toBase58(), pct: 0 };
// }
// const Cn = _.default.BigInt(1e4); // Constant to convert basis points to a percentage

function calculatePlatformFee({
    quote,                 // The AMM quote (containing inAmount/outAmount)
    sourceMint,            // The input token's mint
    destinationMint,       // The output token's mint
    swapMode,              // The swap mode (ExactIn or ExactOut)
    legIndex,              // The index of the current leg in the swap route
    isLastLeg,             // Boolean indicating if this is the last leg in the route
    platformFeeBps,        // Platform fee in basis points (bps)
}) {
    const feePercentage = platformFeeBps / 100; // Convert bps to percentage (e.g., 50 bps = 0.5%)
    
    // Case 1: Last leg in ExactIn mode - Calculate fee based on outAmount
    if (isLastLeg && swapMode === exports.SwapMode.ExactIn) {
        const feeAmount = _.default.divide(
            _.default.multiply(quote.outAmount, _.default.BigInt(platformFeeBps)),
            Cn
        );

        return {
            amount: feeAmount,
            mint: destinationMint.toBase58(), // Fee is in terms of the destination token
            pct: feePercentage,               // Percentage fee
        };
    }

    // Case 2: First leg in ExactOut mode - Calculate fee based on inAmount
    if (legIndex === 0 && swapMode === exports.SwapMode.ExactOut) {
        const feeAmount = _.default.divide(
            _.default.multiply(quote.inAmount, _.default.BigInt(platformFeeBps)),
            Cn
        );

        return {
            amount: feeAmount,
            mint: sourceMint.toBase58(),     // Fee is in terms of the source token
            pct: feePercentage,              // Percentage fee
        };
    }

    // Case 3: No fee for intermediate legs or other cases
    return {
        amount: i.ZERO,                    // No fee applied
        mint: destinationMint.toBase58(),  // Still return the destination token
        pct: 0,                            // 0% fee
    };
}





class Jupiter {
    constructor(t, n, o, i, a, s, r = 0, u = !0, d, l, p) {
        (this.connection = void 0),
            (this.cluster = void 0),
            (this.tokenRouteSegments = void 0),
            (this.feeCalculator = void 0),
            (this.platformFeeAndAccounts = void 0),
            (this.quoteMintToReferrer = void 0),
            (this.routeCacheDuration = void 0),
            (this.wrapUnwrapSOL = void 0),
            (this.intermediateTokens = void 0),
            (this.shouldLoadSerumOpenOrders = void 0),
            (this.addressLookupTableProvider = void 0),
            (this.serumOpenOrdersPromise = void 0),
            (this.user = void 0),
            (this.routeCache = new Map()),
            (this.routeSegmentCache = new L.default({ max: 500 })),
            (this.getDepositAndFees = async ({
                marketInfos: e,
                userPublicKey: t,
                serumOpenOrdersPromise: n = Promise.resolve(new Map()),
            }) =>
                (async ({
                    connection: e,
                    owner: t,
                    inputMint: n,
                    marketInfos: o,
                    feeCalculator: i,
                    serumOpenOrdersPromise: a,
                    wrapUnwrapSOL: s,
                }) => {
                    const r = await Promise.all(
                            o.map(async (n) => {
                                const o = n.amm;

                                if (o instanceof Zt || o instanceof sn) {
                                    if (!o.market) return;

                                    return await On(e, t.publicKey, o.market, await a);
                                }
                            })
                        ),
                        {
                            userIntermediaryTokenAccountResults: u,
                            userDestinationTokenAccountResult: c,
                        } = await m.getAtaInstructions({
                            connection: e,
                            outputMints: o.map((e) => e.outputMint),
                            owner: t,
                            unwrapSOL: s,
                        }),
                        d =
                            !!s &&
                            [n, ...o.map((e) => e.outputMint)].some((e) =>
                                e.equals(m.WRAPPED_SOL_MINT)
                            );

                    return m.calculateTransactionDepositAndFee({
                        intermediates: u,
                        destination: c,
                        openOrders: r,
                        hasWrapUnwrapSOL: d,
                        feeCalculator: i,
                    });
                })({
                    connection: this.connection,
                    feeCalculator: this.feeCalculator,
                    inputMint: e[0].inputMint,
                    marketInfos: e,
                    serumOpenOrdersPromise: n,
                    owner: new m.Owner(t),
                    wrapUnwrapSOL: this.wrapUnwrapSOL,
                })),
            (this.getDepositAndFeesForUser = ({ marketInfos: e }) => {
                if (this.user && this.serumOpenOrdersPromise) {
                    const t = new m.Owner(this.user);

                    return this.getDepositAndFees({
                        marketInfos: e,
                        userPublicKey: t.publicKey,
                        serumOpenOrdersPromise: this.serumOpenOrdersPromise,
                    });
                }
                return Promise.resolve(void 0);
            }),
            (this.exchange = async ({
                routeInfo: t,
                userPublicKey: n,
                feeAccount: o,
                wrapUnwrapSOL: i,
                blockhashWithExpiryBlockHeight: a,
                asLegacyTransaction: s,
                computeUnitPriceMicroLamports: r,
            }) => {
                var u;

                const { connection: d, serumOpenOrdersPromise: l } = this,
                    p = n || this.user;

                if (!p) throw new Error("user not found");

                const h = new m.Owner(p),
                    g = t.marketInfos.length - 1,
                    A = t.marketInfos[0].inputMint,
                    f = t.marketInfos[g].outputMint,
                    S = null != i ? i : this.wrapUnwrapSOL,
                    [k, y, M] = await Promise.all([
                        A.equals(m.WRAPPED_SOL_MINT) && S
                            ? m.createAndCloseWSOLAccount({
                                    connection: d,
                                    owner: h,
                                    amount:
                                        t.swapMode === exports.SwapMode.ExactIn
                                            ? t.amount
                                            : t.otherAmountThreshold,
                                })
                            : {
                                    ...m.getEmptyInstruction(),
                                    address: m.findAssociatedTokenAddress({
                                        tokenMintAddress: A,
                                        walletAddress: h.publicKey,
                                    }),
                                },
                        m.getAtaInstructions({
                            connection: d,
                            outputMints: t.marketInfos.map((e) => e.outputMint),
                            owner: h,
                            unwrapSOL: S,
                        }),
                        Promise.all(
                            t.marketInfos.map(async ({ amm: e }) => {
                                if (e instanceof Zt || e instanceof sn) {
                                    if (!e.market) return;

                                    return await On(d, h.publicKey, e.market, await l);
                                }
                            })
                        ),
                    ]),
                    w = {
                        intermediates: y.userIntermediaryTokenAccountResults,
                        destination: y.userDestinationTokenAccountResult,
                        openOrders: M,
                    },
                    P = w.openOrders.filter(Boolean).length > 0,
                    T = (o =
                        null !== (u = o) && void 0 !== u
                            ? u
                            : t.swapMode === exports.SwapMode.ExactIn
                            ? this.platformFeeAndAccounts.feeAccounts.get(f.toBase58())
                            : this.platformFeeAndAccounts.feeAccounts.get(A.toBase58()))
                        ? {
                                feeBps:
                                    this.platformFeeAndAccounts.feeBps ||
                                    Math.floor(100 * t.marketInfos[g].platformFee.pct),
                                feeAccount: o,
                            }
                        : void 0,
                    { instruction: I } = await (async function ({
                        user: t,
                        openOrdersAddresses: n,
                        userSourceTokenAccountAddress: o,
                        userIntermediateTokenAccountAddresses: i,
                        userDestinationTokenAccountAddress: a,
                        routeInfo: s,
                        platformFee: r,
                        computeUnitPriceMicroLamports: u,
                        quoteMintToReferrer: d,
                    }) {
                        if (s.marketInfos.length - 1 !== i.length)
                            throw new Error("Missing intermediary token account address");

                        const l = [o, ...i, a],
                            p = !!r && r.feeBps > 0,
                            h = t.publicKey,
                            g = [e.ComputeBudgetProgram.setComputeUnitLimit({ units: 14e5 })];

                        u &&
                            u > 0 &&
                            g.push(
                                e.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: u })
                            );

                        const A = [];

                        if (s.swapMode === exports.SwapMode.ExactIn) {
                            const e = (function (e, t, n, o, i, a, s, r) {
                                    const u = [],
                                        m = [];

                                    for (const [t, o] of e.marketInfos.entries()) {
                                        const r = o.amm,
                                            [c, d] = i.slice(t),
                                            [l, p] = r.getSwapLegAndAccounts({
                                                sourceMint: o.inputMint,
                                                destinationMint: o.outputMint,
                                                userSourceTokenAccount: c,
                                                userDestinationTokenAccount: d,
                                                userTransferAuthority: n,
                                                openOrdersAddress: a[t],
                                                quoteMintToReferrer: s,
                                                swapMode: e.swapMode,
                                                amount: o.inAmount,
                                            });

                                        u.push(l), m.push(...p);
                                    }
                                    return (
                                        t &&
                                            r &&
                                            m.push({
                                                pubkey: r.feeAccount,
                                                isWritable: !0,
                                                isSigner: !1,
                                            }),
                                        {
                                            swapInstruction: Fe(
                                                n,
                                                o,
                                                Me(u),
                                                m,
                                                new c.BN(e.amount.toString()),
                                                new c.BN(e.outAmount.toString()),
                                                e.slippageBps,
                                                t && r ? r.feeBps : 0
                                            ),
                                        }
                                    );
                                })(s, p, h, a, l, n, d, r),
                                { swapInstruction: t } = e;

                            A.push(t);
                        } else if (s.swapMode === exports.SwapMode.ExactOut) {
                            const { swapInstruction: e } = (function (e, t, n, o, i, a) {
                                const s = e.marketInfos[0],
                                    r = s.amm;

                                if (r.createExactOutSwapInstruction)
                                    return {
                                        swapInstruction: r.createExactOutSwapInstruction({
                                            sourceMint: s.inputMint,
                                            destinationMint: s.outputMint,
                                            userSourceTokenAccount: n,
                                            userDestinationTokenAccount: o,
                                            userTransferAuthority: t,
                                            quoteMintToReferrer: i,
                                            swapMode: e.swapMode,
                                            amount: e.amount,
                                            slippageBps: e.slippageBps,
                                            inAmount: e.inAmount,
                                            platformFee: a,
                                            overflowFeeAccount:
                                                null == i ? void 0 : i.get(s.inputMint.toBase58()),
                                        }),
                                    };

                                throw new Error(`ExactOutInstruction missing for ${r.label}.`);
                            })(s, h, o, a, d, r);

                            A.push(e);
                        }
                        const { signers: f, cleanupInstructions: S } =
                            m.getEmptyInstruction();

                        return (
                            t.isKeyPair && t.signer && f.push(t.signer),
                            {
                                instruction: {
                                    setupInstructions: g,
                                    signers: f,
                                    cleanupInstructions: S,
                                    instructions: A,
                                },
                            }
                        );
                    })({
                        user: h,
                        openOrdersAddresses: w.openOrders.map((e) =>
                            null == e ? void 0 : e.address
                        ),
                        userSourceTokenAccountAddress: k.address,
                        userIntermediateTokenAccountAddresses: w.intermediates.map(
                            ({ address: e }) => e
                        ),
                        userDestinationTokenAccountAddress: w.destination.address,
                        routeInfo: t,
                        platformFee: T,
                        computeUnitPriceMicroLamports: r,
                        quoteMintToReferrer: this.quoteMintToReferrer,
                        asLegacyTransaction: s,
                    }),
                    b = new m.TransactionBuilder(d, h.publicKey, h),
                    v = [
                        ...w.intermediates,
                        k,
                        !w.destination.address.equals(k.address) && w.destination,
                    ];

                b.addInstruction(I),
                    P &&
                        w.openOrders.forEach((e) => {
                            e && b.addInstruction(e);
                        }),
                    v.forEach((e) => {
                        e && b.addInstruction(e);
                    }),
                    (a = a || (await this.connection.getLatestBlockhash("confirmed")));

                const R =
                        await this.addressLookupTableProvider.getAdressLookupTableAccounts(
                            t.marketInfos
                                .map(({ amm: e }) =>
                                    e instanceof sn ? [e.firstAmm.id, e.secondAmm.id] : e.id
                                )
                                .flat()
                        ),
                    { transaction: B } = await b.build(a, R, s),
                    O = w;

                return {
                    swapTransaction: B,
                    addressLookupTableAccounts: R,
                    execute: ({ wallet: e, onTransaction: t } = {}) =>
                        m
                            .executeTransaction({
                                connection: this.connection,
                                wallet: e,
                                onTransaction: t,
                                inputMint: A,
                                outputMint: f,
                                sourceAddress: k.address,
                                destinationAddress: O.destination.address,
                                swapTransaction: B,
                                owner: h,
                                wrapUnwrapSOL: S,
                            })
                            .finally(() => {
                                this.routeCache.clear();
                            }),
                };
            }),
            (this.connection = t),
            (this.cluster = n),
            (this.tokenRouteSegments = o),
            (this.feeCalculator = i),
            (this.platformFeeAndAccounts = a),
            (this.quoteMintToReferrer = s),
            (this.routeCacheDuration = r),
            (this.wrapUnwrapSOL = u),
            (this.intermediateTokens = d),
            (this.shouldLoadSerumOpenOrders = l),
            (this.addressLookupTableProvider = p);
    }
    static async load({
        connection: t,
        cluster: n,
        user: o,
        platformFeeAndAccounts: i = Dn,
        quoteMintToReferrer: a,
        routeCacheDuration: s = 0,
        wrapUnwrapSOL: r = !0,
        marketsCache: u,
        restrictIntermediateTokens: c = !1,
        shouldLoadSerumOpenOrders: d = !1,
        ammsToExclude: l = { GooseFX: !0, Serum: !0 },
        mintsToExclude: p = [],
        usePreloadedAddressLookupTableCache: h = !1,
    }) {
        const [
                {
                    tokenRouteSegments: g,
                    addressLookupTableProvider: A,
                    saberWrapperMints: f,
                },
                {
                    value: { feeCalculator: S },
                },
                k,
            ] = await Promise.all([
                Jupiter.loadCoreData({
                    connection: t,
                    cluster: n,
                    marketsCache: u,
                    ammsToExclude: l,
                    mintsToExclude: p,
                    usePreloadedAddressLookupTableCache: h,
                }),
                t.getRecentBlockhashAndContext("processed"),
                null != a ? a : En(t, new e.PublicKey(m.JUPITER_FEE_OWNER)),
            ]),
            y =
                !0 === c
                    ? await Jupiter.getIntermediateTokens(f)
                    : c
                    ? c.intermediateTokens
                    : void 0,
            M = new Jupiter(t, n, g, S, i, k, s, r, y ? new Set(y) : void 0, d, A);

        return o && M.setUserPublicKey(o), M;
    }
    static async loadCoreData({
        connection: e,
        cluster: t,
        marketsCache: n,
        ammsToExclude: o,
        mintsToExclude: i,
        usePreloadedAddressLookupTableCache: a,
    }) {
        let s;

        s =
            !n || "url" in n
                ? await (async (e) => await (await N.default(e)).json())(
                        (null == n ? void 0 : n.url) || m.MARKETS_URL[t]
                    )
                : n;

        const {
            amms: amms,
            saberWrapperMints: u,
            addressLookupTableProvider: c,
        } = await Jupiter.fetchAmms(e, s, o, i, a);

        return {
            tokenRouteSegments: buildTokenRouteSegments(amms),
            addressLookupTableProvider: c,
            saberWrapperMints: u,
        };
    }
    getAccountToAmmIdsMap() {
        const e = new Map();

        return (
            this.tokenRouteSegments.forEach((t) => {
                Array.from(t.values()).forEach((t) => {
                    t.forEach((t) => {
                        t.getAccountsForUpdate().forEach((n) => {
                            const o = e.get(n.toBase58()) || new Set();

                            o.add(t.id), e.set(n.toBase58(), o);
                        });
                    });
                });
            }),
            e
        );
    }
    getAmmIdToAmmMap() {
        const e = new Map();

        return (
            this.tokenRouteSegments.forEach((t) => {
                Array.from(t.values()).forEach((t) => {
                    t.forEach((t) => {
                        e.set(t.id, t);
                    });
                });
            }),
            e
        );
    }
    // async computeRoutes({
    //     inputMint: e,
    //     outputMint: t,
    //     amount: n,
    //     slippageBps: o,
    //     feeBps: i = 0,
    //     forceFetch: a,
    //     onlyDirectRoutes: s,
    //     swapMode: r = exports.SwapMode.ExactIn,
    //     filterTopNResult: u,
    //     asLegacyTransaction: c,
    // }) {
    //     const m = e.toBase58(),
    //         d = t.toBase58(),
    //         l =
    //             i ||
    //             (this.platformFeeAndAccounts.feeAccounts.get(d)
    //                 ? this.platformFeeAndAccounts.feeBps
    //                 : 0),
    //         p = new Date().getTime(),
    //         h = [m, d].sort((e, t) => e.localeCompare(t)).join() + s + r + c,
    //         g = this.routeCache.get(h);

    //     let A = this.routeSegmentCache.get(h);

    //     A ||
    //         ((A = (function ({
    //             inputMint: e,
    //             outputMint: t,
    //             tokenRouteSegments: n,
    //             swapMode: o,
    //             intermediateTokens: i,
    //             onlyDirectRoutes: a,
    //             asLegacyTransaction: s,
    //         }) {
    //             const r = new Map(),
    //                 u = n.get(e),
    //                 c = n.get(t);

    //             if (u && c) {
    //                 const m = Math.min(u.size, c.size),
    //                     d = new Map(),
    //                     l = new Map(),
    //                     [p, h, g, A] = [u, c, e, t];

    //                 for (let [e, t] of p.entries()) {
    //                     if (
    //                         ((t =
    //                             o === exports.SwapMode.ExactIn
    //                                 ? t.slice()
    //                                 : t.filter((e) => e.exactOutputSupported)),
    //                         e === A)
    //                     ) {
    //                         const e = t;

    //                         d.set(A, e), l.set(g, e);

    //                         continue;
    //                     }
    //                     if (a || o === exports.SwapMode.ExactOut || Bn(i, m, e)) continue;

    //                     let u = n.get(e) || new Map();

    //                     for (let [n, o] of u) {
    //                         if (((o = o.slice()), n === A)) {
    //                             const n = o,
    //                                 i = r.get(e) || new Map();

    //                             if (
    //                                 (i.set(g, t),
    //                                 i.set(A, n),
    //                                 r.set(e, i),
    //                                 d.set(e, t),
    //                                 l.set(e, n),
    //                                 s)
    //                             )
    //                                 break;
    //                         }
    //                         if (!s) {
    //                             if (Bn(i, m, n)) continue;

    //                             const a = h.get(n);

    //                             if (a) {
    //                                 d.set(e, t);

    //                                 const i = r.get(e) || new Map();

    //                                 i.set(n, o), r.set(e, i);

    //                                 const s = r.get(n) || new Map();

    //                                 s.set(e, o), r.set(n, s);

    //                                 const u = r.get(n) || new Map();

    //                                 u.set(A, a), r.set(n, u), l.set(n, a);
    //                             }
    //                         }
    //                     }
    //                 }
    //                 r.set(g, d), r.set(A, l);
    //             }
    //             return r;
    //         })({
    //             inputMint: m,
    //             outputMint: d,
    //             tokenRouteSegments: this.tokenRouteSegments,
    //             intermediateTokens: this.intermediateTokens,
    //             onlyDirectRoutes: s,
    //             swapMode: r,
    //             asLegacyTransaction: c,
    //         })),
    //         this.routeSegmentCache.set(h, A));

    //     let f = !1;

    //     if (-1 === this.routeCacheDuration) f = !1;
    //     else if (0 === this.routeCacheDuration) f = !0;
    //     else if (g) {
    //         const { fetchTimestamp: e } = g;

    //         p - e > this.routeCacheDuration && (f = !0);
    //     } else f = !0;

    //     (a || f) &&
    //         (await (async function (e, t) {
    //             const n = new Map(),
    //                 o = new Set(),
    //                 i = new Map();

    //             t.forEach((e) => {
    //                 e.forEach((e) => {
    //                     e.forEach((e) => {
    //                         i.set(e.id, e),
    //                             e.getAccountsForUpdate().forEach((e) => {
    //                                 o.add(e.toBase58());
    //                             });
    //                     });
    //                 });
    //             });

    //             const a = Array.from(o);

    //             a.length > 0 &&
    //                 ((await z(e, a)).forEach((e, t) => {
    //                     e && n.set(a[t], e);
    //                 }),
    //                 i.forEach((e) => {
    //                     e.update(n);
    //                 }));
    //         })(this.connection, A),
    //         this.routeCache.set(h, { fetchTimestamp: new Date().getTime() }));

    //     try {
    //         return {
    //             routesInfos: await findBestRoute({
    //                 inputRouteSegment: A,
    //                 inputMint: e,
    //                 outputMint: t,
    //                 amount: n,
    //                 getDepositAndFeeForRoute: this.getDepositAndFeesForUser,
    //                 onlyDirectRoutes: s,
    //                 slippageBps: o,
    //                 platformFeeBps: l,
    //                 filterTopNResult: u,
    //                 swapMode: r,
    //                 asLegacyTransaction: c,
    //             }),
    //             cached: !(a || f),
    //         };
    //     } catch (e) {
    //         throw e;
    //     } finally {
    //         this.routeCache.forEach(({ fetchTimestamp: e }, t) => {
    //             e - p > this.routeCacheDuration && this.routeCache.delete(t);
    //         });
    //     }
    // }


    // Method to compute the best routes for token swaps based on input/output mints, amount, and swap options
    async computeRoutes({
        inputMint,                  // e: The mint of the input token
        outputMint,                 // t: The mint of the output token
        amount,                     // n: Amount to be swapped
        slippageBps,                // o: Slippage tolerance in basis points
        feeBps = 0,                 // i: Platform fee in basis points (default is 0)
        forceFetch,                 // a: Force fetching new routes, ignoring cached data
        onlyDirectRoutes,           // s: Whether to include only direct routes (no intermediate tokens)
        swapMode = exports.SwapMode.ExactIn, // r: Mode of the swap (ExactIn or ExactOut)
        filterTopNResult,           // u: Limit to top N results (optional)
        asLegacyTransaction,        // c: Boolean flag for using legacy transaction format
    }) {
        // Convert input/output mints to Base58 string format for caching and comparison
        const inputMintBase58 = inputMint.toBase58();
        const outputMintBase58 = outputMint.toBase58();
        
        // Calculate the effective platform fee (either provided directly or fetched from accounts)
        const effectivePlatformFeeBps = feeBps || (this.platformFeeAndAccounts.feeAccounts.get(outputMintBase58)
            ? this.platformFeeAndAccounts.feeBps
            : 0);

        // Get the current timestamp (used for caching purposes)
        const currentTime = new Date().getTime();
        
        // Generate a cache key based on mints, swap mode, and transaction type
        const cacheKey = [inputMintBase58, outputMintBase58].sort((a, b) => a.localeCompare(b)).join() + onlyDirectRoutes + swapMode + asLegacyTransaction;
        
        // Retrieve cached route data
        const cachedRoute = this.routeCache.get(cacheKey);
        
        // Check if there's a cached route segment
        let routeSegment = this.routeSegmentCache.get(cacheKey);

        // If no cached route segment exists, generate new route segment data
        if (!routeSegment) {
            routeSegment = (function generateRouteSegments({
                inputMint,              // Mint for the input token
                outputMint,             // Mint for the output token
                tokenRouteSegments,     // Map containing available token route segments
                swapMode,               // The swap mode (ExactIn/ExactOut)
                intermediateTokens,     // Optional intermediate tokens that can be used in the route
                onlyDirectRoutes,       // Whether to restrict to only direct routes
                asLegacyTransaction,    // Whether to use legacy transaction format
            }) {
                const routeMap = new Map();
                const inputRoutes = tokenRouteSegments.get(inputMint);
                const outputRoutes = tokenRouteSegments.get(outputMint);

                if (inputRoutes && outputRoutes) {
                    const minRouteSize = Math.min(inputRoutes.size, outputRoutes.size);
                    const inputRouteMap = new Map();
                    const outputRouteMap = new Map();

                    for (let [mint, route] of inputRoutes.entries()) {
                        // Modify route based on swap mode (filter for exact output if necessary)
                        if (swapMode === exports.SwapMode.ExactIn) {
                            route = route.slice();
                        } else {
                            route = route.filter((r) => r.exactOutputSupported);
                        }

                        // If this mint equals the output mint, store the direct route
                        if (mint === outputMint) {
                            inputRouteMap.set(outputMint, route);
                            outputRouteMap.set(inputMint, route);
                            continue;
                        }

                        // Skip routes that don't meet the filter conditions
                        if (onlyDirectRoutes || swapMode === exports.SwapMode.ExactOut || shouldExcludeIntermediateToken(intermediateTokens, minRouteSize, mint)) {
                            continue;
                        }

                        // Get intermediate routes
                        const intermediateRoutes = tokenRouteSegments.get(mint) || new Map();

                        for (let [intermediateMint, intermediateRoute] of intermediateRoutes) {
                            if (intermediateMint === outputMint) {
                                const finalRoute = intermediateRoute;
                                const inputRoute = routeMap.get(mint) || new Map();
                                inputRoute.set(inputMint, route);
                                inputRoute.set(outputMint, finalRoute);
                                routeMap.set(mint, inputRoute);

                                inputRouteMap.set(mint, route);
                                outputRouteMap.set(mint, finalRoute);

                                if (asLegacyTransaction) break;
                            }
                        }
                    }
                    routeMap.set(inputMint, inputRouteMap);
                    routeMap.set(outputMint, outputRouteMap);
                }

                return routeMap;
            })({
                inputMint: inputMintBase58,
                outputMint: outputMintBase58,
                tokenRouteSegments: this.tokenRouteSegments,
                intermediateTokens: this.intermediateTokens,
                onlyDirectRoutes,
                swapMode,
                asLegacyTransaction,
            });

            // Cache the generated route segment
            this.routeSegmentCache.set(cacheKey, routeSegment);
        }

        // Check if the route cache should be refreshed
        let needsRouteRefresh = false;

        if (this.routeCacheDuration === -1) {
            needsRouteRefresh = false;
        } else if (this.routeCacheDuration === 0) {
            needsRouteRefresh = true;
        } else if (cachedRoute) {
            const { fetchTimestamp } = cachedRoute;
            if (currentTime - fetchTimestamp > this.routeCacheDuration) {
                needsRouteRefresh = true;
            }
        } else {
            needsRouteRefresh = true;
        }

        // Fetch new route data if necessary
        if (forceFetch || needsRouteRefresh) {
            await (async function updateRouteSegments(connection, routeSegmentData) {
                const updatedData = new Map();
                const mintSet = new Set();
                const ammMap = new Map();

                // Gather all the AMM account updates
                routeSegmentData.forEach((routes) => {
                    routes.forEach((route) => {
                        route.forEach((amm) => {
                            ammMap.set(amm.id, amm);
                            amm.getAccountsForUpdate().forEach((account) => {
                                mintSet.add(account.toBase58());
                            });
                        });
                    });
                });

                // Convert Set to Array and fetch updates
                const accountArray = Array.from(mintSet);
                if (accountArray.length > 0) {
                    const fetchedUpdates = await z(connection, accountArray);
                    fetchedUpdates.forEach((data, index) => {
                        if (data) updatedData.set(accountArray[index], data);
                    });

                    // Update AMMs with the new data
                    ammMap.forEach((amm) => {
                        amm.update(updatedData);
                    });
                }
            })(this.connection, routeSegment);

            // Update the route cache with the new fetch timestamp
            this.routeCache.set(cacheKey, { fetchTimestamp: currentTime });
        }

        try {
            // Compute the best routes using the `findBestRoute` function
            return {
                routesInfos: await findBestRoute({
                    inputRouteSegment: routeSegment,
                    inputMint,
                    outputMint,
                    amount,
                    getDepositAndFeeForRoute: this.getDepositAndFeesForUser,
                    onlyDirectRoutes,
                    slippageBps,
                    platformFeeBps: effectivePlatformFeeBps,
                    filterTopNResult,
                    swapMode,
                    asLegacyTransaction,
                }),
                cached: !(forceFetch || needsRouteRefresh),  // Indicate whether the result is from cache
            };
        } catch (error) {
            throw error;
        } finally {
            // Clear old route cache entries
            this.routeCache.forEach(({ fetchTimestamp }, cacheKey) => {
                if (currentTime - fetchTimestamp > this.routeCacheDuration) {
                    this.routeCache.delete(cacheKey);
                }
            });
        }
    }












    setUserPublicKey(e) {
        this.user = e;

        const t = new m.Owner(this.user);

        this.serumOpenOrdersPromise = this.shouldLoadSerumOpenOrders
            ? Jupiter.findSerumOpenOrdersForOwner({
                    connection: this.connection,
                    cluster: this.cluster,
                    userPublicKey: t.publicKey,
                })
            : Promise.resolve(new Map());
    }
    static async fetchAmms(t, n, o, i, a = !1) {
        return (async function ({
            connection: t,
            marketsCache: n,
            usePreloadedAddressLookupTableCache: o,
            ammsToExclude: i = {},
            mintsToExclude: a = [],
        }) {
            const s = ((t) =>
                t.map((t) => {
                    const {
                        data: [n, o],
                        pubkey: i,
                        ...a
                    } = t;

                    return {
                        ...a,
                        pubkey: new e.PublicKey(i),
                        data: Buffer.from(n, o),
                        owner: new e.PublicKey(a.owner),
                    };
                }))(n);

            {
                const e = [];

                if (e.length) {
                    const n = await (async function (e, t) {
                        return await Promise.all(
                            (
                                await z(
                                    e,
                                    t.map((e) => e.toBase58())
                                )
                            ).map(async (e, n) => {
                                const o = t[n];

                                if (!e) throw new Error(`Failed to fetch pool ${o.toBase58()}`);

                                return { pubkey: o, ...e };
                            })
                        );
                    })(t, e);

                    s.push(...n);
                }
            }
            const r = [],
                u = [],
                c = s.map((e) => e.pubkey.toBase58()),
                m = await z(t, c),
                d = new Set(a.map((e) => e.toBase58())),
                l = s
                    .filter((e, t) => m[t])
                    .reduce((e, t) => {
                        try {
                            const n = wn(t.pubkey, t, t.params);

                            if (n) {
                                if (Y(i, n.label)) return e;

                                if (
                                    a &&
                                    a.length &&
                                    n.reserveTokenMints.some((e) => d.has(e.toBase58()))
                                )
                                    return e;

                                e.push(n),
                                    n.shouldPrefetch && r.push(n),
                                    n instanceof Vt && u.push(n.wrapperMint.toBase58());
                            }
                        } catch (e) {}
                        return e;
                    }, new Array()),
                [p, h, g] = await Promise.all([
                    $(r, t),
                    M.loadWasm(),
                    await In(t, n, o),
                ]);

            return { amms: l, saberWrapperMints: u, addressLookupTableProvider: g };
        })({
            connection: t,
            marketsCache: n,
            ammsToExclude: o,
            mintsToExclude: i,
            usePreloadedAddressLookupTableCache: a,
        });
    }
    getRouteMap(e, t) {
        return (function (e, t, n, o) {
            const i = new Map(),
                a = new Set(e.keys());

            a.forEach((e) => {
                i.set(e, new Set());
            });

            for (const [A, f] of e) {
                const S = new Set(a);

                for (let e of f.keys()) {
                    var s, r;

                    null === (s = i.get(A)) || void 0 === s || s.add(e),
                        null === (r = i.get(e)) || void 0 === r || r.add(A),
                        S.delete(e);
                }
                if (!n)
                    for (let a of S) {
                        var u;

                        let s = null === (u = i.get(A)) || void 0 === u ? void 0 : u.has(a);

                        if (s) continue;

                        const r = e.get(A),
                            f = e.get(a);

                        if (r && f) {
                            const u = Math.min(r.size, f.size);

                            let [S, k, y, M] = [r, f, A, a];

                            for (let [r, f] of S.entries()) {
                                if (n || shouldExcludeIntermediateToken(t, u, r)) continue;

                                let S = e.get(r) || new Map();

                                for (let [e, n] of S) {
                                    if (e === M) {
                                        if (!o) {
                                            var c, m;

                                            null === (c = i.get(A)) || void 0 === c || c.add(a),
                                                null === (m = i.get(a)) || void 0 === m || m.add(A),
                                                (s = !0);

                                            break;
                                        }
                                        for (let e of f) {
                                            for (let t of n)
                                                if (yn({ amms: [e, t], asLegacyTransaction: o })) {
                                                    var d, l;

                                                    null === (d = i.get(A)) || void 0 === d || d.add(a),
                                                        null === (l = i.get(a)) || void 0 === l || l.add(A),
                                                        (s = !0);

                                                    break;
                                                }
                                            if (s) break;
                                        }
                                    }
                                    if (!o) {
                                        var p;

                                        if (shouldExcludeIntermediateToken(t, u, e)) continue;

                                        if (
                                            null === (p = k.get(e)) || void 0 === p
                                                ? void 0
                                                : p.slice()
                                        ) {
                                            var h, g;

                                            null === (h = i.get(A)) || void 0 === h || h.add(a),
                                                null === (g = i.get(a)) || void 0 === g || g.add(A),
                                                (s = !0);

                                            break;
                                        }
                                    }
                                }
                                if (s) break;
                            }
                        }
                    }
            }
            return Array.from(i.entries()).reduce(
                (e, [t, n]) => (e.set(t, [...n]), e),
                new Map()
            );
        })(this.tokenRouteSegments, this.intermediateTokens, e, t);
    }



    static async getIntermediateTokens(e) {
        const t = await (async function () {
            const e = await (
                await N.default("https://cache.jup.ag/top-tokens")
            ).json();

            return new Set(e.filter((e, t) => t < 60));
        })();

        for (const e of Ie) t.add(e);

        return e.forEach((e) => t.add(e)), Array.from(t);
    }

    
}
 

Jupiter.getRemoteRouteMap = m.getRemoteRouteMap, 

Jupiter.findSerumOpenOrdersForOwner = async ({ userPublicKey: e, cluster: t, connection: o }) => {
    const i = new Map;

    if (e) {
        const a = "mainnet-beta" === t ? m.MAINNET_SERUM_DEX_PROGRAM : m.DEVNET_SERUM_DEX_PROGRAM;

        (await n.OpenOrders.findForOwner(o, e, a)).forEach((e => { i.set(e.market.toString(), e.address) }))
    } return i
}, 

exports.AldrinAmm = AldrinAmm, 

exports.BalansolAmm = BalansolAmm, 

exports.CremaAmm = CremaAmm, 

exports.CropperAmm = CropperAmm, 

exports.CykuraAmm = CykuraAmm, 

exports.DeltaFiAmm = class DeltaFiAmm {
    constructor(t, n) {
        (this.address = void 0),
            (this.id = void 0),
            (this.label = "DeltaFi"),
            (this.shouldPrefetch = !1),
            (this.exactOutputSupported = !1),
            (this.hasDynamicAccounts = !1),
            (this.swapInfo = void 0),
            (this.feePct = void 0),
            (this.prices = void 0),
            (this.pythAddresses = void 0),
            (this.address = t),
            (this.id = t.toBase58()),
            (this.swapInfo = ct.coder.accounts.decode("SwapInfo", n.data));

        const { swapConfig: o } = this.swapInfo;

        (this.feePct = o.tradeFeeNumerator / o.tradeFeeDenominator),
            (this.pythAddresses = [
                this.swapInfo.pythPriceBase,
                this.swapInfo.pythPriceQuote,
            ].filter((t) => !e.SystemProgram.programId.equals(t)));
    }
    getAccountsForUpdate() {
        return [this.address, ...this.pythAddresses];
    }
    getPriceData(e, t) {
        const { id: n } = this,
            o = e.get(t.toBase58()) || ut[n];

        if (!o) throw new Error(`Missing pyth account info for ${t.toBase58()}`);

        return "data" in o ? k.parsePriceData(o.data) : o;
    }
    update(e) {
        const t = e.get(this.address.toBase58());

        if (!t) throw new Error(`Missing ${this.address.toBase58()}`);

        this.swapInfo = ct.coder.accounts.decode("SwapInfo", t.data);

        try {
            const t = this.getPriceData(e, this.swapInfo.pythPriceBase),
                n = this.getPriceData(e, this.swapInfo.pythPriceQuote);

            if (t.price && n.price) {
                const e = new y.BigNumber(t.price).dividedBy(new y.BigNumber(n.price)),
                    o = new y.BigNumber(t.price + t.confidence).dividedBy(
                        new y.BigNumber(n.price - n.confidence)
                    ),
                    i = new y.BigNumber(t.price - t.confidence).dividedBy(
                        new y.BigNumber(n.price + n.confidence)
                    );

                this.prices = { marketPrice: e, highPrice: o, lowPrice: i };
            } else this.prices = void 0;
        } catch (e) {
            this.prices = void 0;
        }
    }
    getQuote({ destinationMint: e, amount: t }) {
        if (!this.prices) throw new Error("Missing price data from pyth");

        const { swapInfo: n } = this,
            {
                amountIn: o,
                amountOut: i,
                priceImpact: a,
            } = S.getSwappedAmountsAndPriceImpactFromRawValue(
                n,
                e.equals(n.mintQuote) ? { sellBase: {} } : { sellQuote: {} },
                new y.BigNumber(t.toString()),
                this.prices.marketPrice,
                this.prices.highPrice,
                this.prices.lowPrice
            ),
            s = i
                .multipliedBy(n.swapConfig.tradeFeeNumerator.toString())
                .dividedBy(n.swapConfig.tradeFeeDenominator.toString())
                .decimalPlaces(0),
            r = i.minus(s);

        return {
            notEnoughLiquidity: !1,
            inAmount: _.default.BigInt(o),
            outAmount: _.default.BigInt(r),
            feeAmount: _.default.BigInt(s),
            feeMint: e.toBase58(),
            feePct: this.feePct,
            priceImpactPct: Number(a),
        };
    }
    getSwapLegAndAccounts(e) {
        var t;

        if (!this.prices) throw new Error("Missing price data from pyth");

        const {
            swapSourceToken: n,
            swapDestinationToken: o,
            adminDestinationToken: i,
        } = this.swapInfo.mintBase.equals(e.sourceMint)
            ? {
                    swapSourceToken: this.swapInfo.tokenBase,
                    swapDestinationToken: this.swapInfo.tokenQuote,
                    adminDestinationToken: this.swapInfo.adminFeeTokenQuote,
                }
            : {
                    swapSourceToken: this.swapInfo.tokenQuote,
                    swapDestinationToken: this.swapInfo.tokenBase,
                    adminDestinationToken: this.swapInfo.adminFeeTokenBase,
                };

        return (function ({
            additionalArgs: e,
            userSourceTokenAccount: t,
            userDestinationTokenAccount: n,
            userTransferAuthority: o,
        }) {
            return [
                Pe(((i = e.stable), { deltaFi: { stable: i } })),
                m.JUPITER_PROGRAM.instruction.deltafiSwap({
                    accounts: {
                        swapProgram: m.DELTA_FI_PROGRAM_ID,
                        marketConfig: e.marketConfig,
                        swapInfo: e.swapInfo,
                        userSourceToken: t,
                        userDestinationToken: n,
                        swapSourceToken: e.swapSourceToken,
                        swapDestinationToken: e.swapDestinationToken,
                        deltafiUser: m.DELTA_FI_USER_ID,
                        adminDestinationToken: e.adminDestinationToken,
                        pythPriceBase: e.pythPriceBase,
                        pythPriceQuote: e.pythPriceQuote,
                        userAuthority: o,
                        tokenProgram: u.TOKEN_PROGRAM_ID,
                    },
                    remainingAccounts: e.referrer
                        ? [{ pubkey: e.referrer, isSigner: !1, isWritable: !0 }]
                        : [Ee],
                }).keys,
            ];

            var i;
        })({
            additionalArgs: {
                stable: !!this.swapInfo.swapType.stableSwap,
                marketConfig: this.swapInfo.configKey,
                swapInfo: this.address,
                swapSourceToken: n,
                swapDestinationToken: o,
                adminDestinationToken: i,
                pythPriceBase: this.swapInfo.pythPriceBase,
                pythPriceQuote: this.swapInfo.pythPriceQuote,
                referrer:
                    null === (t = e.quoteMintToReferrer) || void 0 === t
                        ? void 0
                        : t.get(e.destinationMint.toBase58()),
            },
            ...e,
        });
    }
    get reserveTokenMints() {
        return [this.swapInfo.mintQuote, this.swapInfo.mintBase];
    }
}

, 

exports.DradexAmm = mn, 

exports.FAKE_PROVIDER = be, 

exports.GooseFXAmm = ht, 

exports.IS_DEV = !0, 

exports.IS_PROD = !1, 

exports.IS_TEST = !1, 

exports.InvariantAmm = InvariantAmm, 

exports.Jupiter = Jupiter, 

exports.LifinityAmm = LifinityAmm, 

exports.LifinityV2Amm = LifinityV2Amm, 

exports.MIN_SEGMENT_SIZE_FOR_INTERMEDIATE_MINTS = 100, 

exports.MarcoPoloAmm = MarcoPoloAmm, 

exports.MarinadeAmm = MarinadeAmm, 

exports.MercurialAmm = MercurialAmm, 

exports.MeteoraAmm = MeteoraAmm, 

exports.PhoenixAmm = PhoenixAmm, 

exports.RaydiumAmm = RaydiumAmm, 

exports.RaydiumClmm = dn, 

exports.SWAP_PROTOCOL_TOKENS = Ie, 

exports.SaberAddDecimalsAmm = Vt, 

exports.SaberAmm = Gt, 

exports.SenchaAmm = Wt, 

exports.SerumAmm = Zt, 

exports.SplTokenSwapAmm = nn, 

exports.SplitTradeAmm = sn, 

exports.SymmetryAmm = kn, 

exports.WhirlpoolAmm = cn, 

exports.ammFactory = wn, 

exports.getPlatformFeeAccounts = En, 

exports.getRouteInfoUniqueId = function (e) { 
    return e.marketInfos.map((e => `${e.amm.id}-${e.inputMint}`)).join("-") 
}, 
    
Object.keys(m).forEach(
    (
        function (e) { 
            "default" === e 
            || exports.hasOwnProperty(e) 
            || Object.defineProperty(
                exports, 
                e, 
                { enumerable: !0, get: function () { return m[e] } }
            ) 
        }
    )

);

//# sourceMappingURL=core.cjs.development.min.js.map
